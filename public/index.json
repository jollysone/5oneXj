[{"categories":["基础知识"],"content":"0x00 前言 在合约代码中，最常用的是使用 msg.sender 来检查授权，但有时由于有些程序员不熟悉 tx.origin 和 msg.sender 的区别，如果使用了 tx.origin 可能导致合约的安全问题。黑客最典型的攻击场景是利用 tx.origin 的代码问题常与钓鱼攻击相结合的组合拳的方式进行攻击。 tx.origin是 Solidity 中的一个全局变量，它返回发送交易的账户地址。如果授权帐户调用恶意合约，使用变量进行授权可能会使合约容易受到攻击。可以调用通过授权检查的易受攻击的合约，因为tx.origin返回交易的原始发件人，在这种情况下是授权帐户。 通过调用 tx.origin 来检查授权可能会导致合约受到攻击，因为 tx.origin 返回交易的原始发送者，因为攻击的调用链可能是 原始发送者－\u003e攻击合约－\u003e 受攻击合约 。在受攻击合约中，tx.origin 是原始发送者。 0x01 前置知识 两者都是 Solidity 中的一个全局变量。 msg.sender: 指直接调用智能合约功能的帐户或智能合约的地址 tx.origin: 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin EOA 账户和合约账户 EOA 账户和合约账户 以太坊账户分两种，外部账户(EOA)和合约账户(SCA)。 外部账户由一对公私钥进行管理，账户包含着 Ether 的余额。 合约账户除了可以含有 Ether 余额外，还拥有一段特定的代码，预先设定代码逻辑在外部账户或其他合约对其合约地址发送消息或发生交易时被调用和处理。 外部账户 EOA 由公私钥对控制 拥有 ether 余额 可以发送交易（transactions） 不包含相关执行代码 合约账户 拥有 ether 余额 含有执行代码 代码仅在该合约地址发生交易或者收到其他合约发送的信息时才会被执行 拥有自己的独立存储状态，且可以调用其他合约 msg.sender 和 tx.origin 的区别 tx.origin：表示最初的调用者，通常取得的是 EOA 的地址。 msg.sender：表示最近的调用者，通常取得是的上级调用者的地址，可以是 EOA 地址，也可以是合约地址。 如果 EOA 用户 A 调用合约 B，合约 B 调用合约 C。那么 在 C 合约中，msg.sender 就是 B 合约的地址，tx.origin 为 A 地址。 在 B 合约中，msg.sender 是 A 地址，tx.origin 也为 A 地址。 通过判断tx.origin==msg.sender来确定调用者是合约还是 EOA 账户。 思考 ：可不可以通过判断一个账户的是否包含执行代码来区分这个账户是 EOA 还是 SCA? 不可以。因为一个合约地址的 CODESIZE是大于零的，但当地址的 CODESIZE等于零时，并不能保证其为非合约，因为合约在构造阶段 CODESIZE也为零。 漏洞演示 下面的漏洞合约代码，在 transfer 方法中做了检查，本意是只有 owner 可以进行 transfer 操作。在这里使用的是tx.origin==owner进行检查。我们假设该 Wallet 合约的部署者是 Alice. contract Wallet { address public owner; constructor() payable { owner = msg.sender; } function transfer(address payable _to, uint _amount) public { require(tx.origin == owner, \"Not owner\"); (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } } 黑客(假设 Eve 为黑客)可以这样进行漏洞利用。 黑客编写一个 Attack 的合约，并进行部署。 黑客通过钓鱼等手段诱导 Wallet 合约的部署者调用 Attack 合约的 attack 方法。 黑客就窃取到了 Wallet 合约的 ETH。 Attack 合约代码 contract Attack { address payable public owner; Wallet wallet; constructor(Wallet _wallet) { wallet = Wallet(_wallet); owner = payable(msg.sender); } function attack() public { wallet.transfer(owner, address(wallet).balance); } } 在这个过程中，Alice 调用了 Attack 合约的 attack 方法，attack 方法调用了 wallet 合约的 transfer 方法，在 transfer 方法中 tx.origin 是 alice(在 transfer 方法中 tx.sender 是 attack 合约)，因为 alice 就是 Wallet 合约的 owner，因此通过检测，将 ETH 转给了黑客 Eve。 还有个疑问，Alice 会傻到去调用 Eve 的合约吗？ 这依靠黑客 Eve 的钓鱼的手法，如果像上面的 attack 方法 Alice 一般不会上当，但如果方法名假装成免费 mint NFT 的函数 freemint，且代码里调用了其它的大量的正常代码，并且调用了其他的合约 C，在 C 合约里调用 wallet.transfer，可能就很难识别出该方法有问题了。而且 Alice 在正常生活中使用 DAPP 时(如使用 uniswap,stepn 等时)，后端采用的也是调用合约方法的形式，相比于直接发送虚假链接发送钓鱼邮件类的邮件，Alice 对此类钓鱼的警惕性会更低些。 所以，黑客为了钓鱼更易成功，可以从下面方面进行增强 多个合约连接。合约 A 调用合约 B，合约 B 调用合约 C，合约 C 调用合约 D，…………，最后合约中调用 wallet.transfer。 黑客的合约可以利用社会工程学伪装，利用贪便宜的心理，打低价或者免费 mint 的旗号，或者高息诱惑的方式等。 黑客可以将漏洞利用隐藏在receive函数中，通过诱导用户向指定的合约转账内触发漏洞利用。如假装与用户进行换币，给客户很大的折扣诱导等。 安全建议 建议使用 msg.sender 进行授权，而非不安全的 tx.origin ，使用不当将会造成不必要的损失。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; contract MyContract { address owner; constructor() { owner = msg.sender; } function sendTo(address payable receiver, uint amount) public { // 不安全写法：require(tx.origin == owner); require(msg.sender == owner); receiver.transfer(amount); } } 参考 Tips SWC-115 Authorization through tx.origin https://swcregistry.io/docs/SWC-115 使用 tx-origin 钓鱼 https://solidity-by-example.org/hacks/phishing-with-tx-origin 代码中的 tx.origin==msg.sender 有什么作用？ https://ethereum.stackexchange.com/questions/113962/what-does-msg-sender-tx-origin-actually-do-why https://davidkathoh.medium.com/tx-origin-vs-msg-sender-93db7f234cb9 ","date":"2019-10-01","objectID":"/blog/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html/:0:0","tags":["基础知识","合约安全","EXP","POC"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/blog/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html/"},{"categories":["基础知识"],"content":"1 跨链概念 跨链是通过连接相对独立的区块链系统，实现资产、数据等的跨链互操作，跨链的主要实现形式包括跨链资产互换和跨链资产转移。 跨链技术 2013年之前，区块链的发展主要集中在单一区块链。2013年以来，跨链技术蓬勃发展，跨链的几种主要模式相继被提出。发展到现在，包含公证人机制、侧链/中继、哈希锁定、分布式私钥控制这四种主流的跨链技术。 实现跨链的两个关键问题分别是跨链交易的原子性和跨链交易验证。哈希锁定模式利用哈希锁和时间锁能够保证跨链交易的原子性，即只有满足一定的时间条件和哈希条件交易才能够完成，从而实现跨链资产互换。对于相互独立的两条区块链而言，为实现跨链资产转移，不得不依赖于外部第三方进行信息交互，根据第三方的工作范围可以分为公证人机制和中继模式。在公证人机制下，第三方负责数据收集和交易验证；在中继模式下，第三方仅负责数据收集，交易验证由目标链完成。 总体而言，跨链技术在过去几年间得到了迅速发展，相关的项目层出不穷。现有的跨链相关项目中，基于侧链/中继模式的项目占比最高；基于哈希锁定的闪电网络自主网上线以来节点数量、通道数量和网络容量不断增长，技术可行性得到了较好的验证；通信协议簇（通过规定一系列通信数据格式与协议规范等实现区块链接入）类项目未来能否成为主流跨链方案一定程度上取决于业界对于相关标准规范的接受度。但是目前跨链技术尚未完全成熟和广泛应用,仍有较大的提升空间。此外除了跨链本身的技术形态演进，跨链技术未来的发展也与跨链技术的应用模式密切相关。 2 跨链代表 早期以Interledger与btc Relay为代表的跨链技术更多关注的是资产转移，现有跨链技术更关注跨链基础设施的落地，强调智能合约和去中心化，并接入各种跨链应用，侧重商业落地。目前跨链项目众多，最为大家所熟知的莫过于跨链双雄：Polkadot 和 Cosmos。 Polkadot是一种异构多链技术：主要由中继链、平行链和跨链桥组成。中继链相当于一个有很多插槽的插座，平行链就是各类家用电器，这些家电插上电，就能获得电力并运行。而平行链要与Polkadot之外的公链进行沟通的话就需要通过跨链桥来搭建在中继链上。 Cosmos是一个支持跨链交互的异构网络：它的目标是创建一个区块链互联网，允许大量自主且易开发的区块链互相扩展和交互。Cosmos的技术特点主要集中于三方面：一是Tendermint共识协议，属于拜占庭容错类的共识算法，在拜占庭节点数不超过 1/3的情况下，能够保证共识的安全性。二是Cosmos SDK，将共识算法和网络模块封装起来，形成一套开箱即用的区块链开发框架，开发者可以在其基础上快速定制开发适合自己需求的公链；三是IBC，也就是区块链间通信协议，它允许不同的区块链实现相互通信，也是Cosmos跨链的核心。 总结 随着区块链技术的不断发展与创新，大量区块链项目如雨后春笋般问世，万链共存是未来的趋势。跨链技术使不同领域不同功能链之间能够更好地实现互联互通与价值流动，同时还极大地降低了传输成本。当资产能够简单、安全的自由流通时，区块链生态将迎来大爆炸式增长。 ","date":"2020-02-26","objectID":"/blog/what-is-the-cross-chain-of-blockchain.html/:0:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/blog/what-is-the-cross-chain-of-blockchain.html/"},{"categories":null,"content":"专注于区块链智能合约开发和审计","date":"2019-08-02","objectID":"/blog/about/","tags":null,"title":"关于","uri":"/blog/about/"},{"categories":null,"content":"信息 专注于区块链智能合约开发和审计 ","date":"2019-08-02","objectID":"/blog/about/:1:0","tags":null,"title":"关于","uri":"/blog/about/"},{"categories":["基础知识"],"content":"1 基础语法 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:0:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.1 定义变量 var 允许对同一个变量重新定义，覆盖原有值。 var a = 1; var a = 2; let 允许修改，但不允许重新定义 let b = 1; b = 2; const 初始化后不允许修改 const c = 100; ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:1:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2 解构赋值 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:2:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.1 数组的解构赋值 let arr = [0,1,2,3,4,5,6] let [a, b, c, d] = arr console.log(a, b, c) // 0 1 2 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:2:1","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.2 对象的解构赋值 const person = { name: '5oneXj', age: 18 } let {name, age} = person console.log(name, age) // 5oneXj 18 // 如果自动推导需要同名，否则需要指定 let {name:name1, age:age1} = person console.log(name1, age1) // 5oneXj 18 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:2:2","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.3 函数参数的解构赋值 const person = { name: '5oneXj’, age: 18 } function printPerson({name, age}){ console.log(`姓名：${name}，年龄：${age}`) } printPerson(person) // 姓名：5oneXj，年龄：18 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:2:3","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.3 箭头函数 // 只适合用于普通函数 // 不要用在构造函数、不要用在成员函数、不要用在原型函数 let add = (a, b) =\u003e { return a + b } // 函数内一句可简写 let add = (a, b) =\u003e a + b console.log(add(1, 2)) // 3 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:3:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.4 Class // `函数式语言，所以一切皆函数，所有对象都是从函数原型继承而来`。 class Person { constructor(name, age){ this.name = name; this.age = age } // 注意，函数没有function method(){ console.log('Person method') } } // 继承 class Man extends Person { constructor(name, age){ super(name, age) } // 重写父类方法 method(){ console.log('Override Person method') } } let p = new Person('5oneXj', 27) p.method() // Person method let m = new Man('sxj', 27) m.method() // Override Person method 2 进阶用法 ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:4:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.1 同步调用（阻塞） var fs = require(\"fs\") var data = fs.readFileSync(\"test.text\", 'utf-8') console.log( data.toString() ) ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:5:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.2 异步调用（非阻塞） var fs = require(\"fs\") fs.readFile(\"test.text\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:6:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.3 模块导入导出 // exports.js functoin say(){ return true; } functoin hear(){ return true; } // 导出单个 module.exports = say // 导出多个， 可以使用点函数，例如 test.say() module.exports = test = { say, hear } // 导出多个需要指定对应导出方法, let {say, hear} = require(‘./exports’) module.exports = { say, hear } let test = require(‘./exports’) test.say() test.hear() ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:7:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.4 path模块 let path = require('path') let p = '/Users/jollysone/Downloads/tracks.csv' path.basename(p) // 返回路径的最后一部分，tracks.csv path.dirname(p) // 返回路径的目录名，/Users/jollysone/Downloads/ path.extname(p) // 返回路径的后缀，.csv // 拼接路径，自动过滤多余斜线，最后一个不过滤，不知道是文件还是目录 path.join('/Users/jollysone/', '/Downloads/', 'tracks.csv/') // 将一个路径正常化 path.normalize('/Users//jollysone//Downloads//tracks.csv') // 基于当前node的执行目录与路径名字拼接 path.resolve('tracks.csv') // /home/tracks.csv ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:8:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.5 文件操作模块(同步异步) var fs = require('fs') // 同步读取 var data = fs.readFileSync(\"test.txt\", 'utf-8') // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) // 同步写入 fs.writeFileSync(\"output.txt\", data.toString()) // 异步写入 fs.writeFile(\"output.txt\", data.toString(), (res) =\u003e { if(res){ console.log('异步写入失败！'); return } console.log('异步写入成功！'); }) // 同步读取文件的状态和信息，可以调取里面的成员变量信息 let stat = fs.statSync(\"output.txt\") console.log(stat.isFile); // 是否文件 console.log(stat.isDirectory); // 是否目录 // 同步删除文件 fs.unlinkSync(\"output.txt\") ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:9:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.6 Promise // 解决大量缩进的回调函数不易阅读的 callback hell 问题。 // 解决大量 异步调异步的嵌套。 new Promise(回调函数); // 异步读取文件封装成 Promise var fs = require('fs') let filePromise = new Promise(function (success, failed){ // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } // ... success(data); // 成功调用 }) }); filePromise.then(res =\u003e { console.log('data:', res); }).catch(err =\u003e { console.log(err); }) ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:10:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.7 async/await // 接上面 Promise // 直接将 Promise 异步代码变为同步写法，但是仍然是异步执行的。 async function demo(){ // 相当于 Promise.then 部分 try { let data = await filePromise } catch (e){ console.log(e); } } demo(); console.log('我是同步代码'); ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:11:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.8 Promise实际应用 // 将每个回调函数都封装成一个 Promise，然后用 async/await 将异步代码变为同步写法。 // 异步读取 Promise let readfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } success(data); }) }) } // 异步写入 Promise let writefilePromise = (data) =\u003e { return Promise((success, failed) =\u003e { fs.writeFile(\"test.txt\", data, function (err){ if(err){ failed(err); } success(‘异步写入成功’); }) }) } // 异步查询文件状态 Promise let statfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.stat(\"test.txt\", function (err, stat){ if(err){ failed(err); } success(stat); }) }) } // 异步读取 =\u003e 异步写入 =\u003e 异步查询 let demo = async () =\u003e { try { let data = await readfilePromise(); let res = await writefilePromise(data); console.log('写入结果', res); let stat = await statfilePromise(); console.log('stat:', stat); } catch (e){ console.log(e); } } 3 NPM使用 # 装淘宝镜像使用 cnpm 命令 $ npm install cnpm $ npm i cnpm # 简写 # 在项目初始化生成 package.json 文件，npm 项目都有这个文件 $ npm init # 跳过向导，快速生成 package.json 文件 $ npm init -y # 安装指定依赖包 --save 参数安装同时会更新 package.json 文件中依赖项 # npm5 以后就不需要添加 $ npm install 包名 --save # 一次性安装 package.json 中的依赖项 $ npm install # 安装指定依赖包 $ npm install 包名 $ npm install —global 包名 $ npm install 包名 包名 包名 包名 $ npm install 包名@版本号 # 卸载指定依赖包 $ npm uninstall 包名 # 查看依赖包信息 $ npm view 包名 # 查看帮助 $ npm 命令 --help # 查看 npm 配置信息 $ npm config list # 设置镜像源 $ npm config set registry https://registry.npm.taobao.org # 清理缓存 $ npm cache clean --force ","date":"2018-03-31","objectID":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/:12:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1 比特币发行量由什么决定？ 对于发行总量的粗略描述是这样的：每10分钟产生一定量的比特币，每四年减半，发行总量上限是2100万枚。 说说减半的规律，2009年1月比特币的创世区块诞生，所谓创世区块就是比特币区块链上的第0个区块，这个区块中生成的比特币数量是50个，10分钟之后系统上会出现下一个区块，生成的比特币数量依然是50个。比特币系统规定每四年比特币的产量会减半，也就是说从2009年开始，每分钟产生50个;四年之后，每10分钟产生25个;再过四年，每10分钟产生12.5个，到2140年所有的比特币将会被全部生产出来，总量是2100万。 上面就是对于比特币发行过程的粗略描述，所谓粗略，就是有些数据是不精确的，例如通过计算器就可以算出到2140年，实际发出的比特币总量是要略小于2100万的。 2 比特币2100万发行量由来 全文导读 根据区块链数据显示，币安交易所目前资产40.5亿美元，共有911个交易对，24小时成交额195.2亿美元，24小时内涨幅85.15%，在全球交易所综合排行榜中，币安交易所暂居第一位，同时币安交易所是国内三大交易所之一。 如果比特币要发展成为单一的世界货币(取代M1数字所包含的所有货币)，那么每个BTC的价值将为100万美元。因为每个比特币中有1亿个聪，所以每个聪的价值为0.01美元。 如果中本聪不是故意的，那么这些数字如此紧密地接近事实真是一个惊人的巧合。 比特币被中本聪设计上限为2100万个。通过限制其最大供应量，并减慢新比特币的出产出速度，中本聪希望每个比特币单位(目前称为“聪”)随着时间的推移而升值。 根据中本聪和比特币核心贡献者迈克·赫恩共享的一封电子邮件，中本聪认为，如果2100万个BTC被世界经济的某一部分使用，那么0.001 BTC的价值约为1欧元。 这个预测在2013年实现，当时比特币首次突破了1000欧元的价格点;如今，每个0.001个BTC的价值接近8.25欧元。 尽管中本聪在电子邮件中将比特币的价格与欧元进行了比较，但一些简单的数学运算表明他可能对比特币有更宏大的愿景，这样从侧面解释了为什么选择了上限为2100万的数字。 比特币诞生之时，全世界的货币供应量约为21万亿美元。这个数字被称为M1货币供应量，由世界上所有实物货币的总价值组成，包括现金、黄金、支票等等。 尽管M1货币供应量替代理论可能是中本聪选择2100万作为比特币上限的最合理的理由，但还有另一种(可能更简单)的解释。 查看用于控制比特币供应的参数，可以很清楚地看到2100万比特币的数字使网络能够确保在规则的时间段(10分钟)内开采区块。 它还可以确保，随着最大供应量接近其上限，作为出块奖励，支付给矿工的比特币数量会随着时间的流逝而减少。事实证明，中本聪为此设置的参数不可避免地导致最多只能生产2100万BTC。 比特币核心代码目前对挖掘难度做出了调整，以确保平均每10分钟挖掘一次新区块，而不管网络的哈希率是多少。基于此功能，每四年周期中应开采21万个区块，此后区块奖励将减半。 第一个周期看到每个区块产出了50个BTC;该数字在2012年减半至25BTC /区块，然后在2016年再次减至12.5BTC /区块。继2022年减半之后，目前位于6.25 / BTC区块。 如果向前推算，您会发现每个周期的块奖励总和等于100(50+25+6.25+3.125+1.5625+….依此类推)。通过将该数字乘以21万个块/周期图，您可以得出最大的2100万的最大供应量。 3 总结 通过以上介绍，相信大家对于比特币发行量由什么决定这个问题已经有所了解，其实对于投资者来说，在比特币交易过程中，最为重要的就是多了解，多学习，毕竟投资有风险，入市需谨慎，这句话大家都知道，举个例子，就好比开着船在大海里航行，没有人能零风险面对，左右不了市场行情的波动，只能增加舵手的能力和船的质量，那样行情的时候你的安全多一份保障，对应的面对的危险是不是少了一份。 ","date":"2018-03-06","objectID":"/blog/origin-of-bitcoins-21-million-circulation.html/:0:0","tags":["基础知识","比特币","BTC"],"title":"比特币发行量由什么决定？比特币2100万发行量由来？","uri":"/blog/origin-of-bitcoins-21-million-circulation.html/"},{"categories":["基础知识"],"content":"1 区块链的由来 区块链概念最早是从比特币衍生出来的。比特币（Bitcoin）诞生于2008年，是由一个名叫中本聪（Satoshi Nakamoto）的人首次提出，这个人非常神秘，至今没有他的任何准确信息。在提出后不久，比特币就诞生了。 比特币以及其他数字货币的核心技术称为区块链技术。区块链（Blockchain）在信息技术里是一种数据结构或数据存储方式。它创新性地组合了 密码技术、点对点（P2P）网络、分布式部署等技术，可以称其为一个划时代的理念。 2 区块链概念 区块链可以借由密码学，串接并保护内容的串联交易记录(又称区块)。在区块链中，区块内容具有 难以篡改 的特性，每一个区块都包含了 前一个区块的加密散列、相应时间戳 和 交易数据(通常用Hash树计算的散列值表示)。用区块链串接的分布式账本能让交易双方有效地记录交易，且可永久查验。 3 区块链原理 区块链技术可以认为是要解决互联网时代下的 “拜占庭将军问题”，即在网络中的中心节点和信息传递通道都缺乏可信度的情况下，如何使网络中的各个节点达成共识。 区块链技术在去中心化、各节点无须事先信任的情况下，通过加密算法、共识机制和特定的数据存储方式，构建一个集体维护的可靠的数据模式，实现数字资产在网络节点之间的转移。 拜占庭将军问题 拜占庭将军问题，首先是由Leslie Lamport与另外两人在1982年提出，故事的模型非常简单，却困扰了计算机科学家们数十年，可以说拜占庭将军问题是计算机分布式系统里的一个比较棘手的问题。 故事大概是这么说的：拜占庭帝国指的是中世纪的土耳其，拜占庭帝国拥有巨大的财富，周围有10个邻邦对拜占庭垂涎已久，但拜占庭高墙耸立，固若金汤，没有任何一个单独的邻邦能够成功入侵。任何单个邻邦入侵的都会失败，同时也有可能自身被其他9个邻邦同时入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。大家可能会想，这个还不简单，只要5个以上邻邦达成一致一起入侵，干掉拜占庭帝国岂不是很容易。然而，大家有没有想过一个问题，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么其余入侵者都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题，在拜占庭问题里，各邻国最重要的事情是：所有将军如何能过达成共识去攻打拜占庭帝国。 达成共识并非坐下来开个会那么简单，有的将军心机深不可测，口是心非，如果有叛徒，可能会出现各种各样的问题，比如：叛徒可能欺骗某些将军自己将采取进攻行动，结果最后却没有行动。或者叛徒可能怂恿其他将军行动。再或者叛徒可能迷惑其他将军，使他们接受不一致的信息，从而让对方困惑到底要不要进攻，导致无法行动。科学家们做过深入的分析和研究，最后的结论是只要叛徒的数量大于等于1/3，那么任务就会失败。 那这个问题怎么解决呢，起初科学家提出了两种解决方案： 第一个方案是口头信息协议，也就是每个邻邦的将军们派人用口信传达消息，口头协议的算法很简单，如果其中一个邻邦发消息出去是进攻还上撤退，信息会传到所有其他邻邦，然后每个邻邦收到信息同样也是将信息传递给其余所有邻邦，每个邻邦都是信息的转达者，一轮下来，每个节点手上都会有10个信息（进攻或者撤退），有叛徒的话，那信息可能有进攻或者不进攻的不一致消息。每个人相当于手里有一本消息的账本，该到底怎么决策呢？如果有一半以上的人说进攻，那么采取进攻行动就是能成功的，所以这时即便有叛徒，只要听大部分人的，少数服从多数来行动就没什么大问题。但是这种口头协议的算法也存在明显的缺点，口头协议并不会告知消息的上一个来源是谁，也就是消息不可追根溯源，出现信息不一致也很难找到叛徒在哪里。 第二个方案是书面信息协议，既然上面说的消息无法追溯根源，那就用写信，信上还要带上将军的签名，比如每个国家都向其他所有国家写信，约定几月几日几点几分一起攻打拜占庭，收到信的国家如果同意就签字盖章，这些方式相比口头信息，消息都是有记录的，有了叛徒也能会找出来。但是在现实中也面临几个问题，首先中世纪的邻邦之间沟通只能靠信使骑马，将军们互不信任，也不可能亲自聚在一起开会，物理距离导致信息传输延迟。真正可信的签名体系难以实现。签名造假的问题也没法避免。签名消息记录的保存难以摆脱中心化的机构。另外，倘若每个国家都各自向其他9个国家派出信使，在这个网络层面即需要90次的传输才能完成一轮信息交流，但是每个国家可能回馈不同的进攻时间，在这种异步通信的条件下，要能协商一致是个大问题。 这就是一个由互不信任的各个邻邦国家所构成的分布式网络，要获得最大的利益，又必须一起努力才能完成，如何达成一致的共识，变成了一个难题。 首先，数据被按时间顺序划分成区块，每一个区块存放一段时间内的所有价值交换信息，所有节点存储这段时间内的数据，并且永久保存，各个节点通过特定的计算争夺领导权，将下一时间段的信息进行打包分发，并通过某种特定的信息添加到上一区块的后面，构成区块链结构。 这种区块链结构的特点就是可以保证数据的完整性，因为每一个区块都会存储它被创建之前的所有价值交换信息;还可以保证数据的严谨性，因为一旦新的区块被加入链中，之前的区块就再也不能修改。 区块链实现了从记录到传输再到存储的全面分布式的模式，数据传输、数据验证、数据存储都去中心化，所有参与者共同构建数据库。 区块链采用非对称加密算法以提高数据的可信赖度，非对称加密即指加密和解密使用不同的密码，即公钥和私钥。加密数据所用的密码被称为公钥，是所有人都知道的、可以用来给信息加密的密码;解密数据所用的密码被称为私钥，是只有 该信息的接收者知道并用于解密的密码。公钥加密的信息只有使用对应的私钥才可以解密。 实际情况中，假设甲向乙发送一个信息，甲、乙各自生产一对公钥与私钥用以加密和解密，甲、乙分别保管自己的私钥并向对方告知公钥，如果甲向乙发送信息，那么甲用乙的公钥进行加密并向乙发送加密后的信息，乙收到消息后用自己的私钥解密，网络中其他参与者均无法解密。这种算法强度高的加密方式保证了区块链信息的可信赖度。 区块链使用数学方法解决信任问题，用算法代替中心化的第三方机构，为人们创造信用，帮助人们达成共识。 4 区块链特点 区块链技术具有去中心化、信息不可篡改、信息透明和可共同维护等特点，下面将分别进行详细阐述。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:0:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.1 去中心化 去中心化就是指网络中各个节点的地位相等，传输内容和交易数据不再需要通过某个中心节点进行，数据也不再存储在中心节点上，这样可以防止因中心节点权力过大而引起的风险。区块链模式中，每个节点都存储数据交易中所有的价值交换数据，取代了中央计算机存储所有信息的模式。 另外，每个节点不仅会参与数据存储，还会验证其他节点记录信息的正确性。只有当某个记录的正确性被大部分节点认同，或者所有节点的对比结果一致时，它才可以被写入链中。 同时，为了保护数据信息不会因节点受攻击或其他意外而丢失，区块链会对所有数据进行分布式存储(将数据存储在网络中的每一个参与的节点中)，并实时更新，极大地提高了数据库的安全性。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:1:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.2 信息不可篡改 区块链网络中，每个参与节点都保存一份完整的交易历史记录，这样，任何一个节点想篡改这些历史记录，别的节点都可以拿出自己的数据备份进行证伪。所以，信息一旦被写入区块中，就不能更改、撤销了。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:2:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.3 信息透明 区块链中的项目和数据都是公开透明的。区块链项目组会公示项目信息和项目代码，区块中的数据经处理后被公开在区块链上，意味着所有的交易信息都是公开可见的。极短时间内，区块信息会被发送到网络中的所有节点上，实现全网数据同步，每个节点都能回溯交易双方过去的所有交易信息。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:3:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.4 可共同维护 在整个区块链系统中，无论是价值的提供者还是价值的接收者，都可以充当维护者，共同维护整个区块链信息的可靠性。 区块链系统是开放的，除了价值交易双方的私有信息被加密外，系统还由其中所有参与节点共同维护，任何一个节点都可以通过公开的接口查询区块链数据和开发相关应用，共同维护整个系统的信息透明度和可信赖性。 5 区块链技术体系 第一层：数据层，存储底层数据、非对称数据加密和时间戳等基础数据。 第二层：网络层，含有分布式组网机制、数据传播机制、数据验证机制等。 第三层：共识层，封装有各类共识机制算法，确定记账决定方式，这关系到整个系统的安全性和可靠性。目前较为知名的由共识层封装的共识机制有工作量证明机制(PoW，Proof of Work)、股份授权证明机制(DPoS，Delegated Proof of Stake)、权益证明机制(PoS，Proof of Stake)等。 第四层：激励层，在区块链技术体系中使用的经济手段，包括经济激励的发行以及分配，多出现在公有链中。 第五层：合约层，封装区块链系统中的脚本代码、算法以及智能合约，帮助区块链灵活地处理数据。 第六层：应用层，封装了各种应用场景和案例，如电商购物、新闻浏览、视频观看等。 6 区块链类型 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:4:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.1 公有区块链（公链） 公有区块链（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。 公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:5:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.2 联合区块链（联盟链） 行业区块链（Consortium Block Chains)：由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易。 但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:6:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.3 私有区块链（私链） 私有区块链（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。 7 区块链应用 区块链技术已经广泛应用于生活中各个领域，例如金融、医疗、内容社交平台、慈善、教育、版权保护、投票等。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:7:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.1 金融 区块链具有的信息透明、不可篡改的特点，在金融领域得到深入应用。各类金融资产如股权、债券、基金等都可以被融入区块链中，以“数字资产”的形式在区块链上进行存储和交易。跨境支付、数字货币、数字票据、支付清算、征信管理、证券交易和保险管理等方面也能从区块链技术中获益。 例如，传统的证券交易需要由证券公司、银行、中央结算机构以及交易所多方协同工作才能共同完成，导致效率低、成本高，容错率也很低，一个环节出现漏洞就会造成巨大的问题和损失。然而，在区块链技术应用在证券交易中后，各参与方便可独立地完成整个结算流程。 再比如，跨境支付是金融领域的重要组成部分，但效率低、速度慢。然而，在区块链点对点的技术应用到跨境支付领域后，汇款通道变得透明，交易历史数据可追溯，让收款方、汇款方都安心，也大大提高了效率和速度。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:8:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.2 医疗 区块链在医疗信息安全与隐私保护方面有着极其重要的应用。在当前中心化的信息管理系统下，各种黑客攻击和系统漏洞导致信息安全问题极大，而医疗领域存储着很多用户的私密资料，数据泄露问题一旦发生，就会造成极其严重的后果。因此，医疗领域需要森严的安全措施保护数据。 区块链的去中心化的特点则有针对性地解决了这个问题。去中心化的病人医疗健康信息数据存储与共享的建立大大有益于医疗行业。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:9:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.3 内容社交平台 目前，很多内容社交平台都是中心化的，如抖音、微博、微信公众号等，中心化的意思是中心决定节点，节点必须依赖中心，节点离开了中心就无法生存。因此，平台需要做的就是提供平台，然后用户通过平台为自己带来流量，进而利用流量获利。 区块链技术可以给内容社交平台注入新的血液，它利用分布式管理将平台去中心化，在新的去中心化系统中，每个人都是一个节点，任何人也都可以成为一个中心。这样平台可以将权力分散到用户身上，用户也可以贡献出自己的力量并获得平台的奖励和经济回报。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:10:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.4 慈善 人们捐赠爱心、传递善意是一件美好而伟大的事，但是层出不穷的慈善黑幕事件给这件美好的事情增添了污点。慈善体系的不透明为这类事情提供了契机，也引发捐赠者对这个行业的担忧。 区块链技术可以大大提高慈善领域的信息透明度，让捐赠者有权对慈善体系和流程进行监督，进而鼓励捐赠者放心捐助，形成良性循环，改善慈善事业。 如利用区块链技术建立公开透明的、不可篡改的信息体系，从善款的流向到受捐赠者的身份确认，建立慈善领域的监督问责机制，增加捐赠者对机构的信任和信心，同时也保护了捐赠方和受赠方的隐私。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:11:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.5 教育 教育系统中，学历认证一直十分重要，人工验证纸质版证书的效率低下，且纸质版证书有丢失的风险。区块链由所有参与者进行维护且不可篡改，使用区块链存储和保护学生的证明文件，可以简化流程并提高学历认证的效率。 学生的学历信息和档案记录等全部存储在区块链中，当学生需要证明自己学历和相关信息时，只需让对方加入链并看见自己的文件即可。同时，区块链具有去中心化的特点，证书不会因为中心机构关闭而消失，数据永远存在。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:12:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.6 版权保护 版权保护在中国一直是大家十分关注且亟待解决的问题。但是版权登记成本较高、效率低，以及版权保护的效率低、效果差的问题一直存在。将区块链技术应用到版权保护领域，对版权所有者和其版权产出的数据进行存储，可以实现对所有权的溯源，从而达到保护版权的目的。 更高效、便捷、有效的保障内容生产者权益的方式，能激励更多的创作者继续创造新的内容，创作者通过将作品记录于区块链，实现对原创作品的追踪，一旦发生纠纷或者盗用事件，可以尽快展开进一步的措施。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:13:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.7 投票 在部分国家，投票被用于进行总统选举。投票本着公平公正、少数服从多数的原则，但是由于系统透明度低，投票结果容易引起部分参与者的怀疑。区块链去中心化和透明化的特点正好可以有针对性地解决这个问题，使投票透明、真实性强。 ","date":"2018-03-02","objectID":"/blog/what-is-blockchain.html/:14:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/what-is-blockchain.html/"}]